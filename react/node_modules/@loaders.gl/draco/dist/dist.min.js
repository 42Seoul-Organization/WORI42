!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var r=e();for(var o in r)("object"==typeof exports?exports:t)[o]=r[o]}}(window,(function(){return function(t){var e={};function r(o){if(e[o])return e[o].exports;var n=e[o]={i:o,l:!1,exports:{}};return t[o].call(n.exports,n,n.exports,r),n.l=!0,n.exports}return r.m=t,r.c=e,r.d=function(t,e,o){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)r.d(o,n,function(e){return t[e]}.bind(null,n));return o},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=3)}([function(t,e,r){"use strict";(function(t,o){r.d(e,"a",(function(){return i})),r.d(e,"b",(function(){return a})),r.d(e,"c",(function(){return s}));const n={self:"undefined"!=typeof self&&self,window:"undefined"!=typeof window&&window,global:void 0!==t&&t,document:"undefined"!=typeof document&&document},i=n.global||n.self||n.window,a="object"!=typeof o||"[object process]"!==String(o)||o.browser,s="function"==typeof importScripts,c=void 0!==o&&o.version&&o.version.match(/v([0-9]*)/);c&&parseFloat(c[1])}).call(this,r(2),r(5))},function(t,e){},function(t,e){var r;r=function(){return this}();try{r=r||new Function("return this")()}catch(t){"object"==typeof window&&(r=window)}t.exports=r},function(t,e,r){(function(e){const o=r(6),n="undefined"==typeof window?e:window;n.loaders=n.loaders||{},t.exports=Object.assign(n.loaders,o)}).call(this,r(2))},,function(t,e){var r,o,n=t.exports={};function i(){throw new Error("setTimeout has not been defined")}function a(){throw new Error("clearTimeout has not been defined")}function s(t){if(r===setTimeout)return setTimeout(t,0);if((r===i||!r)&&setTimeout)return r=setTimeout,setTimeout(t,0);try{return r(t,0)}catch(e){try{return r.call(null,t,0)}catch(e){return r.call(this,t,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:i}catch(t){r=i}try{o="function"==typeof clearTimeout?clearTimeout:a}catch(t){o=a}}();var c,d=[],u=!1,l=-1;function h(){u&&c&&(u=!1,c.length?d=c.concat(d):l=-1,d.length&&f())}function f(){if(!u){var t=s(h);u=!0;for(var e=d.length;e;){for(c=d,d=[];++l<e;)c&&c[l].run();l=-1,e=d.length}c=null,u=!1,function(t){if(o===clearTimeout)return clearTimeout(t);if((o===a||!o)&&clearTimeout)return o=clearTimeout,clearTimeout(t);try{o(t)}catch(e){try{return o.call(null,t)}catch(e){return o.call(this,t)}}}(t)}}function y(t,e){this.fun=t,this.array=e}function b(){}n.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];d.push(new y(t,e)),1!==d.length||u||s(f)},y.prototype.run=function(){this.fun.apply(null,this.array)},n.title="browser",n.browser=!0,n.env={},n.argv=[],n.version="",n.versions={},n.on=b,n.addListener=b,n.once=b,n.off=b,n.removeListener=b,n.removeAllListeners=b,n.emit=b,n.prependListener=b,n.prependOnceListener=b,n.listeners=function(t){return[]},n.binding=function(t){throw new Error("process.binding is not supported")},n.cwd=function(){return"/"},n.chdir=function(t){throw new Error("process.chdir is not supported")},n.umask=function(){return 0}},function(t,e,r){"use strict";r.r(e),r.d(e,"DracoLoader",(function(){return p})),r.d(e,"DracoWorkerLoader",(function(){return A})),r.d(e,"DracoWriter",(function(){return _}));var o=r(0),n=r(1);const i={};async function a(t,e=null,r={}){return e&&(t=function(t,e,r){const n=r.modules||{};if(n[t])return n[t];if(!o.b)return`modules/${e}/dist/libs/${t}`;if(r.CDN)return function(t,e){if(!t)throw new Error(e||"loader assertion failed.")}(r.CDN.startsWith("http")),`${r.CDN}/${e}@2.2.7/dist/libs/${t}`;if(o.c)return"../src/libs/"+t;return`modules/${e}/src/libs/${t}`}(t,e,r)),i[t]=i[t]||async function(t){if(t.endsWith("wasm")){const e=await fetch(t);return await e.arrayBuffer()}if(!o.b)return Object(n.requireFromFile)(t);if(o.c)return importScripts(t);const e=await fetch(t);return function(t,e){if(!o.b)return Object(n.requireFromString)(t,e);if(o.c)return eval.call(o.a,t),null;const r=document.createElement("script");r.id=e;try{r.appendChild(document.createTextNode(t))}catch(e){r.text=t}return document.body.appendChild(r),null}(await e.text(),t)}(t),await i[t]}let s,c;async function d(t){const e=t.modules||{};return e.draco3d?{draco:e.draco3d.createDecoderModule()}:(s=s||async function(t){let e,r;switch(t.draco&&t.draco.decoderType){case"js":e=await a("draco_decoder.js","draco",t);break;case"wasm":default:[e,r]=await Promise.all([await a("draco_wasm_wrapper.js","draco",t),await a("draco_decoder.wasm","draco",t)])}return e=e||o.a.DracoDecoderModule,await function(t,e){const r={};e&&(r.wasmBinary=e);return new Promise(e=>{t({...r,onModuleLoaded:t=>e({draco:t})})})}(e,r)}(t),await s)}async function u(t){const e=t.modules||{};return e.draco3d?{draco:e.draco3d.createEncoderModule()}:(c=c||async function(t){let e=await a("draco_encoder.js","draco",t);return e=e||o.a.DracoEncoderModule,new Promise(t=>{e({onModuleLoaded:e=>t({draco:e})})})}(t),await c)}function l(t){if(!t||!t.POSITION)return null;let e=1/0,r=1/0,o=1/0,n=-1/0,i=-1/0,a=-1/0;const s=t.POSITION.value,c=s&&s.length;if(!c)return null;for(let t=0;t<c;t+=3){const c=s[t],d=s[t+1],u=s[t+2];e=c<e?c:e,r=d<r?d:r,o=u<o?u:o,n=c>n?c:n,i=d>i?d:i,a=u>a?u:a}return[[e,r,o],[n,i,a]]}const h=0,f=1,y={POSITION:"POSITION",NORMAL:"NORMAL",COLOR:"COLOR_0",TEX_COORD:"TEXCOORD_0"},b={1:Int8Array,2:Uint8Array,3:Int16Array,4:Uint16Array,5:Int32Array,6:Uint32Array,9:Float32Array};class w{constructor(t){this.draco=t,this.drawMode="TRIANGLE"}destroy(){}destroyGeometry(t){t&&this.draco.destroy(t.dracoGeometry)}parseSync(t,e){const r=new this.draco.DecoderBuffer;r.Init(new Int8Array(t),t.byteLength);const o=new this.draco.Decoder,n={};let i,a,s;try{const t=o.GetEncodedGeometryType(r);switch(t){case this.draco.TRIANGULAR_MESH:a=new this.draco.Mesh,i=o.DecodeBufferToMesh(r,a),s={type:h,faceCount:a.num_faces(),attributeCount:a.num_attributes(),vertexCount:a.num_points()};break;case this.draco.POINT_CLOUD:a=new this.draco.PointCloud,i=o.DecodeBufferToPointCloud(r,a),s={type:f,attributeCount:a.num_attributes(),vertexCount:a.num_points()};break;default:throw new Error("Unknown DRACO geometry type.")}if(!i.ok()||!a.ptr){const t="DRACO decompression failed: "+i.error_msg();throw a&&this.draco.destroy(a),new Error(t)}n.loaderData={header:s},this.extractDRACOGeometry(o,a,t,n),n.header={vertexCount:s.vertexCount,boundingBox:l(n.attributes)}}finally{this.draco.destroy(o),this.draco.destroy(r)}return n}extractDRACOGeometry(t,e,r,o){const n=this.getAttributes(t,e),i=n.POSITION;if(!i)throw new Error("DRACO decompressor: No position attribute found.");return this.getPositionAttributeMetadata(i),r===this.draco.TRIANGULAR_MESH?(n.indices="TRIANGLE_STRIP"===this.drawMode?this.getMeshStripIndices(t,e):this.getMeshFaceIndices(t,e),o.mode="TRIANGLE_STRIP"===this.drawMode?5:4):o.mode=0,n.indices&&(o.indices={value:n.indices,size:1},delete n.indices),o.attributes=n,o}getPositionAttributeMetadata(t){this.metadata=this.metadata||{},this.metadata.attributes=this.metadata.attributes||{};const e=new this.draco.AttributeQuantizationTransform;if(e.InitFromAttribute(t)){this.metadata.attributes.position.isQuantized=!0,this.metadata.attributes.position.maxRange=e.range(),this.metadata.attributes.position.numQuantizationBits=e.quantization_bits(),this.metadata.attributes.position.minValues=new Float32Array(3);for(let t=0;t<3;++t)this.metadata.attributes.position.minValues[t]=e.min_value(t)}this.draco.destroy(e)}getAttributes(t,e){const r={},o=e.num_points();for(const n in y){const i=this.draco[n],a=t.GetAttributeId(e,i);if(-1!==a){const i=t.GetAttribute(e,a),{typedArray:s}=this.getAttributeTypedArray(t,e,i,n);r[y[n]]={value:s,size:s.length/o}}}return r}getMeshFaceIndices(t,e){const r=e.num_faces(),o=new Uint32Array(3*r),n=new this.draco.DracoInt32Array;for(let i=0;i<r;++i){t.GetFaceFromMesh(e,i,n);const r=3*i;o[r]=n.GetValue(0),o[r+1]=n.GetValue(1),o[r+2]=n.GetValue(2)}return this.draco.destroy(n),o}getMeshStripIndices(t,e){const r=new this.draco.DracoInt32Array;t.GetTriangleStripsFromMesh(e,r);const o=new Uint32Array(r.size());for(let t=0;t<r.size();++t)o[t]=r.GetValue(t);return this.draco.destroy(r),o}getAttributeTypedArray(t,e,r,o){if(0===r.ptr){throw new Error("DRACO decode bad attribute "+o)}const n=b[r.data_type()],i=r.num_components(),a=e.num_points()*i;let s,c;switch(n){case Float32Array:s=new this.draco.DracoFloat32Array,t.GetAttributeFloatForAllPoints(e,r,s),c=new Float32Array(a);break;case Int8Array:s=new this.draco.DracoInt8Array,t.GetAttributeInt8ForAllPoints(e,r,s),c=new Int8Array(a);break;case Int16Array:s=new this.draco.DracoInt16Array,t.GetAttributeInt16ForAllPoints(e,r,s),c=new Int16Array(a);break;case Int32Array:s=new this.draco.DracoInt32Array,t.GetAttributeInt32ForAllPoints(e,r,s),c=new Int32Array(a);break;case Uint8Array:s=new this.draco.DracoUInt8Array,t.GetAttributeUInt8ForAllPoints(e,r,s),c=new Uint8Array(a);break;case Uint16Array:s=new this.draco.DracoUInt16Array,t.GetAttributeUInt16ForAllPoints(e,r,s),c=new Uint16Array(a);break;case Uint32Array:s=new this.draco.DracoUInt32Array,t.GetAttributeUInt32ForAllPoints(e,r,s),c=new Uint32Array(a);break;default:throw new Error("DRACO decoder: unexpected attribute type.")}for(let t=0;t<a;t++)c[t]=s.GetValue(t);return this.draco.destroy(s),{typedArray:c,components:i}}decode(t,e){return this.parseSync(t,e)}}const A={id:"draco",name:"Draco",version:"2.2.7",extensions:["drc"],mimeTypes:["application/octet-stream"],binary:!0,test:"DRACO",options:{draco:{decoderType:"object"==typeof WebAssembly?"wasm":"js",libraryPath:"libs/",workerUrl:"https://unpkg.com/@loaders.gl/draco@2.2.7/dist/draco-loader.worker.js",localWorkerUrl:"modules/draco/dist/draco-loader.worker.dev.js"}}},p={...A,parse:async function(t,e,r,o){const{draco:n}=await d(e),i=new w(n);try{return i.parseSync(t)}finally{i.destroy()}}};const m={POSITION:"POSITION",NORMAL:"NORMAL",COLOR_0:"COLOR",TEXCOORD_0:"TEX_COORD"};function O(){}function I(t){const e=t.size(),r=new ArrayBuffer(e),o=new Int8Array(r);for(let r=0;r<e;++r)o[r]=t.GetValue(r);return r}class g{constructor(t,e={}){this.draco=t,this.dracoEncoder=new this.draco.Encoder,this.dracoMeshBuilder=new this.draco.MeshBuilder,this.log=e.log||O}destroy(){this.destroyEncodedObject(this.dracoMeshBuilder),this.destroyEncodedObject(this.dracoEncoder),this.dracoMeshBuilder=null,this.dracoEncoder=null,this.draco=null}destroyEncodedObject(t){t&&this.draco.destroy(t)}encodeSync(t,e){return this._setOptions(e),e.pointcloud?this._encodePointCloud(t):this._encodeMesh(t)}_getAttributesFromMesh(t){const e={...t,...t.attributes};return t.indices&&(e.indices=t.indices),e}_encodePointCloud(t){const e=this._getAttributesFromMesh(t),r=this._createDracoPointCloud(e),o=new this.draco.DracoInt8Array;try{const t=this.dracoEncoder.EncodePointCloudToDracoBuffer(r,!1,o);if(!(t>0))throw new Error("Draco encoding failed.");return this.log(`DRACO encoded ${r.num_points()} points\n        with ${r.num_attributes()} attributes into ${t} bytes`),I(o)}finally{this.destroyEncodedObject(o),this.destroyEncodedObject(r)}}_encodeMesh(t){const e=this._getAttributesFromMesh(t),r=this._createDracoMesh(e),o=new this.draco.DracoInt8Array;try{const t=this.dracoEncoder.EncodeMeshToDracoBuffer(r,o);if(t<=0)throw new Error("Draco encoding failed.");return this.log(`DRACO encoded ${r.num_points()} points\n        with ${r.num_attributes()} attributes into ${t} bytes`),I(o)}finally{this.destroyEncodedObject(o),this.destroyEncodedObject(r)}}_setOptions(t){if("speed"in t&&this.dracoEncoder.SetSpeedOptions(...t.speed),"method"in t){const e=this.draco[t.method];this.dracoEncoder.SetEncodingMethod(e)}if("quantization"in t)for(const e in t.quantization){const r=t.quantization[e],o=this.draco[e];this.dracoEncoder.SetAttributeQuantization(o,r)}}_createDracoMesh(t){const e=new this.draco.Mesh;try{const r=this._getPositionAttribute(t);if(!r)throw new Error("positions");const o=r.length/3;for(let r in t){const n=t[r];r=m[r]||r,this._addAttributeToMesh(e,r,n,o)}}catch(t){throw this.destroyEncodedObject(e),t}return e}_createDracoPointCloud(t){const e=new this.draco.PointCloud;try{const r=this._getPositionAttribute(t);if(!r)throw new Error("positions");const o=r.length/3;for(let r in t){const n=t[r];r=m[r]||r,this._addAttributeToMesh(e,r,n,o)}}catch(t){throw this.destroyEncodedObject(e),t}return e}_addAttributeToMesh(t,e,r,o){if(!ArrayBuffer.isView(r))return;const n=this._getDracoAttributeType(e,r),i=r.length/o;if("indices"===n){const o=r.length/3;return this.log(`Adding attribute ${e}, size ${o}`),void this.dracoMeshBuilder.AddFacesToMesh(t,o,r)}switch(this.log(`Adding attribute ${e}, size ${i}`),r.constructor.name){case"Int8Array":this.dracoMeshBuilder.AddInt8Attribute(t,n,o,i,r);break;case"Int16Array":this.dracoMeshBuilder.AddInt16Attribute(t,n,o,i,r);break;case"Int32Array":this.dracoMeshBuilder.AddInt32Attribute(t,n,o,i,r);break;case"Uint8Array":case"Uint8ClampedArray":this.dracoMeshBuilder.AddUInt8Attribute(t,n,o,i,r);break;case"Uint16Array":this.dracoMeshBuilder.AddUInt16Attribute(t,n,o,i,r);break;case"Uint32Array":this.dracoMeshBuilder.AddUInt32Attribute(t,n,o,i,r);break;case"Float32Array":default:this.dracoMeshBuilder.AddFloatAttribute(t,n,o,i,r)}}_getDracoAttributeType(t,e){switch(t.toLowerCase()){case"indices":return"indices";case"position":case"positions":case"vertices":return this.draco.POSITION;case"normal":case"normals":return this.draco.NORMAL;case"color":case"colors":return this.draco.COLOR;case"texCoord":case"texCoords":return this.draco.TEX_COORD;default:return this.draco.GENERIC}}_getPositionAttribute(t){for(const e in t){const r=t[e];if(this._getDracoAttributeType(e,r)===this.draco.POSITION)return r}return null}}var _={name:"DRACO",extensions:["drc"],encode:async function(t,e){const r=e&&e.draco||e||{},{draco:o}=await u(e||{}),n=new g(o);try{return n.encodeSync(t,r)}finally{n.destroy()}},options:{draco:{pointcloud:!1}}}}])}));