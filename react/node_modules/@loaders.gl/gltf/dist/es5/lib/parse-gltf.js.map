{"version":3,"sources":["../../../src/lib/parse-gltf.js"],"names":["isGLTF","arrayBuffer","options","dataView","DataView","byteOffset","parseGLTF","gltf","arrayBufferOrString","context","parseGLTFContainerSync","promises","loadImages","promise","push","loadBuffers","Promise","all","postProcess","data","uri","baseUri","ArrayBuffer","textDecoder","TextDecoder","decode","json","glb","type","_glb","buffers","Array","length","fill","header","hasBinChunk","binChunks","byteLength","images","i","buffer","fetch","response","loadImage","image","parse","Number","isFinite","bufferView","array","ImageLoader","parsedImage"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase, max-statements, no-restricted-globals */\n/* global TextDecoder */\nimport {ImageLoader} from '@loaders.gl/images';\nimport {parseJSON, getZeroOffsetArrayBuffer} from '@loaders.gl/loader-utils';\nimport assert from './utils/assert';\nimport {resolveUrl} from './gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from './gltf-utils/get-typed-array';\nimport {decodeExtensions} from './extensions/gltf-extensions';\nimport parseGLBSync, {isGLB} from './parse-glb';\nimport postProcessGLTF from './post-process-gltf';\n\nexport function isGLTF(arrayBuffer, options = {}) {\n  const dataView = new DataView(arrayBuffer);\n  const byteOffset = 0;\n  return isGLB(dataView, byteOffset);\n}\n\nexport async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  const promises = [];\n\n  if (options.gltf.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options.gltf.loadBuffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  // Post processing resolves indices to objects, buffers\n  return options.gltf.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\n// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb = {};\n    byteOffset = parseGLBSync(glb, data, byteOffset, options);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, `GLTF: must be ArrayBuffer or string`);\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n// Asynchronously fetch and parse buffers, store in buffers array outside of json\nasync function loadBuffers(gltf, options, context) {\n  for (let i = 0; i < gltf.json.buffers.length; ++i) {\n    const buffer = gltf.json.buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await fetch(uri);\n      const arrayBuffer = await response.arrayBuffer();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    }\n  }\n}\n\nasync function loadImages(gltf, options, context) {\n  const images = gltf.json.images || [];\n\n  const promises = [];\n  for (let i = 0; i < images.length; ++i) {\n    promises.push(loadImage(gltf, images[i], i, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n// Asynchronously fetches and parses one image, store in images array outside of json\nasync function loadImage(gltf, image, i, options, context) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = getZeroOffsetArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  const parsedImage = await parse(arrayBuffer, ImageLoader, {}, context);\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  gltf.images[i] = parsedImage;\n}\n"],"file":"parse-gltf.js"}