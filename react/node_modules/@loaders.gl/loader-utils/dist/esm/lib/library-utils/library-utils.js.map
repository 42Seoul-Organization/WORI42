{"version":3,"sources":["../../../../src/lib/library-utils/library-utils.js"],"names":["global","isBrowser","isWorker","requireFromFile","requireFromString","assert","LATEST","VERSION","loadLibraryPromises","loadLibrary","libraryUrl","moduleName","options","getLibraryUrl","loadLibraryFromFile","library","modules","CDN","startsWith","endsWith","fetch","response","arrayBuffer","importScripts","text","scriptSource","loadLibraryFromString","id","eval","call","script","document","createElement","appendChild","createTextNode","e","body"],"mappings":"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","sourcesContent":["/* global fetch, document */\nimport {global, isBrowser, isWorker} from '../env-utils/globals';\nimport {requireFromFile, requireFromString} from './require-utils.node';\nimport assert from '../env-utils/assert';\n\n// TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...\nconst LATEST = 'beta';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : LATEST;\n\nconst loadLibraryPromises = {}; // promises\n\n// Dynamically loads a library (\"module\")\nexport async function loadLibrary(libraryUrl, moduleName = null, options = {}) {\n  if (moduleName) {\n    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);\n  }\n\n  // Ensure libraries are only loaded once\n  loadLibraryPromises[libraryUrl] =\n    loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n  return await loadLibraryPromises[libraryUrl];\n}\n\n// TODO - sort out how to resolve paths for main/worker and dev/prod\nexport function getLibraryUrl(library, moduleName, options) {\n  // Allow application to import and supply libraries through `options.modules`\n  const modules = options.modules || {};\n  if (modules[library]) {\n    return modules[library];\n  }\n\n  // Load from local files, not from CDN scripts in Node.js\n  // TODO - needs to locate the modules directory when installed!\n  if (!isBrowser) {\n    return `modules/${moduleName}/dist/libs/${library}`;\n  }\n\n  // In browser, load from external scripts\n  if (options.CDN) {\n    assert(options.CDN.startsWith('http'));\n    return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${library}`;\n  }\n\n  // TODO - loading inside workers requires paths relative to worker script location...\n  if (isWorker) {\n    return `../src/libs/${library}`;\n  }\n\n  return `modules/${moduleName}/src/libs/${library}`;\n}\n\nasync function loadLibraryFromFile(libraryUrl) {\n  if (libraryUrl.endsWith('wasm')) {\n    const response = await fetch(libraryUrl);\n    return await response.arrayBuffer();\n  }\n\n  if (!isBrowser) {\n    return requireFromFile(libraryUrl);\n  }\n  if (isWorker) {\n    /* global importScripts */\n    return importScripts(libraryUrl);\n  }\n  // TODO - fix - should be more secure than string parsing since observes CORS\n  // if (isBrowser) {\n  //   return await loadScriptFromFile(libraryUrl);\n  // }\n\n  const response = await fetch(libraryUrl);\n  const scriptSource = await response.text();\n  return loadLibraryFromString(scriptSource, libraryUrl);\n}\n\n/*\nasync function loadScriptFromFile(libraryUrl) {\n  const script = document.createElement('script');\n  script.src = libraryUrl;\n  return await new Promise((resolve, reject) => {\n    script.onload = data => {\n      resolve(data);\n    };\n    script.onerror = reject;\n  });\n}\n*/\n\n// TODO - Needs security audit...\n//  - Raw eval call\n//  - Potentially bypasses CORS\n// Upside is that this separates fetching and parsing\n// we could create a`LibraryLoader` or`ModuleLoader`\nfunction loadLibraryFromString(scriptSource, id) {\n  if (!isBrowser) {\n    return requireFromString(scriptSource, id);\n  }\n\n  if (isWorker) {\n    // Use lvalue trick to make eval run in global scope\n    eval.call(global, scriptSource); // eslint-disable-line no-eval\n    // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript\n    // http://perfectionkills.com/global-eval-what-are-the-options/\n    return null;\n  }\n\n  const script = document.createElement('script');\n  script.id = id;\n  // most browsers like a separate text node but some throw an error. The second method covers those.\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n  document.body.appendChild(script);\n  return null;\n}\n\n// TODO - technique for module injection into worker, from THREE.DracoLoader...\n/*\nfunction combineWorkerWithLibrary(worker, jsContent) {\n  var fn = wWorker.toString();\n  var body = [\n    '// injected',\n    jsContent,\n    '',\n    '// worker',\n    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))\n  ].join('\\n');\n  this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n}\n*/\n"],"file":"library-utils.js"}