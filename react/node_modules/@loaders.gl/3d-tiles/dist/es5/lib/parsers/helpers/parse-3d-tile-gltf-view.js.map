{"version":3,"sources":["../../../../../src/lib/parsers/helpers/parse-3d-tile-gltf-view.js"],"names":["GLTF_FORMAT","URI","EMBEDDED","parse3DTileGLTFViewSync","tile","arrayBuffer","byteOffset","rotateYtoZ","gltfByteLength","byteLength","Error","gltfArrayBuffer","gltfByteOffset","console","warn","type","extractGLTF","gltfFormat","options","context","extractGLTFBufferOrURL","loadGLTF","parse","fetch","gltfUrl","GLTFLoader","gltf","gltfUrlBytes","Uint8Array","textDecoder","TextDecoder","decode","replace"],"mappings":";;;;;;;;;;;;;;;AAWA;;AACA;;AAEO,IAAMA,WAAW,GAAG;AACzBC,EAAAA,GAAG,EAAE,CADoB;AAEzBC,EAAAA,QAAQ,EAAE;AAFe,CAApB;;;AAKA,SAASC,uBAAT,CAAiCC,IAAjC,EAAuCC,WAAvC,EAAoDC,UAApD,EAAgE;AAIrEF,EAAAA,IAAI,CAACG,UAAL,GAAkB,IAAlB;AAGA,MAAMC,cAAc,GAAGJ,IAAI,CAACE,UAAL,GAAkBF,IAAI,CAACK,UAAvB,GAAoCH,UAA3D;;AACA,MAAIE,cAAc,KAAK,CAAvB,EAA0B;AACxB,UAAM,IAAIE,KAAJ,CAAU,0CAAV,CAAN;AACD;;AAIDN,EAAAA,IAAI,CAACO,eAAL,GAAuB,2CAAyBN,WAAzB,EAAsCC,UAAtC,EAAkDE,cAAlD,CAAvB;AACAJ,EAAAA,IAAI,CAACQ,cAAL,GAAsB,CAAtB;AACAR,EAAAA,IAAI,CAACI,cAAL,GAAsBA,cAAtB;;AAEA,MAAIF,UAAU,GAAG,CAAb,KAAmB,CAAvB,EAA0B,CAIzB,CAJD,MAIO;AAGLO,IAAAA,OAAO,CAACC,IAAR,WAAgBV,IAAI,CAACW,IAArB;AACD;;AAGD,SAAOX,IAAI,CAACE,UAAL,GAAkBF,IAAI,CAACK,UAA9B;AACD;;SAEqBO,W;;;;;iFAAf,iBAA2BZ,IAA3B,EAAiCa,UAAjC,EAA6CC,OAA7C,EAAsDC,OAAtD;AAAA;AAAA;AAAA;AAAA;AAAA;AACLC,YAAAA,sBAAsB,CAAChB,IAAD,EAAOa,UAAP,EAAmBC,OAAnB,CAAtB;;AADK,iBAGDA,OAAO,CAACG,QAHP;AAAA;AAAA;AAAA;;AAIIC,YAAAA,KAJJ,GAIoBH,OAJpB,CAIIG,KAJJ,EAIWC,KAJX,GAIoBJ,OAJpB,CAIWI,KAJX;;AAAA,iBAKCnB,IAAI,CAACoB,OALN;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAM4BD,KAAK,CAACnB,IAAI,CAACoB,OAAN,EAAeN,OAAf,CANjC;;AAAA;AAMDd,YAAAA,IAAI,CAACO,eANJ;AAODP,YAAAA,IAAI,CAACQ,cAAL,GAAsB,CAAtB;;AAPC;AAAA,iBASCR,IAAI,CAACO,eATN;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAWiBW,KAAK,CAAClB,IAAI,CAACO,eAAN,EAAuBc,gBAAvB,EAAmCP,OAAnC,EAA4CC,OAA5C,CAXtB;;AAAA;AAWDf,YAAAA,IAAI,CAACsB,IAXJ;AAYD,mBAAOtB,IAAI,CAACO,eAAZ;AACA,mBAAOP,IAAI,CAACQ,cAAZ;AACA,mBAAOR,IAAI,CAACI,cAAZ;;AAdC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAmBP,SAASY,sBAAT,CAAgChB,IAAhC,EAAsCa,UAAtC,EAAkDC,OAAlD,EAA2D;AACzD,UAAQD,UAAR;AACE,SAAKjB,WAAW,CAACC,GAAjB;AAGE,UAAM0B,YAAY,GAAG,IAAIC,UAAJ,CAAexB,IAAI,CAACO,eAApB,EAAqCP,IAAI,CAACQ,cAA1C,CAArB;AACA,UAAMiB,WAAW,GAAG,IAAIC,WAAJ,EAApB;AACA,UAAMN,OAAO,GAAGK,WAAW,CAACE,MAAZ,CAAmBJ,YAAnB,CAAhB;AACAvB,MAAAA,IAAI,CAACoB,OAAL,GAAeA,OAAO,CAACQ,OAAR,CAAgB,UAAhB,EAA4B,EAA5B,CAAf;AACA,aAAO5B,IAAI,CAACO,eAAZ;AACA,aAAOP,IAAI,CAACQ,cAAZ;AACA,aAAOR,IAAI,CAACI,cAAZ;AACA;;AACF,SAAKR,WAAW,CAACE,QAAjB;AACE;;AACF;AACE,YAAM,IAAIQ,KAAJ,mCAAN;AAfJ;AAiBD","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* global TextDecoder */\n\n// TODO - should we automatically parse the embedded glTF or leave it to the app?\n// - I.e. some apps might work directly on a GLB, in that case no need for us to decode...\n// - And if we decode, do we still keep the GLB in case it is needed?\n// - Do we add an option to control this?\n// - Also, should we have hard dependency on gltf module or use injection or auto-discovery for gltf parser?\n\nimport {GLTFLoader} from '@loaders.gl/gltf';\nimport {getZeroOffsetArrayBuffer} from '@loaders.gl/loader-utils';\n\nexport const GLTF_FORMAT = {\n  URI: 0,\n  EMBEDDED: 1\n};\n\nexport function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset) {\n  // Set flags\n  // glTF models need to be rotated from Y to Z up\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up\n  tile.rotateYtoZ = true;\n\n  // Assume glTF consumes rest of tile\n  const gltfByteLength = tile.byteOffset + tile.byteLength - byteOffset;\n  if (gltfByteLength === 0) {\n    throw new Error('glTF byte length must be greater than 0.');\n  }\n\n  // TODO - We can avoid copy if already 4-byte aligned...\n  // However the rest of the code may not be able to accept byteOffsets, so copy anyway\n  tile.gltfArrayBuffer = getZeroOffsetArrayBuffer(arrayBuffer, byteOffset, gltfByteLength);\n  tile.gltfByteOffset = 0;\n  tile.gltfByteLength = gltfByteLength;\n\n  if (byteOffset % 4 === 0) {\n    // tile.gltfArrayBuffer = arrayBuffer;\n    // tile.gltfByteOffset = byteOffset;\n    // tile.gltfByteLength = gltfByteLength;\n  } else {\n    // Create a copy of the glb so that it is 4-byte aligned\n    // eslint-disable-next-line\n    console.warn(`${tile.type}: embedded glb is not aligned to a 4-byte boundary.`);\n  }\n\n  // Entire tile is consumed\n  return tile.byteOffset + tile.byteLength;\n}\n\nexport async function extractGLTF(tile, gltfFormat, options, context) {\n  extractGLTFBufferOrURL(tile, gltfFormat, options);\n\n  if (options.loadGLTF) {\n    const {parse, fetch} = context;\n    if (tile.gltfUrl) {\n      tile.gltfArrayBuffer = await fetch(tile.gltfUrl, options);\n      tile.gltfByteOffset = 0;\n    }\n    if (tile.gltfArrayBuffer) {\n      // TODO - Should handle byteOffset... However, not used now...\n      tile.gltf = await parse(tile.gltfArrayBuffer, GLTFLoader, options, context);\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n    }\n  }\n}\n\nfunction extractGLTFBufferOrURL(tile, gltfFormat, options) {\n  switch (gltfFormat) {\n    case GLTF_FORMAT.URI:\n      // We need to remove padding from the end of the model URL in case this tile was part of a composite tile.\n      // This removes all white space and null characters from the end of the string.\n      const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);\n      const textDecoder = new TextDecoder();\n      const gltfUrl = textDecoder.decode(gltfUrlBytes);\n      tile.gltfUrl = gltfUrl.replace(/[\\s\\0]+$/, '');\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n      break;\n    case GLTF_FORMAT.EMBEDDED:\n      break;\n    default:\n      throw new Error(`b3dm: Illegal glTF format field`);\n  }\n}\n"],"file":"parse-3d-tile-gltf-view.js"}