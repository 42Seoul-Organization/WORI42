{"version":3,"sources":["../../../src/iterator-utils/async-iteration.js"],"names":["concatenateArrayBuffers","forEach","iterator","visitor","done","value","next","return","cancel","concatenateChunksAsync","asyncIterator","arrayBuffer","ArrayBuffer","string","chunk"],"mappings":";AAAA,SAAQA,uBAAR,QAAsC,uCAAtC;AAgBA,OAAO,eAAeC,OAAf,CAAuBC,QAAvB,EAAiCC,OAAjC,EAA0C;AAE/C,SAAO,IAAP,EAAa;AACX,UAAM;AAACC,MAAAA,IAAD;AAAOC,MAAAA;AAAP,QAAgB,MAAMH,QAAQ,CAACI,IAAT,EAA5B;;AACA,QAAIF,IAAJ,EAAU;AACRF,MAAAA,QAAQ,CAACK,MAAT;AACA;AACD;;AACD,UAAMC,MAAM,GAAGL,OAAO,CAACE,KAAD,CAAtB;;AACA,QAAIG,MAAJ,EAAY;AACV;AACD;AACF;AACF;AAUD,OAAO,eAAeC,sBAAf,CAAsCC,aAAtC,EAAqD;AAC1D,MAAIC,WAAW,GAAG,IAAIC,WAAJ,CAAgB,CAAhB,CAAlB;AACA,MAAIC,MAAM,GAAG,EAAb;AAF0D;AAAA;;AAAA;;AAAA;AAG1D,wCAA0BH,aAA1B,oLAAyC;AAAA,YAAxBI,KAAwB;;AACvC,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7BD,QAAAA,MAAM,IAAIC,KAAV;AACD,OAFD,MAEO;AACLH,QAAAA,WAAW,GAAGX,uBAAuB,CAACW,WAAD,EAAcG,KAAd,CAArC;AACD;AACF;AATyD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAU1D,SAAOD,MAAM,IAAIF,WAAjB;AACD","sourcesContent":["import {concatenateArrayBuffers} from '../javascript-utils/memory-copy-utils';\n\n// GENERAL UTILITIES\n\n/**\n * Iterate over async iterator, without resetting iterator if end is not reached\n * - forEach intentionally does not reset iterator if exiting loop prematurely\n *   so that iteration can continue in a second loop\n * - It is recommended to use a standard for-await as last loop to ensure\n *   iterator gets properly reset\n *\n * TODO - optimize using sync iteration if argument is an Iterable?\n *\n * @param iterator\n * @param visitor\n */\nexport async function forEach(iterator, visitor) {\n  // eslint-disable-next-line\n  while (true) {\n    const {done, value} = await iterator.next();\n    if (done) {\n      iterator.return();\n      return;\n    }\n    const cancel = visitor(value);\n    if (cancel) {\n      return;\n    }\n  }\n}\n\n// Breaking big data into iterable chunks, concatenating iterable chunks into big data objects\n\n/**\n * Concatenates all data chunks yielded by an (async) iterator\n * Supports strings and ArrayBuffers\n *\n * This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs\n */\nexport async function concatenateChunksAsync(asyncIterator) {\n  let arrayBuffer = new ArrayBuffer(0);\n  let string = '';\n  for await (const chunk of asyncIterator) {\n    if (typeof chunk === 'string') {\n      string += chunk;\n    } else {\n      arrayBuffer = concatenateArrayBuffers(arrayBuffer, chunk);\n    }\n  }\n  return string || arrayBuffer;\n}\n"],"file":"async-iteration.js"}