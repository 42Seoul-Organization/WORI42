{"ast":null,"code":"/**\r\n * JSON parser.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { DataParser } from \"./DataParser\";\nimport * as $object from \"../utils/Object\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * A parser for JSON.\r\n *\r\n * @important\r\n */\n\nvar JSONParser =\n/** @class */\nfunction (_super) {\n  __extends(JSONParser, _super);\n\n  function JSONParser() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Content-type suitable for JSON format.\r\n     */\n\n\n    _this.contentType = \"application/json\";\n    /**\r\n     * Parser options.\r\n     *\r\n     * @see {@link IJSONOptions} for description of each option\r\n     */\n\n    _this.options = {};\n    return _this;\n  }\n  /**\r\n   * Tests if the data is valid JSON.\r\n   *\r\n   * @param data  Source data\r\n   * @return Is it JSON?\r\n   */\n\n\n  JSONParser.isJSON = function (data) {\n    try {\n      // Try parsing JSON\n      JSON.parse(data); // If we got to this point it means it's a valid JSON\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n  /**\r\n   * Parses and returns data.\r\n   *\r\n   * @param data  Unparsed data\r\n   * @return Parsed data\r\n   */\n\n\n  JSONParser.prototype.parse = function (data) {\n    var _this = this; // Init return\n\n\n    var res; // Try parsing\n\n    try {\n      if ($type.hasValue(JSON)) {\n        res = JSON.parse(data);\n      }\n    } catch (e) {\n      return undefined;\n    } // Do we need to cast some fields to numbers or dates?\n\n\n    var empty = $type.hasValue(this.options.emptyAs);\n    var numbers = this.parsableNumbers;\n    var dates = this.parsableDates;\n\n    if (Array.isArray(res) && (numbers || dates || empty)) {\n      var _loop_1 = function _loop_1(i, len) {\n        var row = res[i];\n        $object.each(row, function (key, value) {\n          if (empty) {\n            row[key] = _this.maybeToEmpty(row[key]);\n          }\n\n          if (numbers) {\n            row[key] = _this.maybeToNumber(key, row[key]);\n          }\n\n          if (dates) {\n            row[key] = _this.maybeToDate(key, row[key]);\n          }\n        });\n      }; // Iterate through the data and check if it needs to be converted\n\n\n      for (var i = 0, len = res.length; i < len; i++) {\n        _loop_1(i, len);\n      }\n    } // Convert to array\n    //return Array.isArray(res) ? res : [res];\n\n\n    return res;\n  };\n\n  return JSONParser;\n}(DataParser);\n\nexport { JSONParser };","map":{"version":3,"sources":["../../../../../src/.internal/core/data/JSONParser.ts"],"names":[],"mappings":"AAAA;;;;AAIA;;;;;;;AAMA,SAAS,UAAT,QAA+C,cAA/C;AAEA,OAAO,KAAK,OAAZ,MAAyB,iBAAzB;AACA,OAAO,KAAK,KAAZ,MAAuB,eAAvB;AA6BA;;;;;;AAKA,IAAA,UAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAgC,EAAA,SAAA,CAAA,UAAA,EAAA,MAAA,CAAA;;AAAhC,WAAA,UAAA,GAAA;AAAA,QAAA,KAAA,GAAA,MAAA,KAAA,IAAA,IAAA,MAAA,CAAA,KAAA,CAAA,IAAA,EAAA,SAAA,CAAA,IAAA,IAAA;AAsBC;;;;;AAGO,IAAA,KAAA,CAAA,WAAA,GAAsB,kBAAtB;AAEP;;;;;;AAKO,IAAA,KAAA,CAAA,OAAA,GAAwB,EAAxB;;AAoDP;AAlFA;;;;;;;;AAMO,EAAA,UAAA,CAAA,MAAA,GAAP,UAAc,IAAd,EAA0B;AACzB,QAAI;AAEH;AACA,MAAA,IAAI,CAAC,KAAL,CAAW,IAAX,EAHG,CAKH;;AACA,aAAO,IAAP;AACA,KAPD,CAQA,OAAO,CAAP,EAAU;AACT,aAAO,KAAP;AACA;AACD,GAZM;AA0BP;;;;;;;;AAMO,EAAA,UAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,IAAb,EAAyB;AAAzB,QAAA,KAAA,GAAA,IAAA,CAAyB,CAExB;;;AACA,QAAI,GAAJ,CAHwB,CAKxB;;AACA,QAAI;AACH,UAAI,KAAK,CAAC,QAAN,CAAe,IAAf,CAAJ,EAA0B;AACzB,QAAA,GAAG,GAAG,IAAI,CAAC,KAAL,CAAW,IAAX,CAAN;AACA;AACD,KAJD,CAIE,OAAO,CAAP,EAAU;AACX,aAAO,SAAP;AACA,KAZuB,CAcxB;;;AACA,QAAI,KAAK,GAAG,KAAK,CAAC,QAAN,CAAe,KAAK,OAAL,CAAa,OAA5B,CAAZ;AACA,QAAI,OAAO,GAAG,KAAK,eAAnB;AACA,QAAI,KAAK,GAAG,KAAK,aAAjB;;AACA,QAAI,KAAK,CAAC,OAAN,CAAc,GAAd,MAAuB,OAAO,IAAI,KAAX,IAAoB,KAA3C,CAAJ,EAAuD;qCAG7C,C,EAAO,G,EAAG;AAClB,YAAI,GAAG,GAAG,GAAG,CAAC,CAAD,CAAb;AACA,QAAA,OAAO,CAAC,IAAR,CAAa,GAAb,EAAkB,UAAC,GAAD,EAAM,KAAN,EAAW;AAC5B,cAAI,KAAJ,EAAW;AACV,YAAA,GAAG,CAAC,GAAD,CAAH,GAAW,KAAI,CAAC,YAAL,CAAkB,GAAG,CAAC,GAAD,CAArB,CAAX;AACA;;AACD,cAAI,OAAJ,EAAa;AACZ,YAAA,GAAG,CAAC,GAAD,CAAH,GAAW,KAAI,CAAC,aAAL,CAAmB,GAAnB,EAAwB,GAAG,CAAC,GAAD,CAA3B,CAAX;AACA;;AACD,cAAI,KAAJ,EAAW;AACV,YAAA,GAAG,CAAC,GAAD,CAAH,GAAW,KAAI,CAAC,WAAL,CAAiB,GAAjB,EAAsB,GAAG,CAAC,GAAD,CAAzB,CAAX;AACA;AACD,SAVD;QALqD,CAEtD;;;AACA,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,GAAG,GAAG,GAAG,CAAC,MAA1B,EAAkC,CAAC,GAAG,GAAtC,EAA2C,CAAC,EAA5C,EAA8C;gBAArC,C,EAAO,G;AAaf;AAED,KApCuB,CAsCxB;AACA;;;AACA,WAAO,GAAP;AAEA,GA1CM;;AA4CR,SAAA,UAAA;AAAC,CApFD,CAAgC,UAAhC,CAAA","sourcesContent":["/**\r\n * JSON parser.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { DataParser, IDataParserOptions } from \"./DataParser\";\r\nimport { DateFormatter } from \"../formatters/DateFormatter\";\r\nimport * as $object from \"../utils/Object\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n\r\n/**\r\n * Defines options for JSON format parser\r\n */\r\nexport interface IJSONOptions extends IDataParserOptions {\r\n\r\n\t/**\r\n\t * A list of fields that should be treaded as numeric.\r\n\t *\r\n\t * Any information container in such fields will be converted to `number`.\r\n\t */\r\n\tnumberFields?: string[];\r\n\r\n\t/**\r\n\t * A list of fields that hold date/time infromation.\r\n\t *\r\n\t * Parser will try to convert such fields into `Date` objects.\r\n\t */\r\n\tdateFields?: string[];\r\n\r\n\t/**\r\n\t * A date formatted to be used when parsing dates.\r\n\t */\r\n\tdateFormatter?: DateFormatter;\r\n\r\n}\r\n\r\n/**\r\n * A parser for JSON.\r\n *\r\n * @important\r\n */\r\nexport class JSONParser extends DataParser {\r\n\r\n\t/**\r\n\t * Tests if the data is valid JSON.\r\n\t *\r\n\t * @param data  Source data\r\n\t * @return Is it JSON?\r\n\t */\r\n\tstatic isJSON(data: string): boolean {\r\n\t\ttry {\r\n\r\n\t\t\t// Try parsing JSON\r\n\t\t\tJSON.parse(data);\r\n\r\n\t\t\t// If we got to this point it means it's a valid JSON\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tcatch (e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Content-type suitable for JSON format.\r\n\t */\r\n\tpublic contentType: string = \"application/json\";\r\n\r\n\t/**\r\n\t * Parser options.\r\n\t *\r\n\t * @see {@link IJSONOptions} for description of each option\r\n\t */\r\n\tpublic options: IJSONOptions = {};\r\n\r\n\t/**\r\n\t * Parses and returns data.\r\n\t *\r\n\t * @param data  Unparsed data\r\n\t * @return Parsed data\r\n\t */\r\n\tpublic parse(data: string): any {\r\n\r\n\t\t// Init return\r\n\t\tlet res: any;\r\n\r\n\t\t// Try parsing\r\n\t\ttry {\r\n\t\t\tif ($type.hasValue(JSON)) {\r\n\t\t\t\tres = JSON.parse(data);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\t// Do we need to cast some fields to numbers or dates?\r\n\t\tlet empty = $type.hasValue(this.options.emptyAs);\r\n\t\tlet numbers = this.parsableNumbers;\r\n\t\tlet dates = this.parsableDates;\r\n\t\tif (Array.isArray(res) && (numbers || dates || empty)) {\r\n\r\n\t\t\t// Iterate through the data and check if it needs to be converted\r\n\t\t\tfor (let i = 0, len = res.length; i < len; i++) {\r\n\t\t\t\tlet row = res[i];\r\n\t\t\t\t$object.each(row, (key, value) => {\r\n\t\t\t\t\tif (empty) {\r\n\t\t\t\t\t\trow[key] = this.maybeToEmpty(row[key]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (numbers) {\r\n\t\t\t\t\t\trow[key] = this.maybeToNumber(key, row[key]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (dates) {\r\n\t\t\t\t\t\trow[key] = this.maybeToDate(key, row[key]);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Convert to array\r\n\t\t//return Array.isArray(res) ? res : [res];\r\n\t\treturn res;\r\n\r\n\t}\r\n\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}