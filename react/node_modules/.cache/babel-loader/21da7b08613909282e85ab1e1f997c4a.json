{"ast":null,"code":"import { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { dataLoader } from \"./DataLoader\";\nimport { JSONParser } from \"./JSONParser\";\nimport { CSVParser } from \"./CSVParser\";\nimport { BaseObjectEvents } from \"../Base\";\nimport { Adapter } from \"../utils/Adapter\";\nimport { Language } from \"../utils/Language\";\nimport { DateFormatter } from \"../formatters/DateFormatter\";\nimport { registry } from \"../Registry\";\nimport * as $type from \"../utils/Type\";\nimport * as $object from \"../utils/Object\";\n;\n;\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Represents a single data source - external file with all of its settings,\r\n * such as format, data parsing, etc.\r\n *\r\n * ```TypeScript\r\n * chart.dataSource.url = \"http://www.myweb.com/data.json\";\r\n * chart.dataSource.parser = am4core.JSONParser;\r\n * ```\r\n * ```JavaScript\r\n * chart.dataSource.url = \"http://www.myweb.com/data.json\";\r\n * chart.dataSource.parser = am4core.JSONParser;\r\n * ```\r\n * ```JSON\r\n * {\r\n *   // ...\r\n *   \"dataSource\": {\r\n *     \"url\": \"http://www.myweb.com/data.json\",\r\n *     \"parser\": \"JSONParser\"\r\n *   },\r\n *   // ...\r\n * }\r\n * ```\r\n *\r\n * @see {@link IDataSourceEvents} for a list of available events\r\n * @see {@link IDataSourceAdapters} for a list of available Adapters\r\n */\n\nvar DataSource =\n/** @class */\nfunction (_super) {\n  __extends(DataSource, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function DataSource(url, parser) {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * Adapter.\r\n     */\n\n\n    _this.adapter = new Adapter(_this);\n    /**\r\n     * Custom options for HTTP(S) request.\r\n     */\n\n    _this._requestOptions = {};\n    /**\r\n     * If set to `true`, any subsequent data loads will be considered incremental\r\n     * (containing only new data points that are supposed to be added to existing\r\n     * data).\r\n     *\r\n     * NOTE: this setting works only with element's `data` property. It won't\r\n     * work with any other externally-loadable data property.\r\n     *\r\n     * @default false\r\n     */\n\n    _this._incremental = false;\n    /**\r\n     * A collection of key/value pairs to attach to a data source URL when making\r\n     * an incremental request.\r\n     */\n\n    _this._incrementalParams = {};\n    /**\r\n     * This setting is used only when `incremental = true`. If set to `true`,\r\n     * it will try to retain the same number of data items across each load.\r\n     *\r\n     * E.g. if incremental load yeilded 5 new records, then 5 items from the\r\n     * beginning of data will be removed so that we end up with the same number\r\n     * of data items.\r\n     *\r\n     * @default false\r\n     */\n\n    _this._keepCount = false;\n    /**\r\n     * If set to `true`, each subsequent load will be treated as an update to\r\n     * currently loaded data, meaning that it will try to update values on\r\n     * existing data items, not overwrite the whole data.\r\n     *\r\n     * This will work faster than complete update, and also will animate the\r\n     * values to their new positions.\r\n     *\r\n     * Data sources across loads must contain the same number of data items.\r\n     *\r\n     * Loader will not truncate the data set if loaded data has fewer data items,\r\n     * and if it is longer, the excess data items will be ignored.\r\n     *\r\n     * @default false\r\n     * @since 4.5.5\r\n     */\n\n    _this._updateCurrentData = false;\n    /**\r\n     * Will show loading indicator when loading files.\r\n     */\n\n    _this.showPreloader = true;\n    _this.className = \"DataSource\"; // Set defaults\n\n    if (url) {\n      _this.url = url;\n    } // Set parser\n\n\n    if (parser) {\n      if (typeof parser == \"string\") {\n        _this.parser = dataLoader.getParserByType(parser);\n      } else {\n        _this.parser = parser;\n      }\n    }\n\n    return _this;\n  }\n  /**\r\n   * Processes the loaded data.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param data         Raw (unparsed) data\r\n   * @param contentType  Content type of the loaded data (optional)\r\n   */\n\n\n  DataSource.prototype.processData = function (data, contentType) {\n    // Parsing started\n    this.dispatchImmediately(\"parsestarted\"); // Check if parser is set\n\n    if (!this.parser) {\n      // Try to resolve from data\n      this.parser = dataLoader.getParserByData(data, contentType);\n\n      if (!this.parser) {\n        // We have a problem - nobody knows what to do with the data\n        // Raise error\n        if (this.events.isEnabled(\"parseerror\")) {\n          var event_1 = {\n            type: \"parseerror\",\n            message: this.language.translate(\"No parser available for file: %1\", null, this.url),\n            target: this\n          };\n          this.events.dispatchImmediately(\"parseerror\", event_1);\n        }\n\n        this.dispatchImmediately(\"parseended\");\n        return;\n      }\n    } // Apply options adapters\n\n\n    this.parser.options = this.adapter.apply(\"parserOptions\", this.parser.options);\n    this.parser.options.dateFields = this.adapter.apply(\"dateFields\", this.parser.options.dateFields || []);\n    this.parser.options.numberFields = this.adapter.apply(\"numberFields\", this.parser.options.numberFields || []); // Check if we need to pass in date formatter\n\n    if (this.parser.options.dateFields && !this.parser.options.dateFormatter) {\n      this.parser.options.dateFormatter = this.dateFormatter;\n    } // Parse\n\n\n    this.data = this.adapter.apply(\"parsedData\", this.parser.parse(this.adapter.apply(\"unparsedData\", data))); // Check for parsing errors\n\n    if (!$type.hasValue(this.data) && this.events.isEnabled(\"parseerror\")) {\n      var event_2 = {\n        type: \"parseerror\",\n        message: this.language.translate(\"Error parsing file: %1\", null, this.url),\n        target: this\n      };\n      this.events.dispatchImmediately(\"parseerror\", event_2);\n    } // Wrap up\n\n\n    this.dispatchImmediately(\"parseended\");\n\n    if ($type.hasValue(this.data)) {\n      this.dispatchImmediately(\"done\", {\n        \"data\": this.data\n      });\n    } // The component is responsible for updating its own data vtriggered via\n    // events.\n    // Update last data load\n\n\n    this.lastLoad = new Date();\n  };\n\n  Object.defineProperty(DataSource.prototype, \"url\", {\n    /**\r\n     * @return URL\r\n     */\n    get: function get() {\n      // Get URL\n      var url = this.disableCache ? this.timestampUrl(this._url) : this._url; // Add incremental params\n\n      if (this.incremental && this.component.data.length) {\n        url = this.addUrlParams(url, this.incrementalParams);\n      }\n\n      return this.adapter.apply(\"url\", url);\n    },\n\n    /**\r\n     * URL of the data source.\r\n     *\r\n     * @param value  URL\r\n     */\n    set: function set(value) {\n      this._url = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"requestOptions\", {\n    /**\r\n     * @return Options\r\n     */\n    get: function get() {\n      return this.adapter.apply(\"requestOptions\", this._requestOptions);\n    },\n\n    /**\r\n     * Custom options for HTTP(S) request.\r\n     *\r\n     * At this moment the only option supported is: `requestHeaders`, which holds\r\n     * an array of objects for custom request headers, e.g.:\r\n     *\r\n     * ```TypeScript\r\n     * chart.dataSource.requestOptions.requestHeaders = [{\r\n     *   \"key\": \"x-access-token\",\r\n     *   \"value\": \"123456789\"\r\n     * }];\r\n     * ``````JavaScript\r\n     * chart.dataSource.requestOptions.requestHeaders = [{\r\n     *   \"key\": \"x-access-token\",\r\n     *   \"value\": \"123456789\"\r\n     * }];\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"dataSource\": {\r\n     *     // ...\r\n     *     \"requestOptions\": {\r\n     *       \"requestHeaders\": [{\r\n     *         \"key\": \"x-access-token\",\r\n     *         \"value\": \"123456789\"\r\n     *       }]\r\n     *     }\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * NOTE: setting this options on an-already loaded DataSource will not\r\n     * trigger a reload.\r\n     *\r\n     * @param value  Options\r\n     */\n    set: function set(value) {\n      this._requestOptions = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"parser\", {\n    /**\r\n     * @return Data parser\r\n     */\n    get: function get() {\n      if (!this._parser) {\n        this._parser = new JSONParser();\n      }\n\n      return this.adapter.apply(\"parser\", this._parser);\n    },\n\n    /**\r\n     * A parser to be used to parse data.\r\n     *\r\n     * ```TypeScript\r\n     * chart.dataSource.url = \"http://www.myweb.com/data.json\";\r\n     * chart.dataSource.parser = am4core.JSONParser;\r\n     * ```\r\n     * ```JavaScript\r\n     * chart.dataSource.url = \"http://www.myweb.com/data.json\";\r\n     * chart.dataSource.parser = am4core.JSONParser;\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"dataSource\": {\r\n     *     \"url\": \"http://www.myweb.com/data.json\",\r\n     *     \"parser\": \"JSONParser\"\r\n     *   },\r\n     *   // ...\r\n     * }\r\n     * ```\r\n     *\r\n     * @default JSONParser\r\n     * @param value  Data parser\r\n     */\n    set: function set(value) {\n      this._parser = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"reloadFrequency\", {\n    /**\r\n     * @return Reload frequency (ms)\r\n     */\n    get: function get() {\n      return this.adapter.apply(\"reloadTimeout\", this._reloadFrequency);\n    },\n\n    /**\r\n     * Data source reload frequency.\r\n     *\r\n     * If set, it will reload the same URL every X milliseconds.\r\n     *\r\n     * @param value Reload frequency (ms)\r\n     */\n    set: function set(value) {\n      var _this = this;\n\n      if (this._reloadFrequency != value) {\n        this._reloadFrequency = value; // Should we schedule a reload?\n\n        if (value) {\n          if (!$type.hasValue(this._reloadDisposer)) {\n            this._reloadDisposer = this.events.on(\"ended\", function (ev) {\n              _this._reloadTimeout = setTimeout(function () {\n                _this.load();\n              }, _this.reloadFrequency);\n            });\n          }\n        } else if ($type.hasValue(this._reloadDisposer)) {\n          this._reloadDisposer.dispose();\n\n          this._reloadDisposer = undefined;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"incremental\", {\n    /**\r\n     * @return Incremental load?\r\n     */\n    get: function get() {\n      return this.adapter.apply(\"incremental\", this._incremental);\n    },\n\n    /**\r\n     * Should subsequent reloads be treated as incremental?\r\n     *\r\n     * Incremental loads will assume that they contain only new data items\r\n     * since the last load.\r\n     *\r\n     * If `incremental = false` the loader will replace all of the target's\r\n     * data with each load.\r\n     *\r\n     * This setting does not have any effect trhe first time data is loaded.\r\n     *\r\n     * NOTE: this setting works only with element's `data` property. It won't\r\n     * work with any other externally-loadable data property.\r\n     *\r\n     * @default false\r\n     * @param Incremental load?\r\n     */\n    set: function set(value) {\n      this._incremental = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"incrementalParams\", {\n    /**\r\n     * @return Incremental request parameters\r\n     */\n    get: function get() {\n      return this.adapter.apply(\"incrementalParams\", this._incrementalParams);\n    },\n\n    /**\r\n     * An object consisting of key/value pairs to apply to an URL when data\r\n     * source is making an incremental request.\r\n     *\r\n     * @param value  Incremental request parameters\r\n     */\n    set: function set(value) {\n      this._incrementalParams = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"keepCount\", {\n    /**\r\n     * @return keepCount load?\r\n     */\n    get: function get() {\n      return this.adapter.apply(\"keepCount\", this._keepCount);\n    },\n\n    /**\r\n     * This setting is used only when `incremental = true`. If set to `true`,\r\n     * it will try to retain the same number of data items across each load.\r\n     *\r\n     * E.g. if incremental load yeilded 5 new records, then 5 items from the\r\n     * beginning of data will be removed so that we end up with the same number\r\n     * of data items.\r\n     *\r\n     * @default false\r\n     * @param Keep record count?\r\n     */\n    set: function set(value) {\n      this._keepCount = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"updateCurrentData\", {\n    /**\r\n     * @return Update current data?\r\n     */\n    get: function get() {\n      return this.adapter.apply(\"updateCurrentData\", this._updateCurrentData);\n    },\n\n    /**\r\n     * If set to `true`, each subsequent load will be treated as an update to\r\n     * currently loaded data, meaning that it will try to update values on\r\n     * existing data items, not overwrite the whole data.\r\n     *\r\n     * This will work faster than complete update, and also will animate the\r\n     * values to their new positions.\r\n     *\r\n     * Data sources across loads must contain the same number of data items.\r\n     *\r\n     * Loader will not truncate the data set if loaded data has fewer data items,\r\n     * and if it is longer, the excess data items will be ignored.\r\n     *\r\n     * NOTE: this setting is ignored if `incremental = true`.\r\n     *\r\n     * @default false\r\n     * @since 2.5.5\r\n     * @param Update current data?\r\n     */\n    set: function set(value) {\n      this._updateCurrentData = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"language\", {\n    /**\r\n     * @return A [[Language]] instance to be used\r\n     */\n    get: function get() {\n      if (this._language) {\n        return this._language;\n      } else if (this.component) {\n        this._language = this.component.language;\n        return this._language;\n      }\n\n      this.language = new Language();\n      return this.language;\n    },\n\n    /**\r\n     * Language instance to use.\r\n     *\r\n     * Will inherit and use chart's language, if not set.\r\n     *\r\n     * @param value An instance of Language\r\n     */\n    set: function set(value) {\n      this._language = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"dateFormatter\", {\n    /**\r\n     * @return A [[DateFormatter]] instance to be used\r\n     */\n    get: function get() {\n      if (this._dateFormatter) {\n        return this._dateFormatter;\n      } else if (this.component) {\n        this._dateFormatter = this.component.dateFormatter;\n        return this._dateFormatter;\n      }\n\n      this.dateFormatter = new DateFormatter();\n      return this.dateFormatter;\n    },\n\n    /**\r\n     * A [[DateFormatter]] to use when parsing dates from string formats.\r\n     *\r\n     * Will inherit and use chart's DateFormatter if not ser.\r\n     *\r\n     * @param value An instance of [[DateFormatter]]\r\n     */\n    set: function set(value) {\n      this._dateFormatter = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Adds current timestamp to the URL.\r\n   *\r\n   * @param url  Source URL\r\n   * @return Timestamped URL\r\n   */\n\n  DataSource.prototype.timestampUrl = function (url) {\n    var tstamp = new Date().getTime().toString();\n    var params = {};\n    params[tstamp] = \"\";\n    return this.addUrlParams(url, params);\n  };\n  /**\r\n   * Disposes of this object.\r\n   */\n\n\n  DataSource.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    if (this._reloadTimeout) {\n      clearTimeout(this._reloadTimeout);\n    }\n\n    if ($type.hasValue(this._reloadDisposer)) {\n      this._reloadDisposer.dispose();\n\n      this._reloadDisposer = undefined;\n    }\n  };\n  /**\r\n   * Initiate the load.\r\n   *\r\n   * All loading in JavaScript is asynchronous. This function will trigger the\r\n   * load and will exit immediately.\r\n   *\r\n   * Use DataSource's events to watch for loaded data and errors.\r\n   */\n\n\n  DataSource.prototype.load = function () {\n    if (this.url) {\n      if (this._reloadTimeout) {\n        clearTimeout(this._reloadTimeout);\n      }\n\n      dataLoader.load(this);\n    }\n  };\n  /**\r\n   * Adds parameters to `url` as query strings. Will take care of proper\r\n   * separators.\r\n   *\r\n   * @param url     Source URL\r\n   * @param params  Parameters\r\n   * @return New URL\r\n   */\n\n\n  DataSource.prototype.addUrlParams = function (url, params) {\n    var join = url.match(/\\?/) ? \"&\" : \"?\";\n    var add = [];\n    $object.each(params, function (key, value) {\n      if (value != \"\") {\n        add.push(key + \"=\" + encodeURIComponent(value));\n      } else {\n        add.push(key);\n      }\n    });\n\n    if (add.length) {\n      return url + join + add.join(\"&\");\n    }\n\n    return url;\n  };\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n\n  DataSource.prototype.processConfig = function (config) {\n    registry.registeredClasses[\"json\"] = JSONParser;\n    registry.registeredClasses[\"JSONParser\"] = JSONParser;\n    registry.registeredClasses[\"csv\"] = CSVParser;\n    registry.registeredClasses[\"CSVParser\"] = CSVParser;\n\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return DataSource;\n}(BaseObjectEvents);\n\nexport { DataSource };","map":{"version":3,"sources":["../../../../../src/.internal/core/data/DataSource.ts"],"names":[],"mappings":";AAAA;;;;;;;AAMA,SAAS,UAAT,QAA2B,cAA3B;AAEA,SAAS,UAAT,QAA2B,cAA3B;AACA,SAAS,SAAT,QAA0B,aAA1B;AACA,SAAS,gBAAT,QAAoD,SAApD;AAEA,SAAS,OAAT,QAAwB,kBAAxB;AAEA,SAAS,QAAT,QAAyB,mBAAzB;AACA,SAAS,aAAT,QAA8B,6BAA9B;AAGA,SAAS,QAAT,QAAyB,aAAzB;AACA,OAAO,KAAK,KAAZ,MAAuB,eAAvB;AACA,OAAO,KAAK,OAAZ,MAAyB,iBAAzB;AAmEC;AA2EA;AAGD;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,IAAA,UAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAgC,EAAA,SAAA,CAAA,UAAA,EAAA,MAAA,CAAA;AAoI/B;;;;;AAGA,WAAA,UAAA,CAAY,GAAZ,EAA0B,MAA1B,EAAsD;AAAtD,QAAA,KAAA,GAEC;AACA,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IAHR;AA3HA;;;;;AAGO,IAAA,KAAA,CAAA,OAAA,GAAoD,IAAI,OAAJ,CAA6C,KAA7C,CAApD;AA4BP;;;;AAGU,IAAA,KAAA,CAAA,eAAA,GAAsC,EAAtC;AAiBV;;;;;;;;;;;AAUU,IAAA,KAAA,CAAA,YAAA,GAAwB,KAAxB;AAEV;;;;;AAIU,IAAA,KAAA,CAAA,kBAAA,GAAkD,EAAlD;AAEV;;;;;;;;;;;AAUU,IAAA,KAAA,CAAA,UAAA,GAAsB,KAAtB;AAEV;;;;;;;;;;;;;;;;;AAgBU,IAAA,KAAA,CAAA,kBAAA,GAA8B,KAA9B;AAaV;;;;AAGO,IAAA,KAAA,CAAA,aAAA,GAAyB,IAAzB;AAcN,IAAA,KAAI,CAAC,SAAL,GAAiB,YAAjB,CAJqD,CAMrD;;AACA,QAAI,GAAJ,EAAS;AACR,MAAA,KAAI,CAAC,GAAL,GAAW,GAAX;AACA,KAToD,CAWrD;;;AACA,QAAI,MAAJ,EAAY;AACX,UAAI,OAAO,MAAP,IAAiB,QAArB,EAA+B;AAC9B,QAAA,KAAI,CAAC,MAAL,GAAc,UAAU,CAAC,eAAX,CAA2B,MAA3B,CAAd;AACA,OAFD,MAGK;AACJ,QAAA,KAAI,CAAC,MAAL,GAAc,MAAd;AACA;AACD;;;AAED;AAED;;;;;;;;;AAOO,EAAA,UAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,IAAnB,EAAiC,WAAjC,EAAqD;AACpD;AACA,SAAK,mBAAL,CAAyB,cAAzB,EAFoD,CAIpD;;AACA,QAAI,CAAC,KAAK,MAAV,EAAkB;AAEjB;AACA,WAAK,MAAL,GAAc,UAAU,CAAC,eAAX,CAA2B,IAA3B,EAAiC,WAAjC,CAAd;;AAEA,UAAI,CAAC,KAAK,MAAV,EAAkB;AACjB;AACA;AACA,YAAI,KAAK,MAAL,CAAY,SAAZ,CAAsB,YAAtB,CAAJ,EAAyC;AACxC,cAAM,OAAK,GAAmD;AAC7D,YAAA,IAAI,EAAE,YADuD;AAE7D,YAAA,OAAO,EAAE,KAAK,QAAL,CAAc,SAAd,CAAwB,kCAAxB,EAA4D,IAA5D,EAAkE,KAAK,GAAvE,CAFoD;AAG7D,YAAA,MAAM,EAAE;AAHqD,WAA9D;AAKA,eAAK,MAAL,CAAY,mBAAZ,CAAgC,YAAhC,EAA8C,OAA9C;AACA;;AACD,aAAK,mBAAL,CAAyB,YAAzB;AACA;AACA;AAED,KAzBmD,CA2BpD;;;AACA,SAAK,MAAL,CAAY,OAAZ,GAAsB,KAAK,OAAL,CAAa,KAAb,CAAmB,eAAnB,EAAoC,KAAK,MAAL,CAAY,OAAhD,CAAtB;AACA,SAAK,MAAL,CAAY,OAAZ,CAAoB,UAApB,GAAiC,KAAK,OAAL,CAAa,KAAb,CAAmB,YAAnB,EAAiC,KAAK,MAAL,CAAY,OAAZ,CAAoB,UAApB,IAAkC,EAAnE,CAAjC;AACA,SAAK,MAAL,CAAY,OAAZ,CAAoB,YAApB,GAAmC,KAAK,OAAL,CAAa,KAAb,CAAmB,cAAnB,EAAmC,KAAK,MAAL,CAAY,OAAZ,CAAoB,YAApB,IAAoC,EAAvE,CAAnC,CA9BoD,CAgCpD;;AACA,QAAI,KAAK,MAAL,CAAY,OAAZ,CAAoB,UAApB,IAAkC,CAAC,KAAK,MAAL,CAAY,OAAZ,CAAoB,aAA3D,EAA0E;AACzE,WAAK,MAAL,CAAY,OAAZ,CAAoB,aAApB,GAAoC,KAAK,aAAzC;AACA,KAnCmD,CAqCpD;;;AACA,SAAK,IAAL,GAAY,KAAK,OAAL,CAAa,KAAb,CACX,YADW,EAEX,KAAK,MAAL,CAAY,KAAZ,CACC,KAAK,OAAL,CAAa,KAAb,CAAmB,cAAnB,EAAmC,IAAnC,CADD,CAFW,CAAZ,CAtCoD,CA6CpD;;AACA,QAAI,CAAC,KAAK,CAAC,QAAN,CAAe,KAAK,IAApB,CAAD,IAA8B,KAAK,MAAL,CAAY,SAAZ,CAAsB,YAAtB,CAAlC,EAAuE;AACtE,UAAM,OAAK,GAAmD;AAC7D,QAAA,IAAI,EAAE,YADuD;AAE7D,QAAA,OAAO,EAAE,KAAK,QAAL,CAAc,SAAd,CAAwB,wBAAxB,EAAkD,IAAlD,EAAwD,KAAK,GAA7D,CAFoD;AAG7D,QAAA,MAAM,EAAE;AAHqD,OAA9D;AAKA,WAAK,MAAL,CAAY,mBAAZ,CAAgC,YAAhC,EAA8C,OAA9C;AACA,KArDmD,CAuDpD;;;AACA,SAAK,mBAAL,CAAyB,YAAzB;;AAEA,QAAI,KAAK,CAAC,QAAN,CAAe,KAAK,IAApB,CAAJ,EAA+B;AAC9B,WAAK,mBAAL,CAAyB,MAAzB,EAAiC;AAChC,gBAAQ,KAAK;AADmB,OAAjC;AAGA,KA9DmD,CAgEpD;AACA;AAEA;;;AACA,SAAK,QAAL,GAAgB,IAAI,IAAJ,EAAhB;AAEA,GAtEM;;AA6EP,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,KAAX,EAAc;AAId;;;SAGA,eAAA;AAEC;AACA,UAAI,GAAG,GAAG,KAAK,YAAL,GACP,KAAK,YAAL,CAAkB,KAAK,IAAvB,CADO,GAEP,KAAK,IAFR,CAHD,CAOC;;AACA,UAAI,KAAK,WAAL,IAAoB,KAAK,SAAL,CAAe,IAAf,CAAoB,MAA5C,EAAoD;AACnD,QAAA,GAAG,GAAG,KAAK,YAAL,CAAkB,GAAlB,EAAuB,KAAK,iBAA5B,CAAN;AACA;;AAED,aAAO,KAAK,OAAL,CAAa,KAAb,CAAmB,KAAnB,EAA0B,GAA1B,CAAP;AAEA,KArBa;;AALd;;;;;SAKA,aAAe,KAAf,EAA4B;AAC3B,WAAK,IAAL,GAAY,KAAZ;AACA,KAFa;oBAAA;;AAAA,GAAd;AA4DA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,gBAAX,EAAyB;AAIzB;;;SAGA,eAAA;AACC,aAAO,KAAK,OAAL,CAAa,KAAb,CAAmB,gBAAnB,EAAqC,KAAK,eAA1C,CAAP;AACA,KATwB;;AArCzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAqCA,aAA0B,KAA1B,EAAmD;AAClD,WAAK,eAAL,GAAuB,KAAvB;AACA,KAFwB;oBAAA;;AAAA,GAAzB;AAoCA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,QAAX,EAAiB;AAIjB;;;SAGA,eAAA;AACC,UAAI,CAAC,KAAK,OAAV,EAAmB;AAClB,aAAK,OAAL,GAAe,IAAI,UAAJ,EAAf;AACA;;AACD,aAAO,KAAK,OAAL,CAAa,KAAb,CAAmB,QAAnB,EAA6B,KAAK,OAAlC,CAAP;AACA,KAZgB;;AAzBjB;;;;;;;;;;;;;;;;;;;;;;;;;SAyBA,aAAkB,KAAlB,EAAmC;AAClC,WAAK,OAAL,GAAe,KAAf;AACA,KAFgB;oBAAA;;AAAA,GAAjB;AAqBA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,iBAAX,EAA0B;AAqB1B;;;SAGA,eAAA;AACC,aAAO,KAAK,OAAL,CAAa,KAAb,CAAmB,eAAnB,EAAoC,KAAK,gBAAzC,CAAP;AACA,KA1ByB;;AAP1B;;;;;;;SAOA,aAA2B,KAA3B,EAAwC;AAAxC,UAAA,KAAA,GAAA,IAAA;;AACC,UAAI,KAAK,gBAAL,IAAyB,KAA7B,EAAoC;AACnC,aAAK,gBAAL,GAAwB,KAAxB,CADmC,CAGnC;;AACA,YAAI,KAAJ,EAAW;AACV,cAAI,CAAC,KAAK,CAAC,QAAN,CAAe,KAAK,eAApB,CAAL,EAA2C;AAC1C,iBAAK,eAAL,GAAuB,KAAK,MAAL,CAAY,EAAZ,CAAe,OAAf,EAAwB,UAAC,EAAD,EAAG;AACjD,cAAA,KAAI,CAAC,cAAL,GAAsB,UAAU,CAAC,YAAA;AAChC,gBAAA,KAAI,CAAC,IAAL;AACA,eAF+B,EAE7B,KAAI,CAAC,eAFwB,CAAhC;AAGA,aAJsB,CAAvB;AAKA;AACD,SARD,MASK,IAAI,KAAK,CAAC,QAAN,CAAe,KAAK,eAApB,CAAJ,EAA0C;AAC9C,eAAK,eAAL,CAAqB,OAArB;;AACA,eAAK,eAAL,GAAuB,SAAvB;AACA;AACD;AACD,KAnByB;oBAAA;;AAAA,GAA1B;AA6CA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,aAAX,EAAsB;AAItB;;;SAGA,eAAA;AACC,aAAO,KAAK,OAAL,CAAa,KAAb,CAAmB,aAAnB,EAAkC,KAAK,YAAvC,CAAP;AACA,KATqB;;AAjBtB;;;;;;;;;;;;;;;;;SAiBA,aAAuB,KAAvB,EAAqC;AACpC,WAAK,YAAL,GAAoB,KAApB;AACA,KAFqB;oBAAA;;AAAA,GAAtB;AAiBA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,mBAAX,EAA4B;AAI5B;;;SAGA,eAAA;AACC,aAAO,KAAK,OAAL,CAAa,KAAb,CAAmB,mBAAnB,EAAwC,KAAK,kBAA7C,CAAP;AACA,KAT2B;;AAN5B;;;;;;SAMA,aAA6B,KAA7B,EAA+D;AAC9D,WAAK,kBAAL,GAA0B,KAA1B;AACA,KAF2B;oBAAA;;AAAA,GAA5B;AAsBA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,WAAX,EAAoB;AAIpB;;;SAGA,eAAA;AACC,aAAO,KAAK,OAAL,CAAa,KAAb,CAAmB,WAAnB,EAAgC,KAAK,UAArC,CAAP;AACA,KATmB;;AAXpB;;;;;;;;;;;SAWA,aAAqB,KAArB,EAAmC;AAClC,WAAK,UAAL,GAAkB,KAAlB;AACA,KAFmB;oBAAA;;AAAA,GAApB;AA8BA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,mBAAX,EAA4B;AAI5B;;;SAGA,eAAA;AACC,aAAO,KAAK,OAAL,CAAa,KAAb,CAAmB,mBAAnB,EAAwC,KAAK,kBAA7C,CAAP;AACA,KAT2B;;AAnB5B;;;;;;;;;;;;;;;;;;;SAmBA,aAA6B,KAA7B,EAA2C;AAC1C,WAAK,kBAAL,GAA0B,KAA1B;AACA,KAF2B;oBAAA;;AAAA,GAA5B;AAkBA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,UAAX,EAAmB;AAInB;;;SAGA,eAAA;AACC,UAAI,KAAK,SAAT,EAAoB;AACnB,eAAO,KAAK,SAAZ;AACA,OAFD,MAGK,IAAI,KAAK,SAAT,EAAoB;AACxB,aAAK,SAAL,GAAiB,KAAK,SAAL,CAAe,QAAhC;AACA,eAAO,KAAK,SAAZ;AACA;;AACD,WAAK,QAAL,GAAgB,IAAI,QAAJ,EAAhB;AACA,aAAO,KAAK,QAAZ;AACA,KAjBkB;;AAPnB;;;;;;;SAOA,aAAoB,KAApB,EAAmC;AAClC,WAAK,SAAL,GAAiB,KAAjB;AACA,KAFkB;oBAAA;;AAAA,GAAnB;AA0BA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,eAAX,EAAwB;AAIxB;;;SAGA,eAAA;AACC,UAAI,KAAK,cAAT,EAAyB;AACxB,eAAO,KAAK,cAAZ;AACA,OAFD,MAGK,IAAI,KAAK,SAAT,EAAoB;AACxB,aAAK,cAAL,GAAsB,KAAK,SAAL,CAAe,aAArC;AACA,eAAO,KAAK,cAAZ;AACA;;AACD,WAAK,aAAL,GAAqB,IAAI,aAAJ,EAArB;AACA,aAAO,KAAK,aAAZ;AACA,KAjBuB;;AAPxB;;;;;;;SAOA,aAAyB,KAAzB,EAA6C;AAC5C,WAAK,cAAL,GAAsB,KAAtB;AACA,KAFuB;oBAAA;;AAAA,GAAxB;AAmBA;;;;;;;AAMO,EAAA,UAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,GAApB,EAA+B;AAC9B,QAAI,MAAM,GAAG,IAAI,IAAJ,GAAW,OAAX,GAAqB,QAArB,EAAb;AACA,QAAI,MAAM,GAAgC,EAA1C;AACA,IAAA,MAAM,CAAC,MAAD,CAAN,GAAiB,EAAjB;AACA,WAAO,KAAK,YAAL,CAAkB,GAAlB,EAAuB,MAAvB,CAAP;AACA,GALM;AAOP;;;;;AAGO,EAAA,UAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACC,IAAA,MAAA,CAAA,SAAA,CAAM,OAAN,CAAa,IAAb,CAAa,IAAb;;AACA,QAAI,KAAK,cAAT,EAAyB;AACxB,MAAA,YAAY,CAAC,KAAK,cAAN,CAAZ;AACA;;AACD,QAAI,KAAK,CAAC,QAAN,CAAe,KAAK,eAApB,CAAJ,EAA0C;AACzC,WAAK,eAAL,CAAqB,OAArB;;AACA,WAAK,eAAL,GAAuB,SAAvB;AACA;AACD,GATM;AAWP;;;;;;;;;;AAQO,EAAA,UAAA,CAAA,SAAA,CAAA,IAAA,GAAP,YAAA;AACC,QAAI,KAAK,GAAT,EAAc;AACb,UAAI,KAAK,cAAT,EAAyB;AACxB,QAAA,YAAY,CAAC,KAAK,cAAN,CAAZ;AACA;;AACD,MAAA,UAAU,CAAC,IAAX,CAAgB,IAAhB;AACA;AACD,GAPM;AASP;;;;;;;;;;AAQO,EAAA,UAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,GAApB,EAAiC,MAAjC,EAAoE;AACnE,QAAI,IAAI,GAAG,GAAG,CAAC,KAAJ,CAAU,IAAV,IAAkB,GAAlB,GAAwB,GAAnC;AACA,QAAI,GAAG,GAAa,EAApB;AACA,IAAA,OAAO,CAAC,IAAR,CAAa,MAAb,EAAqB,UAAC,GAAD,EAAM,KAAN,EAAW;AAC/B,UAAI,KAAK,IAAI,EAAb,EAAiB;AAChB,QAAA,GAAG,CAAC,IAAJ,CAAS,GAAG,GAAG,GAAN,GAAY,kBAAkB,CAAC,KAAD,CAAvC;AACA,OAFD,MAGK;AACJ,QAAA,GAAG,CAAC,IAAJ,CAAS,GAAT;AACA;AACD,KAPD;;AAQA,QAAI,GAAG,CAAC,MAAR,EAAgB;AACf,aAAO,GAAG,GAAG,IAAN,GAAa,GAAG,CAAC,IAAJ,CAAS,GAAT,CAApB;AACA;;AACD,WAAO,GAAP;AACA,GAfM;AAiBP;;;;;;;;AAMO,EAAA,UAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,MAArB,EAAsD;AAErD,IAAA,QAAQ,CAAC,iBAAT,CAA2B,MAA3B,IAAqC,UAArC;AACA,IAAA,QAAQ,CAAC,iBAAT,CAA2B,YAA3B,IAA2C,UAA3C;AACA,IAAA,QAAQ,CAAC,iBAAT,CAA2B,KAA3B,IAAoC,SAApC;AACA,IAAA,QAAQ,CAAC,iBAAT,CAA2B,WAA3B,IAA0C,SAA1C;;AAEA,IAAA,MAAA,CAAA,SAAA,CAAM,aAAN,CAAmB,IAAnB,CAAmB,IAAnB,EAAoB,MAApB;AAEA,GATM;;AAWR,SAAA,UAAA;AAAC,CA9mBD,CAAgC,gBAAhC,CAAA","sourcesContent":["/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { dataLoader } from \"./DataLoader\";\r\nimport { DataParser } from \"./DataParser\";\r\nimport { JSONParser } from \"./JSONParser\";\r\nimport { CSVParser } from \"./CSVParser\";\r\nimport { BaseObjectEvents, IBaseObjectEvents } from \"../Base\";\r\nimport { Component } from \"../Component\";\r\nimport { Adapter } from \"../utils/Adapter\";\r\nimport { AMEvent } from \"../utils/EventDispatcher\";\r\nimport { Language } from \"../utils/Language\";\r\nimport { DateFormatter } from \"../formatters/DateFormatter\";\r\nimport { INetRequestOptions } from \"../utils/Net\";\r\nimport { IDisposer } from \"../utils/Disposer\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $type from \"../utils/Type\";\r\nimport * as $object from \"../utils/Object\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines events for [[DataSource]].\r\n */\r\nexport interface IDataSourceEvents extends IBaseObjectEvents {\r\n\r\n\t/**\r\n\t * Invoked when loading of the data starts.\r\n\t */\r\n\tstarted: {};\r\n\r\n\t/**\r\n\t * Invoked when loading of the data starts.\r\n\t */\r\n\tloadstarted: {};\r\n\r\n\t/**\r\n\t * Invoked when the loading of the data finishes.\r\n\t */\r\n\tloadended: {};\r\n\r\n\t/**\r\n\t * Invoked when parsing of the loaded data starts.\r\n\t */\r\n\tparsestarted: {};\r\n\r\n\t/**\r\n\t * Invoked when parsing of the loaded data finishes.\r\n\t */\r\n\tparseended: {};\r\n\r\n\t/**\r\n\t * Invoked when loading and parsing finishes.\r\n\t */\r\n\tended: {};\r\n\r\n\t/**\r\n\t * Invoked when data source was successfully loaded and parsed.\r\n\t */\r\n\tdone: {\r\n\t\tdata: any\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when data source encounters a loading error.\r\n\t */\r\n\terror: {\r\n\t\tcode: number,\r\n\t\tmessage: string\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when data source encounters a parsing error.\r\n\t */\r\n\tparseerror: {\r\n\t\tmessage: string\r\n\t};\r\n\r\n};\r\n\r\n/**\r\n * Defines adapters for [[DataSource]].\r\n */\r\nexport interface IDataSourceAdapters {\r\n\r\n\t/**\r\n\t * Applied to a data source URL before it is loaded.\r\n\t */\r\n\turl: string;\r\n\r\n\t/**\r\n\t * Applied to a parser type, before parsing starts.\r\n\t *\r\n\t * Can be used to supply different parser than the one set/determined by\r\n\t * Data Loader.\r\n\t */\r\n\tparser: DataParser;\r\n\r\n\t/**\r\n\t * Applied to the timeout setting.\r\n\t */\r\n\treloadTimeout: number;\r\n\r\n\t/**\r\n\t * Applied to the loaded data **before** it is passed to parser.\r\n\t */\r\n\tunparsedData: string;\r\n\r\n\t/**\r\n\t * Applied to the loaded data **after** it was parsed by a parser.\r\n\t */\r\n\tparsedData: any;\r\n\r\n\t/**\r\n\t * Applied to `incremental` setting.\r\n\t */\r\n\tincremental: boolean;\r\n\r\n\t/**\r\n\t * Applied to `incrementalParams` setting.\r\n\t */\r\n\tincrementalParams: { [index: string]: string };\r\n\r\n\t/**\r\n\t * Applied to `updateCurrentData` setting.\r\n\t */\r\n\tupdateCurrentData: boolean;\r\n\r\n\t/**\r\n\t * Applied to `keepCount` setting.\r\n\t */\r\n\tkeepCount: boolean;\r\n\r\n\t/**\r\n\t * Applied to parser options.\r\n\t */\r\n\tparserOptions: any;\r\n\r\n\t/**\r\n\t * Applied to the array that lists fields in data that hold date-based values.\r\n\t */\r\n\tdateFields: string[];\r\n\r\n\t/**\r\n\t * Applied to the array that lists fields in data that hold numeric values.\r\n\t */\r\n\tnumberFields: string[];\r\n\r\n\t/**\r\n\t * Applied to the custom request options object.\r\n\t */\r\n\trequestOptions: INetRequestOptions;\r\n\r\n};\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Represents a single data source - external file with all of its settings,\r\n * such as format, data parsing, etc.\r\n *\r\n * ```TypeScript\r\n * chart.dataSource.url = \"http://www.myweb.com/data.json\";\r\n * chart.dataSource.parser = am4core.JSONParser;\r\n * ```\r\n * ```JavaScript\r\n * chart.dataSource.url = \"http://www.myweb.com/data.json\";\r\n * chart.dataSource.parser = am4core.JSONParser;\r\n * ```\r\n * ```JSON\r\n * {\r\n *   // ...\r\n *   \"dataSource\": {\r\n *     \"url\": \"http://www.myweb.com/data.json\",\r\n *     \"parser\": \"JSONParser\"\r\n *   },\r\n *   // ...\r\n * }\r\n * ```\r\n *\r\n * @see {@link IDataSourceEvents} for a list of available events\r\n * @see {@link IDataSourceAdapters} for a list of available Adapters\r\n */\r\nexport class DataSource extends BaseObjectEvents {\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IDataSourceEvents;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IDataSourceAdapters;\r\n\r\n\t/**\r\n\t * Adapter.\r\n\t */\r\n\tpublic adapter: Adapter<DataSource, IDataSourceAdapters> = new Adapter<DataSource, IDataSourceAdapters>(this);\r\n\r\n\t/**\r\n\t * A [[Component]] recipient of the data.\r\n\t */\r\n\tpublic component: Component;\r\n\r\n\t/**\r\n\t * An instance of [[Language]].\r\n\t */\r\n\tprotected _language: Language;\r\n\r\n\t/**\r\n\t * An instance of [[DateFormatter]].\r\n\t */\r\n\tprotected _dateFormatter: DateFormatter;\r\n\r\n\t/**\r\n\t * An instance of parser class that can understand and parse data from the\r\n\t * source URL.\r\n\t */\r\n\tprotected _parser: DataParser;\r\n\r\n\t/**\r\n\t * An URL of the data source.\r\n\t */\r\n\tprotected _url: string;\r\n\r\n\t/**\r\n\t * Custom options for HTTP(S) request.\r\n\t */\r\n\tprotected _requestOptions: INetRequestOptions = {};\r\n\r\n\t/**\r\n\t * Reload full data source every X ms.\r\n\t */\r\n\tprotected _reloadFrequency: number;\r\n\r\n\t/**\r\n\t * Holds timeout reference for next reload.\r\n\t */\r\n\tprotected _reloadTimeout: any;\r\n\r\n\t/**\r\n\t * Holds disposer for the reload event handler.\r\n\t */\r\n\tprivate _reloadDisposer: IDisposer;\r\n\r\n\t/**\r\n\t * If set to `true`, any subsequent data loads will be considered incremental\r\n\t * (containing only new data points that are supposed to be added to existing\r\n\t * data).\r\n\t *\r\n\t * NOTE: this setting works only with element's `data` property. It won't\r\n\t * work with any other externally-loadable data property.\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tprotected _incremental: boolean = false;\r\n\r\n\t/**\r\n\t * A collection of key/value pairs to attach to a data source URL when making\r\n\t * an incremental request.\r\n\t */\r\n\tprotected _incrementalParams: { [index: string]: string } = {};\r\n\r\n\t/**\r\n\t * This setting is used only when `incremental = true`. If set to `true`,\r\n\t * it will try to retain the same number of data items across each load.\r\n\t *\r\n\t * E.g. if incremental load yeilded 5 new records, then 5 items from the\r\n\t * beginning of data will be removed so that we end up with the same number\r\n\t * of data items.\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tprotected _keepCount: boolean = false;\r\n\r\n\t/**\r\n\t * If set to `true`, each subsequent load will be treated as an update to\r\n\t * currently loaded data, meaning that it will try to update values on\r\n\t * existing data items, not overwrite the whole data.\r\n\t *\r\n\t * This will work faster than complete update, and also will animate the\r\n\t * values to their new positions.\r\n\t *\r\n\t * Data sources across loads must contain the same number of data items.\r\n\t *\r\n\t * Loader will not truncate the data set if loaded data has fewer data items,\r\n\t * and if it is longer, the excess data items will be ignored.\r\n\t *\r\n\t * @default false\r\n\t * @since 4.5.5\r\n\t */\r\n\tprotected _updateCurrentData: boolean = false;\r\n\r\n\t/**\r\n\t * Holds the date of the last load.\r\n\t */\r\n\tpublic lastLoad: Date;\r\n\r\n\t/**\r\n\t * If set to `true` it will timestamp all requested URLs to work around\r\n\t * browser cache.\r\n\t */\r\n\tpublic disableCache: boolean;\r\n\r\n\t/**\r\n\t * Will show loading indicator when loading files.\r\n\t */\r\n\tpublic showPreloader: boolean = true;\r\n\r\n\t/**\r\n\t * Loaded and parsed data.\r\n\t */\r\n\tpublic data: any;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor(url?: string, parser?: string | DataParser) {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"DataSource\";\r\n\r\n\t\t// Set defaults\r\n\t\tif (url) {\r\n\t\t\tthis.url = url;\r\n\t\t}\r\n\r\n\t\t// Set parser\r\n\t\tif (parser) {\r\n\t\t\tif (typeof parser == \"string\") {\r\n\t\t\t\tthis.parser = dataLoader.getParserByType(parser);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.parser = parser;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Processes the loaded data.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param data         Raw (unparsed) data\r\n\t * @param contentType  Content type of the loaded data (optional)\r\n\t */\r\n\tpublic processData(data: string, contentType?: string): void {\r\n\t\t// Parsing started\r\n\t\tthis.dispatchImmediately(\"parsestarted\");\r\n\r\n\t\t// Check if parser is set\r\n\t\tif (!this.parser) {\r\n\r\n\t\t\t// Try to resolve from data\r\n\t\t\tthis.parser = dataLoader.getParserByData(data, contentType);\r\n\r\n\t\t\tif (!this.parser) {\r\n\t\t\t\t// We have a problem - nobody knows what to do with the data\r\n\t\t\t\t// Raise error\r\n\t\t\t\tif (this.events.isEnabled(\"parseerror\")) {\r\n\t\t\t\t\tconst event: AMEvent<this, IDataSourceEvents>[\"parseerror\"] = {\r\n\t\t\t\t\t\ttype: \"parseerror\",\r\n\t\t\t\t\t\tmessage: this.language.translate(\"No parser available for file: %1\", null, this.url),\r\n\t\t\t\t\t\ttarget: this\r\n\t\t\t\t\t};\r\n\t\t\t\t\tthis.events.dispatchImmediately(\"parseerror\", event);\r\n\t\t\t\t}\r\n\t\t\t\tthis.dispatchImmediately(\"parseended\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Apply options adapters\r\n\t\tthis.parser.options = this.adapter.apply(\"parserOptions\", this.parser.options);\r\n\t\tthis.parser.options.dateFields = this.adapter.apply(\"dateFields\", this.parser.options.dateFields || []);\r\n\t\tthis.parser.options.numberFields = this.adapter.apply(\"numberFields\", this.parser.options.numberFields || []);\r\n\r\n\t\t// Check if we need to pass in date formatter\r\n\t\tif (this.parser.options.dateFields && !this.parser.options.dateFormatter) {\r\n\t\t\tthis.parser.options.dateFormatter = this.dateFormatter;\r\n\t\t}\r\n\r\n\t\t// Parse\r\n\t\tthis.data = this.adapter.apply(\r\n\t\t\t\"parsedData\",\r\n\t\t\tthis.parser.parse(\r\n\t\t\t\tthis.adapter.apply(\"unparsedData\", data)\r\n\t\t\t)\r\n\t\t);\r\n\r\n\t\t// Check for parsing errors\r\n\t\tif (!$type.hasValue(this.data) && this.events.isEnabled(\"parseerror\")) {\r\n\t\t\tconst event: AMEvent<this, IDataSourceEvents>[\"parseerror\"] = {\r\n\t\t\t\ttype: \"parseerror\",\r\n\t\t\t\tmessage: this.language.translate(\"Error parsing file: %1\", null, this.url),\r\n\t\t\t\ttarget: this\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"parseerror\", event);\r\n\t\t}\r\n\r\n\t\t// Wrap up\r\n\t\tthis.dispatchImmediately(\"parseended\");\r\n\r\n\t\tif ($type.hasValue(this.data)) {\r\n\t\t\tthis.dispatchImmediately(\"done\", {\r\n\t\t\t\t\"data\": this.data\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// The component is responsible for updating its own data vtriggered via\r\n\t\t// events.\r\n\r\n\t\t// Update last data load\r\n\t\tthis.lastLoad = new Date();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * URL of the data source.\r\n\t *\r\n\t * @param value  URL\r\n\t */\r\n\tpublic set url(value: string) {\r\n\t\tthis._url = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return URL\r\n\t */\r\n\tpublic get url(): string {\r\n\r\n\t\t// Get URL\r\n\t\tlet url = this.disableCache\r\n\t\t\t? this.timestampUrl(this._url)\r\n\t\t\t: this._url;\r\n\r\n\t\t// Add incremental params\r\n\t\tif (this.incremental && this.component.data.length) {\r\n\t\t\turl = this.addUrlParams(url, this.incrementalParams);\r\n\t\t}\r\n\r\n\t\treturn this.adapter.apply(\"url\", url);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Custom options for HTTP(S) request.\r\n\t *\r\n\t * At this moment the only option supported is: `requestHeaders`, which holds\r\n\t * an array of objects for custom request headers, e.g.:\r\n\t *\r\n\t * ```TypeScript\r\n\t * chart.dataSource.requestOptions.requestHeaders = [{\r\n\t *   \"key\": \"x-access-token\",\r\n\t *   \"value\": \"123456789\"\r\n\t * }];\r\n\t * ``````JavaScript\r\n\t * chart.dataSource.requestOptions.requestHeaders = [{\r\n\t *   \"key\": \"x-access-token\",\r\n\t *   \"value\": \"123456789\"\r\n\t * }];\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"dataSource\": {\r\n\t *     // ...\r\n\t *     \"requestOptions\": {\r\n\t *       \"requestHeaders\": [{\r\n\t *         \"key\": \"x-access-token\",\r\n\t *         \"value\": \"123456789\"\r\n\t *       }]\r\n\t *     }\r\n\t *   }\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * NOTE: setting this options on an-already loaded DataSource will not\r\n\t * trigger a reload.\r\n\t *\r\n\t * @param value  Options\r\n\t */\r\n\tpublic set requestOptions(value: INetRequestOptions) {\r\n\t\tthis._requestOptions = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Options\r\n\t */\r\n\tpublic get requestOptions(): INetRequestOptions {\r\n\t\treturn this.adapter.apply(\"requestOptions\", this._requestOptions);\r\n\t}\r\n\r\n\t/**\r\n\t * A parser to be used to parse data.\r\n\t *\r\n\t * ```TypeScript\r\n\t * chart.dataSource.url = \"http://www.myweb.com/data.json\";\r\n\t * chart.dataSource.parser = am4core.JSONParser;\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * chart.dataSource.url = \"http://www.myweb.com/data.json\";\r\n\t * chart.dataSource.parser = am4core.JSONParser;\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"dataSource\": {\r\n\t *     \"url\": \"http://www.myweb.com/data.json\",\r\n\t *     \"parser\": \"JSONParser\"\r\n\t *   },\r\n\t *   // ...\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @default JSONParser\r\n\t * @param value  Data parser\r\n\t */\r\n\tpublic set parser(value: DataParser) {\r\n\t\tthis._parser = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Data parser\r\n\t */\r\n\tpublic get parser(): DataParser {\r\n\t\tif (!this._parser) {\r\n\t\t\tthis._parser = new JSONParser();\r\n\t\t}\r\n\t\treturn this.adapter.apply(\"parser\", this._parser);\r\n\t}\r\n\r\n\t/**\r\n\t * Data source reload frequency.\r\n\t *\r\n\t * If set, it will reload the same URL every X milliseconds.\r\n\t *\r\n\t * @param value Reload frequency (ms)\r\n\t */\r\n\tpublic set reloadFrequency(value: number) {\r\n\t\tif (this._reloadFrequency != value) {\r\n\t\t\tthis._reloadFrequency = value;\r\n\r\n\t\t\t// Should we schedule a reload?\r\n\t\t\tif (value) {\r\n\t\t\t\tif (!$type.hasValue(this._reloadDisposer)) {\r\n\t\t\t\t\tthis._reloadDisposer = this.events.on(\"ended\", (ev) => {\r\n\t\t\t\t\t\tthis._reloadTimeout = setTimeout(() => {\r\n\t\t\t\t\t\t\tthis.load();\r\n\t\t\t\t\t\t}, this.reloadFrequency);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if ($type.hasValue(this._reloadDisposer)) {\r\n\t\t\t\tthis._reloadDisposer.dispose();\r\n\t\t\t\tthis._reloadDisposer = undefined;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Reload frequency (ms)\r\n\t */\r\n\tpublic get reloadFrequency(): number {\r\n\t\treturn this.adapter.apply(\"reloadTimeout\", this._reloadFrequency);\r\n\t}\r\n\r\n\t/**\r\n\t * Should subsequent reloads be treated as incremental?\r\n\t *\r\n\t * Incremental loads will assume that they contain only new data items\r\n\t * since the last load.\r\n\t *\r\n\t * If `incremental = false` the loader will replace all of the target's\r\n\t * data with each load.\r\n\t *\r\n\t * This setting does not have any effect trhe first time data is loaded.\r\n\t *\r\n\t * NOTE: this setting works only with element's `data` property. It won't\r\n\t * work with any other externally-loadable data property.\r\n\t *\r\n\t * @default false\r\n\t * @param Incremental load?\r\n\t */\r\n\tpublic set incremental(value: boolean) {\r\n\t\tthis._incremental = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Incremental load?\r\n\t */\r\n\tpublic get incremental(): boolean {\r\n\t\treturn this.adapter.apply(\"incremental\", this._incremental);\r\n\t}\r\n\r\n\t/**\r\n\t * An object consisting of key/value pairs to apply to an URL when data\r\n\t * source is making an incremental request.\r\n\t *\r\n\t * @param value  Incremental request parameters\r\n\t */\r\n\tpublic set incrementalParams(value: { [index: string]: string }) {\r\n\t\tthis._incrementalParams = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Incremental request parameters\r\n\t */\r\n\tpublic get incrementalParams(): { [index: string]: string } {\r\n\t\treturn this.adapter.apply(\"incrementalParams\", this._incrementalParams);\r\n\t}\r\n\r\n\t/**\r\n\t * This setting is used only when `incremental = true`. If set to `true`,\r\n\t * it will try to retain the same number of data items across each load.\r\n\t *\r\n\t * E.g. if incremental load yeilded 5 new records, then 5 items from the\r\n\t * beginning of data will be removed so that we end up with the same number\r\n\t * of data items.\r\n\t *\r\n\t * @default false\r\n\t * @param Keep record count?\r\n\t */\r\n\tpublic set keepCount(value: boolean) {\r\n\t\tthis._keepCount = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return keepCount load?\r\n\t */\r\n\tpublic get keepCount(): boolean {\r\n\t\treturn this.adapter.apply(\"keepCount\", this._keepCount);\r\n\t}\r\n\r\n\t/**\r\n\t * If set to `true`, each subsequent load will be treated as an update to\r\n\t * currently loaded data, meaning that it will try to update values on\r\n\t * existing data items, not overwrite the whole data.\r\n\t *\r\n\t * This will work faster than complete update, and also will animate the\r\n\t * values to their new positions.\r\n\t *\r\n\t * Data sources across loads must contain the same number of data items.\r\n\t *\r\n\t * Loader will not truncate the data set if loaded data has fewer data items,\r\n\t * and if it is longer, the excess data items will be ignored.\r\n\t *\r\n\t * NOTE: this setting is ignored if `incremental = true`.\r\n\t *\r\n\t * @default false\r\n\t * @since 2.5.5\r\n\t * @param Update current data?\r\n\t */\r\n\tpublic set updateCurrentData(value: boolean) {\r\n\t\tthis._updateCurrentData = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Update current data?\r\n\t */\r\n\tpublic get updateCurrentData(): boolean {\r\n\t\treturn this.adapter.apply(\"updateCurrentData\", this._updateCurrentData);\r\n\t}\r\n\r\n\t/**\r\n\t * Language instance to use.\r\n\t *\r\n\t * Will inherit and use chart's language, if not set.\r\n\t *\r\n\t * @param value An instance of Language\r\n\t */\r\n\tpublic set language(value: Language) {\r\n\t\tthis._language = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return A [[Language]] instance to be used\r\n\t */\r\n\tpublic get language(): Language {\r\n\t\tif (this._language) {\r\n\t\t\treturn this._language;\r\n\t\t}\r\n\t\telse if (this.component) {\r\n\t\t\tthis._language = this.component.language;\r\n\t\t\treturn this._language;\r\n\t\t}\r\n\t\tthis.language = new Language();\r\n\t\treturn this.language;\r\n\t}\r\n\r\n\t/**\r\n\t * A [[DateFormatter]] to use when parsing dates from string formats.\r\n\t *\r\n\t * Will inherit and use chart's DateFormatter if not ser.\r\n\t *\r\n\t * @param value An instance of [[DateFormatter]]\r\n\t */\r\n\tpublic set dateFormatter(value: DateFormatter) {\r\n\t\tthis._dateFormatter = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return A [[DateFormatter]] instance to be used\r\n\t */\r\n\tpublic get dateFormatter(): DateFormatter {\r\n\t\tif (this._dateFormatter) {\r\n\t\t\treturn this._dateFormatter;\r\n\t\t}\r\n\t\telse if (this.component) {\r\n\t\t\tthis._dateFormatter = this.component.dateFormatter;\r\n\t\t\treturn this._dateFormatter;\r\n\t\t}\r\n\t\tthis.dateFormatter = new DateFormatter();\r\n\t\treturn this.dateFormatter;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds current timestamp to the URL.\r\n\t *\r\n\t * @param url  Source URL\r\n\t * @return Timestamped URL\r\n\t */\r\n\tpublic timestampUrl(url: string): string {\r\n\t\tlet tstamp = new Date().getTime().toString();\r\n\t\tlet params: { [index: string]: string } = {};\r\n\t\tparams[tstamp] = \"\";\r\n\t\treturn this.addUrlParams(url, params);\r\n\t}\r\n\r\n\t/**\r\n\t * Disposes of this object.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tsuper.dispose();\r\n\t\tif (this._reloadTimeout) {\r\n\t\t\tclearTimeout(this._reloadTimeout);\r\n\t\t}\r\n\t\tif ($type.hasValue(this._reloadDisposer)) {\r\n\t\t\tthis._reloadDisposer.dispose();\r\n\t\t\tthis._reloadDisposer = undefined;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Initiate the load.\r\n\t *\r\n\t * All loading in JavaScript is asynchronous. This function will trigger the\r\n\t * load and will exit immediately.\r\n\t *\r\n\t * Use DataSource's events to watch for loaded data and errors.\r\n\t */\r\n\tpublic load(): void {\r\n\t\tif (this.url) {\r\n\t\t\tif (this._reloadTimeout) {\r\n\t\t\t\tclearTimeout(this._reloadTimeout);\r\n\t\t\t}\r\n\t\t\tdataLoader.load(this);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds parameters to `url` as query strings. Will take care of proper\r\n\t * separators.\r\n\t *\r\n\t * @param url     Source URL\r\n\t * @param params  Parameters\r\n\t * @return New URL\r\n\t */\r\n\tpublic addUrlParams(url: string, params: { [index: string]: string }): string {\r\n\t\tlet join = url.match(/\\?/) ? \"&\" : \"?\";\r\n\t\tlet add: string[] = [];\r\n\t\t$object.each(params, (key, value) => {\r\n\t\t\tif (value != \"\") {\r\n\t\t\t\tadd.push(key + \"=\" + encodeURIComponent(value));\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tadd.push(key);\r\n\t\t\t}\r\n\t\t});\r\n\t\tif (add.length) {\r\n\t\t\treturn url + join + add.join(\"&\");\r\n\t\t}\r\n\t\treturn url;\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON-based config before it is applied to the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param config  Config\r\n\t */\r\n\tpublic processConfig(config?: { [index: string]: any }): void {\r\n\r\n\t\tregistry.registeredClasses[\"json\"] = JSONParser;\r\n\t\tregistry.registeredClasses[\"JSONParser\"] = JSONParser;\r\n\t\tregistry.registeredClasses[\"csv\"] = CSVParser;\r\n\t\tregistry.registeredClasses[\"CSVParser\"] = CSVParser;\r\n\r\n\t\tsuper.processConfig(config);\r\n\r\n\t}\r\n\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}