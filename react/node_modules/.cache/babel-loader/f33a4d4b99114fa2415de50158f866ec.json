{"ast":null,"code":"/**\r\n * Animation module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObjectEvents } from \"../Base\";\nimport { SVGDefaults } from \"../defs/SVGDefaults\";\nimport { Disposer } from \"../utils/Disposer\";\nimport { Color } from \"../utils/Color\";\nimport { Percent, percent } from \"../utils/Percent\";\nimport * as $async from \"../utils/AsyncPending\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $colors from \"../utils/Colors\";\nimport * as $math from \"../utils/Math\";\nimport * as $array from \"../utils/Array\";\nimport * as $type from \"../utils/Type\";\nimport { system } from \"../System\";\nimport { options } from \"../Options\";\n/**\r\n * Calls a `callback` function for the `duration` of milliseconds.\r\n *\r\n * @todo Needed?\r\n * @deprecated Not used anywhere\r\n * @ignore Exclude from docs\r\n * @param duration  Duration (ms)\r\n * @param callback  Callback function\r\n * @return Disposer\r\n */\n\nexport function animate(duration, callback) {\n  var disposed = false; // TODO use performance.now() ?\n\n  var startTime = Date.now();\n\n  function loop(now) {\n    if (!disposed) {\n      var diff = now - startTime;\n\n      if (diff >= duration) {\n        callback(1);\n      } else {\n        $async.nextFrame(loop);\n        callback(diff / duration);\n      }\n    }\n  }\n\n  $async.nextFrame(loop);\n  return new Disposer(function () {\n    disposed = true;\n  });\n}\n/**\r\n * Returns numeric value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\n\nfunction getProgressNumber(progress, from, to) {\n  return from + (to - from) * progress;\n}\n/**\r\n * Returns [[Percent]] value accoring to progress between start and end\r\n * values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\n\n\nfunction getProgressPercent(progress, from, to) {\n  return new Percent(getProgressNumber(progress, from.percent, to.percent));\n}\n/**\r\n * Returns color value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Color according to progress\r\n */\n\n\nfunction getProgressColor(progress, from, to) {\n  var color = new Color($colors.interpolate(from.rgb, to.rgb, progress));\n\n  if (from.alpha != to.alpha) {\n    color.alpha = from.alpha + (to.alpha - from.alpha) * progress;\n  }\n\n  return color;\n}\n/**\r\n * [getHybridProperty description]\r\n *\r\n * @todo Description\r\n * @param property [description]\r\n * @param type [description]\r\n * @return [description]\r\n */\n\n\nfunction getHybridProperty(property, type) {\n  return type + property.charAt(0).toUpperCase() + property.substr(1);\n}\n\nvar AnimationDisposer =\n/** @class */\nfunction () {\n  function AnimationDisposer(array) {\n    this._disposer = new Disposer(function () {\n      while (array.length !== 0) {\n        array[0].dispose();\n      }\n    });\n  }\n\n  AnimationDisposer.prototype.isDisposed = function () {\n    return this._disposer.isDisposed();\n  };\n\n  AnimationDisposer.prototype.dispose = function () {\n    this._disposer.dispose();\n  };\n\n  return AnimationDisposer;\n}();\n\nexport { AnimationDisposer };\n/**\r\n * Animation can be used to transition certain properties on an object that\r\n * implements [[IAnimatable]] interface.\r\n *\r\n * @see {@link IAnimationEvents} for a list of available events\r\n */\n\nvar Animation =\n/** @class */\nfunction (_super) {\n  __extends(Animation, _super);\n  /**\r\n   * Constructor\r\n   *\r\n   * @param object            An object animation should run on\r\n   * @param animationOptions  One or several (array) of animation options\r\n   * @param duration          Duration (ms)\r\n   * @param easing            Easing function\r\n   */\n\n\n  function Animation(object, animationOptions, duration, easing) {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * Duration of the animation in milliseconds.\r\n     */\n\n\n    _this.duration = 0;\n    /**\r\n     * Easing function to use.\r\n     *\r\n     * @see {@link Ease}\r\n     */\n\n    _this.easing = $ease.linear;\n    /**\r\n     * Contains progress of the current animation: 0 (start) to 1 (end).\r\n     */\n\n    _this.progress = 0;\n    /**\r\n     * Indicated how many times animation should loop.\r\n     */\n\n    _this._loop = 0;\n    /**\r\n     * Animation is paused.\r\n     */\n\n    _this._pause = false;\n    /**\r\n     * Holds reference to timeout for delayed play.\r\n     */\n\n    _this._delayTimeout = null;\n    /**\r\n     * Elapsed time in currently playing animation.\r\n     */\n\n    _this._time = 0;\n    _this._isFinished = false;\n    _this.className = \"Animation\"; // Override duration if animations disabled system-wide\n\n    if (options.animationsEnabled === false) {\n      duration = 0;\n    } // Set parameters\n\n\n    _this.object = object;\n    _this.animationOptions = $array.toArray(animationOptions);\n    _this.duration = duration;\n\n    if (easing) {\n      _this.easing = easing;\n    } // Run check if there are already animations playing on the same properties\n    // and stop them - the last animation takes precedence\n    //this.stopSameAnimations();\n\n    /*if ($type.hasValue(callback)) {\r\n        // TODO don't use .call\r\n        this.events.on(\"animationended\", callback, object);\r\n    }*/\n    // Apply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  } // TODO verify that this is correct\n\n\n  Animation.prototype.debug = function () {};\n  /**\r\n   * Disposes this object, clears up after itself.\r\n   */\n\n\n  Animation.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.pause();\n  };\n  /**\r\n   * Delays animation start by X milliseconds.\r\n   *\r\n   * @param delay  Delay (ms)\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.delay = function (delay) {\n    var _this = this; //@todo Maybe not use `bind()`\n\n\n    if (delay > 0) {\n      this.pause(); // This is so that it will get disposed if `this.object` is disposed\n      // TODO hacky, figure out a better way\n\n      $array.move(this.object.animations, this);\n      var id_1 = setTimeout(function () {\n        _this._delayTimeout = null;\n\n        _this.start();\n      }, delay);\n      this._delayTimeout = new Disposer(function () {\n        clearTimeout(id_1);\n      });\n    }\n\n    return this;\n  };\n\n  Animation.prototype._start = function () {\n    this._isFinished = false; // Clear delay timeout if there was one\n\n    if (this._delayTimeout) {\n      this.removeDispose(this._delayTimeout);\n      this._delayTimeout = null;\n    } // Run check if there are already animations playing on the same properties\n    // and stop them - the last animation takes precedence\n\n\n    this.stopSameAnimations(); // Reset counters\n\n    this._pause = false; // Register animation\n\n    $array.move(system.animations, this); // Register this animation in object's `animations` list\n\n    $array.move(this.object.animations, this);\n    system.requestFrame();\n  };\n  /**\r\n   * Starts animation.\r\n   *\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.start = function () {\n    this._start();\n\n    this._startTime = Date.now();\n    this._time = 0;\n    this.staticOptions = []; // Process initial property values\n\n    for (var i = this.animationOptions.length - 1; i >= 0; i--) {\n      var options_1 = this.animationOptions[i];\n\n      if (!$type.hasValue(options_1.from)) {\n        if (options_1.childObject) {\n          options_1.from = options_1.childObject[options_1.property];\n        } else {\n          options_1.from = this.object[options_1.property];\n\n          if (!$type.hasValue(options_1.from)) {\n            options_1.from = SVGDefaults[options_1.property];\n          }\n        }\n        /*if (!$type.hasValue(options.from)) {\r\n            throw Error(\"Could not get initial transition value.\");\r\n        }*/\n\n      }\n\n      if (options_1.from == options_1.to) {\n        // || options.to == (<any>this.object)[options.property]){ this is not good, as dataItem.value is set to final at once, and we animate workingValue\n        $array.remove(this.animationOptions, options_1);\n      } else if (!$type.hasValue(options_1.from) || !(options_1.from instanceof Percent) && options_1.to instanceof Percent || options_1.from instanceof Percent && !(options_1.to instanceof Percent)) {\n        // Initial value is undefined, treat it as static\n        this.staticOptions.push(options_1);\n        $array.remove(this.animationOptions, options_1);\n      } else {\n        // Use different update methods for different value types\n        if ($type.isNumber(options_1.to)) {\n          // Numeric value\n          options_1.updateMethod = getProgressNumber; // Check if initial value is not Percent\n\n          if (options_1.from instanceof Percent) {\n            // It is. Let's convert it to pixel value\n            // @todo Check if we can do this in a less hacky way\n            var convertedFrom = this.object[getHybridProperty(options_1.property, \"pixel\")];\n\n            if (!isNaN(convertedFrom)) {\n              options_1.from = convertedFrom;\n            } else {\n              this.staticOptions.push(options_1);\n              $array.remove(this.animationOptions, options_1);\n            }\n          } else if (isNaN(options_1.from)) {\n            // Static value\n            this.staticOptions.push(options_1);\n            $array.remove(this.animationOptions, options_1);\n          }\n        } else {\n          // Check if maybe we have a color or percent value\n          if (options_1.to instanceof Color) {\n            // Yup - set resolved named color\n            //options.from = $colors.stringToColor(<string>options.from);\n            if (options_1.from) {\n              options_1.updateMethod = getProgressColor;\n            } else {\n              // Static value\n              this.staticOptions.push(options_1);\n              $array.remove(this.animationOptions, options_1);\n            }\n          } else if (options_1.to instanceof Percent) {\n            // Percent\n            options_1.updateMethod = getProgressPercent; // Check if the initial value is maybe in pixels\n\n            if (!isNaN(options_1.from)) {\n              // It is. Let's convert it\n              // @todo Check if we can do this in a less hacky way\n              var convertedFrom = this.object[getHybridProperty(options_1.property, \"relative\")];\n\n              if (!isNaN(convertedFrom)) {\n                options_1.from = percent(convertedFrom * 100);\n              }\n            }\n          } else {\n            // Static value\n            this.staticOptions.push(options_1);\n            $array.remove(this.animationOptions, options_1);\n          }\n        }\n      }\n    } // Apply static options (just in case they were reset by previous\n    // animation loop)\n\n\n    this.applyStaticOptions();\n\n    if (this.events.isEnabled(\"animationstarted\")) {\n      var event_1 = {\n        type: \"animationstarted\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationstarted\", event_1);\n    }\n\n    this.update(); // If duration is 0, just end animation\n\n    if (this.duration === 0) {\n      this.end();\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets loop count for the animation. If parameter is not a valid number the\r\n   * animation will keep on looping indefinitely.\r\n   *\r\n   * @param count  Number of times to loop animation\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.loop = function (count) {\n    if (!$type.isNumber(count)) {\n      count = Infinity;\n    }\n\n    this._loop = count;\n    return this;\n  };\n  /**\r\n   * Pauses animation.\r\n   *\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.pause = function () {\n    this._pause = true;\n\n    if (this._delayTimeout) {\n      this.removeDispose(this._delayTimeout);\n      this._delayTimeout = null;\n    }\n\n    $array.remove(system.animations, this);\n    $array.remove(this.object.animations, this);\n    return this;\n  };\n  /**\r\n   * Resumes paused animation.\r\n   *\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.resume = function () {\n    this._start();\n\n    this._startTime = Date.now() - this._time;\n    return this;\n  };\n  /**\r\n   * Jumps to animation end. If animation is set to loop, this will start\r\n   * another round of animation from start.\r\n   *\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.end = function () {\n    // Pause and complete the progress\n    if (this._loop == 0) {\n      this.pause();\n    }\n\n    this.setProgress(1); // Apply static options\n\n    this.applyStaticOptions();\n\n    if (this.events.isEnabled(\"animationended\")) {\n      var event_2 = {\n        type: \"animationended\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationended\", event_2);\n    } // Check if we should loop\n\n\n    if (this._loop > 0) {\n      this._loop--;\n      this.start();\n    } else {\n      this.stop();\n      this._isFinished = true;\n    }\n\n    return this;\n  };\n  /**\r\n   * Stops animation immediately leaving properties in their current values.\r\n   */\n\n\n  Animation.prototype.kill = function () {\n    this.pause();\n    this._isFinished = true;\n  };\n  /**\r\n   * Returns indicator if this animation is finished or not\r\n   *\r\n   * @return Is finished?\r\n   */\n\n\n  Animation.prototype.isFinished = function () {\n    return this._isFinished;\n  };\n  /**\r\n   * Applies static options that can't be animated.\r\n   */\n\n\n  Animation.prototype.applyStaticOptions = function () {\n    var _this = this;\n\n    $array.each(this.staticOptions, function (options) {\n      if (options.childObject) {\n        options.childObject[options.property] = _this.progress == 1 ? options.to : options.from;\n      } else {\n        _this.object[options.property] = _this.progress == 1 ? options.to : options.from;\n      }\n    });\n  };\n  /**\r\n   * Stops animation.\r\n   *\r\n   * When animation is stopped, the properties of the target object will remain\r\n   * where they were at the moment when `stop()` was called.\r\n   *\r\n   * @param skipEvent  Do not trigger `animationstopped` event\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.stop = function (skipEvent) {\n    this.pause();\n\n    if (!skipEvent) {\n      if (this.events.isEnabled(\"animationstopped\")) {\n        var event_3 = {\n          type: \"animationstopped\",\n          target: this,\n          progress: this.progress\n        };\n        this.events.dispatchImmediately(\"animationstopped\", event_3);\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets current progress and updates object's numeric and color values.\r\n   *\r\n   * @param progress Progress (0-1)\r\n   */\n\n\n  Animation.prototype.setProgress = function (progress) {\n    var _this = this;\n\n    this._time = this.duration * progress; // just in case we call this from outside\n\n    $array.each(this.animationOptions, function (options) {\n      if (options.updateMethod && $type.hasValue(options.from)) {\n        var value = options.updateMethod(progress, options.from, options.to);\n\n        if (options.childObject) {\n          options.childObject[options.property] = value;\n        } else {\n          _this.object[options.property] = value;\n        }\n      }\n    });\n    this.progress = progress;\n\n    if (this.events.isEnabled(\"animationprogress\")) {\n      var event_4 = {\n        type: \"animationprogress\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationprogress\", event_4);\n    }\n\n    system.requestFrame();\n  };\n  /**\r\n   * Tracks and sets progress according to time or frames.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.update = function () {\n    if (!this._pause) {\n      var progress = void 0;\n      this._time = $math.fitToRange(Date.now() - this._startTime, 0, this.duration);\n      var timeProgress = this._time / this.duration;\n      progress = this.easing(timeProgress);\n\n      if (this.duration == 0 || !$type.isNumber(progress) || timeProgress >= 1) {\n        progress = 1;\n      }\n\n      this.setProgress(progress);\n\n      if ($math.round(this._time / this.duration, 6) == 1) {\n        this.end();\n      }\n    }\n\n    return this;\n  };\n\n  Object.defineProperty(Animation.prototype, \"delayed\", {\n    /**\r\n     * Returns `true` if this animation is delayed.\r\n     *\r\n     * @readonly\r\n     * @return [description]\r\n     */\n    get: function get() {\n      return this._delayTimeout ? true : false;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Checks other animations currently running on the same object and removes\r\n   * overlapping options from those other animations that are contained in\r\n   * this animation.\r\n   *\r\n   * This is needed to ensure that no two confurent animations step on each\r\n   * other's toes by trying to animate the same property.\r\n   */\n\n  Animation.prototype.stopSameAnimations = function () {\n    var _this = this; // stop animation of the same property\n    // TODO make this more efficient\n    // TODO don't copy the array\n\n\n    $array.each($array.copy(this.object.animations), function (animation) {\n      if (animation !== _this && !animation.delayed) {\n        var killed_1 = [];\n        $array.each(_this.animationOptions, function (newOptions) {\n          $array.each(animation.animationOptions, function (oldOptions) {\n            if (newOptions.property == oldOptions.property && newOptions.childObject == oldOptions.childObject) {\n              killed_1.push(oldOptions);\n\n              if (animation.animationOptions.length == 0) {\n                animation.kill();\n              }\n            }\n          });\n        });\n        $array.each(killed_1, function (oldOptions) {\n          $array.remove(animation.animationOptions, oldOptions);\n        });\n      }\n    });\n  };\n  /**\r\n   * Adds easing functions to \"function\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as function?\r\n   */\n\n\n  Animation.prototype.asFunction = function (field) {\n    return field == \"easing\" || _super.prototype.asIs.call(this, field);\n  };\n\n  return Animation;\n}(BaseObjectEvents);\n\nexport { Animation };","map":{"version":3,"sources":["../../../../../src/.internal/core/utils/Animation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Animation module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObjectEvents, IBaseObjectEvents } from \"../Base\";\r\nimport { AMEvent } from \"../utils/EventDispatcher\";\r\nimport { SVGDefaults } from \"../defs/SVGDefaults\";\r\nimport { Disposer, IDisposer } from \"../utils/Disposer\";\r\nimport { Color } from \"../utils/Color\";\r\nimport { Percent, percent } from \"../utils/Percent\";\r\nimport * as $async from \"../utils/AsyncPending\";\r\nimport * as $ease from \"../utils/Ease\";\r\nimport * as $colors from \"../utils/Colors\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $array from \"../utils/Array\";\r\nimport * as $type from \"../utils/Type\";\r\nimport { system } from \"../System\";\r\nimport { options } from \"../Options\";\r\n\r\n\r\n/**\r\n * Defines interface for animation objects.\r\n *\r\n * Should at least contain `update()` method.\r\n */\r\nexport interface IAnimationObject {\r\n\tupdate: () => void\r\n}\r\n\r\n/**\r\n * Defines interface for objects that can be animated\r\n */\r\nexport interface IAnimatable {\r\n\tanimations: Array<Animation>;\r\n}\r\n\r\n\r\nexport type IAnimationOption = Color | Percent | number | string | boolean;\r\n\r\n/**\r\n * Defines interface for animation options.\r\n */\r\nexport interface IAnimationOptions {\r\n\r\n\t/**\r\n\t * An initial value to animate from.\r\n\t *\r\n\t * If omitted, the source value will be current value.\r\n\t */\r\n\tfrom?: IAnimationOption;\r\n\r\n\t/**\r\n\t * A target value to animate from.\r\n\t */\r\n\tto: IAnimationOption;\r\n\r\n\t/**\r\n\t * Property name to animate.\r\n\t */\r\n\tproperty?: any;\r\n\r\n\t/**\r\n\t * If current values should be taken from different object than the target\r\n\t * element of the animation, this property should be set to that object.\r\n\t */\r\n\tchildObject?: { [index: string]: any };\r\n\r\n\t/**\r\n\t * A method/function reference that will be called to for updating the\r\n\t * property value.\r\n\t */\r\n\tupdateMethod?(progress: number, from: IAnimationOption, to: IAnimationOption): IAnimationOption;\r\n\r\n\r\n\t/**\r\n\t * sometimes we need to pass some dummy data in animationOptions\r\n\t */\r\n\tdummyData?: any;\r\n\r\n}\r\n\r\n/**\r\n * An interface for an object defining [[Percent]] animation.\r\n */\r\nexport interface IPercentAnimationOptions extends IAnimationOptions {\r\n\r\n\t/**\r\n\t * Initial value.\r\n\t */\r\n\tfrom?: Percent;\r\n\r\n\t/**\r\n\t * Target value.\r\n\t */\r\n\tto: Percent;\r\n\r\n}\r\n\r\n/**\r\n * An interface for an object defining [[Color]] animation.\r\n */\r\nexport interface IColorAnimationOptions extends IAnimationOptions {\r\n\r\n\t/**\r\n\t * Initial value.\r\n\t */\r\n\tfrom?: Color;\r\n\r\n\t/**\r\n\t * Target value.\r\n\t */\r\n\tto: Color;\r\n\r\n}\r\n\r\n\r\n/**\r\n * Calls a `callback` function for the `duration` of milliseconds.\r\n *\r\n * @todo Needed?\r\n * @deprecated Not used anywhere\r\n * @ignore Exclude from docs\r\n * @param duration  Duration (ms)\r\n * @param callback  Callback function\r\n * @return Disposer\r\n */\r\nexport function animate(duration: number, callback: (time: number) => void): IDisposer {\r\n\tlet disposed = false;\r\n\r\n\t// TODO use performance.now() ?\r\n\tconst startTime = Date.now();\r\n\r\n\tfunction loop(now: number): void {\r\n\t\tif (!disposed) {\r\n\t\t\tconst diff = now - startTime;\r\n\r\n\t\t\tif (diff >= duration) {\r\n\t\t\t\tcallback(1);\r\n\r\n\t\t\t} else {\r\n\t\t\t\t$async.nextFrame(loop);\r\n\t\t\t\tcallback(diff / duration);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t$async.nextFrame(loop);\r\n\r\n\treturn new Disposer(() => {\r\n\t\tdisposed = true;\r\n\t});\r\n}\r\n\r\n\r\n/**\r\n * Defines events for [[Animation]].\r\n */\r\nexport interface IAnimationEvents extends IBaseObjectEvents {\r\n\r\n\t/**\r\n\t * Invoked when animation starts playing.\r\n\t */\r\n\tanimationstarted: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation finishes playing.\r\n\t */\r\n\tanimationended: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation makes progress.\r\n\t */\r\n\tanimationprogress: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation is stopped by some other process, before it had\r\n\t * a chance to finish.\r\n\t */\r\n\tanimationstopped: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n}\r\n\r\n\r\n/**\r\n * Returns numeric value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\r\nfunction getProgressNumber(progress: number, from: number, to: number): number {\r\n\treturn from + ((to - from) * progress);\r\n}\r\n\r\n/**\r\n * Returns [[Percent]] value accoring to progress between start and end\r\n * values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\r\nfunction getProgressPercent(progress: number, from: Percent, to: Percent): Percent {\r\n\treturn new Percent(getProgressNumber(progress, from.percent, to.percent));\r\n}\r\n\r\n/**\r\n * Returns color value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Color according to progress\r\n */\r\nfunction getProgressColor(progress: number, from: Color, to: Color): Color {\r\n\tconst color = new Color($colors.interpolate(from.rgb, to.rgb, progress));\r\n\tif (from.alpha != to.alpha) {\r\n\t\tcolor.alpha = from.alpha + (to.alpha - from.alpha) * progress;\r\n\t}\r\n\treturn color;\r\n}\r\n\r\n/**\r\n * [getHybridProperty description]\r\n *\r\n * @todo Description\r\n * @param property [description]\r\n * @param type [description]\r\n * @return [description]\r\n */\r\nfunction getHybridProperty(property: string, type: \"pixel\" | \"relative\"): string {\r\n\treturn type + property.charAt(0).toUpperCase() + property.substr(1);\r\n}\r\n\r\n\r\nexport class AnimationDisposer implements IDisposer {\r\n\tprivate _disposer: Disposer;\r\n\r\n\tconstructor(array: Array<Animation>) {\r\n\t\tthis._disposer = new Disposer(() => {\r\n\t\t\twhile (array.length !== 0) {\r\n\t\t\t\tarray[0].dispose();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tisDisposed(): boolean {\r\n\t\treturn this._disposer.isDisposed();\r\n\t}\r\n\r\n\tdispose(): void {\r\n\t\tthis._disposer.dispose();\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Animation can be used to transition certain properties on an object that\r\n * implements [[IAnimatable]] interface.\r\n *\r\n * @see {@link IAnimationEvents} for a list of available events\r\n */\r\nexport class Animation extends BaseObjectEvents implements IAnimationObject {\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IAnimationEvents;\r\n\r\n\t/**\r\n\t * An animation target object. [[Animation]] will update properties of\r\n\t * this object.\r\n\t */\r\n\tpublic object: IAnimatable;\r\n\r\n\t/**\r\n\t * An array of animation option objects. Each animation object represent\r\n\t * one property. Animation can animate any number of properties\r\n\t * simultaneously.\r\n\t */\r\n\tpublic animationOptions: IAnimationOptions[];\r\n\r\n\t/**\r\n\t * Duration of the animation in milliseconds.\r\n\t */\r\n\tpublic duration: number = 0;\r\n\r\n\t/**\r\n\t * Easing function to use.\r\n\t *\r\n\t * @see {@link Ease}\r\n\t */\r\n\tpublic easing: (value: number) => number = $ease.linear;\r\n\r\n\t/**\r\n\t * Contains progress of the current animation: 0 (start) to 1 (end).\r\n\t */\r\n\tpublic progress: number = 0;\r\n\r\n\t/**\r\n\t * A list of options that cannot be animated. Those will be applied when\r\n\t * Animation ends.\r\n\t */\r\n\tprotected staticOptions!: IAnimationOptions[];\r\n\r\n\t/**\r\n\t * Indicated how many times animation should loop.\r\n\t */\r\n\tprotected _loop: number = 0;\r\n\r\n\t/**\r\n\t * Animation is paused.\r\n\t */\r\n\tprotected _pause: boolean = false;\r\n\r\n\t/**\r\n\t * Holds reference to timeout for delayed play.\r\n\t */\r\n\tprotected _delayTimeout: IDisposer | null = null;\r\n\r\n\t/**\r\n\t * A timestamp of when animation started playing.\r\n\t */\r\n\tprotected _startTime: $type.Optional<number>;\r\n\r\n\t/**\r\n\t * Elapsed time in currently playing animation.\r\n\t */\r\n\tprotected _time: number = 0;\r\n\r\n\t// TODO verify that this is correct\r\n\tprotected debug(): void { }\r\n\r\n\tprotected _isFinished: boolean = false;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t *\r\n\t * @param object            An object animation should run on\r\n\t * @param animationOptions  One or several (array) of animation options\r\n\t * @param duration          Duration (ms)\r\n\t * @param easing            Easing function\r\n\t */\r\n\tconstructor(object: IAnimatable, animationOptions: IAnimationOptions[] | IAnimationOptions, duration: number, easing?: (value: number) => number) {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"Animation\";\r\n\r\n\t\t// Override duration if animations disabled system-wide\r\n\t\tif (options.animationsEnabled === false) {\r\n\t\t\tduration = 0;\r\n\t\t}\r\n\r\n\t\t// Set parameters\r\n\t\tthis.object = object;\r\n\t\tthis.animationOptions = $array.toArray(animationOptions);\r\n\t\tthis.duration = duration;\r\n\t\tif (easing) {\r\n\t\t\tthis.easing = easing;\r\n\t\t}\r\n\r\n\t\t// Run check if there are already animations playing on the same properties\r\n\t\t// and stop them - the last animation takes precedence\r\n\t\t//this.stopSameAnimations();\r\n\r\n\t\t/*if ($type.hasValue(callback)) {\r\n\t\t\t// TODO don't use .call\r\n\t\t\tthis.events.on(\"animationended\", callback, object);\r\n\t\t}*/\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Disposes this object, clears up after itself.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tsuper.dispose();\r\n\t\tthis.pause();\r\n\t}\r\n\r\n\t/**\r\n\t * Delays animation start by X milliseconds.\r\n\t *\r\n\t * @param delay  Delay (ms)\r\n\t * @return Animation\r\n\t */\r\n\tpublic delay(delay: number): Animation {\r\n\t\t//@todo Maybe not use `bind()`\r\n\t\tif (delay > 0) {\r\n\t\t\tthis.pause();\r\n\r\n\t\t\t// This is so that it will get disposed if `this.object` is disposed\r\n\t\t\t// TODO hacky, figure out a better way\r\n\t\t\t$array.move(this.object.animations, this);\r\n\r\n\t\t\tlet id = setTimeout(() => {\r\n\t\t\t\tthis._delayTimeout = null;\r\n\t\t\t\tthis.start();\r\n\t\t\t}, delay);\r\n\r\n\t\t\tthis._delayTimeout = new Disposer(() => {\r\n\t\t\t\tclearTimeout(id);\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\tprivate _start() {\r\n\t\tthis._isFinished = false;\r\n\t\t// Clear delay timeout if there was one\r\n\t\tif (this._delayTimeout) {\r\n\t\t\tthis.removeDispose(this._delayTimeout);\r\n\t\t\tthis._delayTimeout = null;\r\n\t\t}\r\n\r\n\t\t// Run check if there are already animations playing on the same properties\r\n\t\t// and stop them - the last animation takes precedence\r\n\t\tthis.stopSameAnimations();\r\n\r\n\t\t// Reset counters\r\n\t\tthis._pause = false;\r\n\r\n\t\t// Register animation\r\n\t\t$array.move(system.animations, this);\r\n\r\n\t\t// Register this animation in object's `animations` list\r\n\t\t$array.move(this.object.animations, this);\r\n\r\n\t\tsystem.requestFrame();\r\n\t}\r\n\r\n\t/**\r\n\t * Starts animation.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic start(): Animation {\r\n\t\tthis._start();\r\n\t\tthis._startTime = Date.now();\r\n\t\tthis._time = 0;\r\n\t\tthis.staticOptions = [];\r\n\r\n\t\t// Process initial property values\r\n\t\tfor (let i: number = this.animationOptions.length - 1; i >= 0; i--) {\r\n\t\t\tlet options: IAnimationOptions = this.animationOptions[i];\r\n\t\t\tif (!$type.hasValue(options.from)) {\r\n\t\t\t\tif (options.childObject) {\r\n\t\t\t\t\toptions.from = options.childObject[options.property];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\toptions.from = (<any>this.object)[options.property];\r\n\r\n\t\t\t\t\tif (!$type.hasValue(options.from)) {\r\n\t\t\t\t\t\toptions.from = (<any>SVGDefaults)[options.property];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*if (!$type.hasValue(options.from)) {\r\n\t\t\t\t\tthrow Error(\"Could not get initial transition value.\");\r\n\t\t\t\t}*/\r\n\t\t\t}\r\n\r\n\t\t\tif (options.from == options.to) { // || options.to == (<any>this.object)[options.property]){ this is not good, as dataItem.value is set to final at once, and we animate workingValue\r\n\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t}\r\n\t\t\telse if (!$type.hasValue(options.from) || (!(options.from instanceof Percent) && (options.to instanceof Percent)) || ((options.from instanceof Percent) && !(options.to instanceof Percent))) {\r\n\t\t\t\t// Initial value is undefined, treat it as static\r\n\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Use different update methods for different value types\r\n\t\t\t\tif ($type.isNumber(<number>options.to)) {\r\n\r\n\t\t\t\t\t// Numeric value\r\n\t\t\t\t\toptions.updateMethod = getProgressNumber;\r\n\r\n\t\t\t\t\t// Check if initial value is not Percent\r\n\t\t\t\t\tif (options.from instanceof Percent) {\r\n\t\t\t\t\t\t// It is. Let's convert it to pixel value\r\n\t\t\t\t\t\t// @todo Check if we can do this in a less hacky way\r\n\t\t\t\t\t\tlet convertedFrom: number = (<any>this.object)[getHybridProperty(options.property, \"pixel\")];\r\n\t\t\t\t\t\tif (!isNaN(convertedFrom)) {\r\n\t\t\t\t\t\t\toptions.from = convertedFrom;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (isNaN(<number>options.from)) {\r\n\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Check if maybe we have a color or percent value\r\n\t\t\t\t\tif (options.to instanceof Color) {\r\n\t\t\t\t\t\t// Yup - set resolved named color\r\n\t\t\t\t\t\t//options.from = $colors.stringToColor(<string>options.from);\r\n\t\t\t\t\t\tif (options.from) {\r\n\t\t\t\t\t\t\toptions.updateMethod = getProgressColor;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (options.to instanceof Percent) {\r\n\t\t\t\t\t\t// Percent\r\n\t\t\t\t\t\toptions.updateMethod = getProgressPercent;\r\n\r\n\t\t\t\t\t\t// Check if the initial value is maybe in pixels\r\n\t\t\t\t\t\tif (!isNaN(<number>options.from)) {\r\n\t\t\t\t\t\t\t// It is. Let's convert it\r\n\t\t\t\t\t\t\t// @todo Check if we can do this in a less hacky way\r\n\t\t\t\t\t\t\tlet convertedFrom: number = (<any>this.object)[getHybridProperty(options.property, \"relative\")];\r\n\t\t\t\t\t\t\tif (!isNaN(convertedFrom)) {\r\n\t\t\t\t\t\t\t\toptions.from = percent(convertedFrom * 100);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Apply static options (just in case they were reset by previous\r\n\t\t// animation loop)\r\n\t\tthis.applyStaticOptions();\r\n\r\n\t\tif (this.events.isEnabled(\"animationstarted\")) {\r\n\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationstarted\"] = {\r\n\t\t\t\ttype: \"animationstarted\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"animationstarted\", event);\r\n\t\t}\r\n\r\n\t\tthis.update();\r\n\r\n\t\t// If duration is 0, just end animation\r\n\t\tif (this.duration === 0) {\r\n\t\t\tthis.end();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets loop count for the animation. If parameter is not a valid number the\r\n\t * animation will keep on looping indefinitely.\r\n\t *\r\n\t * @param count  Number of times to loop animation\r\n\t * @return Animation\r\n\t */\r\n\tpublic loop(count?: number): Animation {\r\n\t\tif (!$type.isNumber(count)) {\r\n\t\t\tcount = Infinity;\r\n\t\t}\r\n\t\tthis._loop = count;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Pauses animation.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic pause(): Animation {\r\n\t\tthis._pause = true;\r\n\r\n\t\tif (this._delayTimeout) {\r\n\t\t\tthis.removeDispose(this._delayTimeout);\r\n\t\t\tthis._delayTimeout = null;\r\n\t\t}\r\n\r\n\t\t$array.remove(system.animations, this);\r\n\t\t$array.remove(this.object.animations, this);\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Resumes paused animation.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic resume(): Animation {\r\n\t\tthis._start();\r\n\t\tthis._startTime = Date.now() - this._time;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Jumps to animation end. If animation is set to loop, this will start\r\n\t * another round of animation from start.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic end(): Animation {\r\n\r\n\t\t// Pause and complete the progress\r\n\t\tif (this._loop == 0) {\r\n\t\t\tthis.pause();\r\n\t\t}\r\n\t\tthis.setProgress(1);\r\n\r\n\t\t// Apply static options\r\n\t\tthis.applyStaticOptions();\r\n\r\n\t\tif (this.events.isEnabled(\"animationended\")) {\r\n\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationended\"] = {\r\n\t\t\t\ttype: \"animationended\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"animationended\", event);\r\n\t\t}\r\n\r\n\t\t// Check if we should loop\r\n\t\tif (this._loop > 0) {\r\n\t\t\tthis._loop--;\r\n\t\t\tthis.start();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.stop();\r\n\t\t\tthis._isFinished = true;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Stops animation immediately leaving properties in their current values.\r\n\t */\r\n\tpublic kill() {\r\n\t\tthis.pause();\r\n\t\tthis._isFinished = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns indicator if this animation is finished or not\r\n\t *\r\n\t * @return Is finished?\r\n\t */\r\n\tpublic isFinished(): boolean {\r\n\t\treturn this._isFinished;\r\n\t}\r\n\r\n\t/**\r\n\t * Applies static options that can't be animated.\r\n\t */\r\n\tprotected applyStaticOptions(): void {\r\n\t\t$array.each(this.staticOptions, (options) => {\r\n\t\t\tif (options.childObject) {\r\n\t\t\t\toptions.childObject[options.property] = this.progress == 1 ? options.to : options.from;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t(<any>this.object)[options.property] = this.progress == 1 ? options.to : options.from;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Stops animation.\r\n\t *\r\n\t * When animation is stopped, the properties of the target object will remain\r\n\t * where they were at the moment when `stop()` was called.\r\n\t *\r\n\t * @param skipEvent  Do not trigger `animationstopped` event\r\n\t * @return Animation\r\n\t */\r\n\tpublic stop(skipEvent?: boolean): Animation {\r\n\t\tthis.pause();\r\n\t\tif (!skipEvent) {\r\n\t\t\tif (this.events.isEnabled(\"animationstopped\")) {\r\n\t\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationstopped\"] = {\r\n\t\t\t\t\ttype: \"animationstopped\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tprogress: this.progress\r\n\t\t\t\t};\r\n\t\t\t\tthis.events.dispatchImmediately(\"animationstopped\", event);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets current progress and updates object's numeric and color values.\r\n\t *\r\n\t * @param progress Progress (0-1)\r\n\t */\r\n\tpublic setProgress(progress: number): void {\r\n\t\tthis._time = this.duration * progress; // just in case we call this from outside\r\n\t\t$array.each(this.animationOptions, (options) => {\r\n\t\t\tif (options.updateMethod && $type.hasValue(options.from)) {\r\n\t\t\t\tlet value = options.updateMethod(progress, options.from, options.to);\r\n\r\n\t\t\t\tif (options.childObject) {\r\n\t\t\t\t\toptions.childObject[options.property] = value;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t(<any>this.object)[options.property] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.progress = progress;\r\n\t\tif (this.events.isEnabled(\"animationprogress\")) {\r\n\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationprogress\"] = {\r\n\t\t\t\ttype: \"animationprogress\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"animationprogress\", event);\r\n\t\t}\r\n\r\n\t\tsystem.requestFrame();\r\n\t}\r\n\r\n\t/**\r\n\t * Tracks and sets progress according to time or frames.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Animation\r\n\t */\r\n\tpublic update(): Animation {\r\n\t\tif (!this._pause) {\r\n\r\n\t\t\tlet progress;\r\n\t\t\tthis._time = $math.fitToRange(Date.now() - this._startTime!, 0, this.duration);\r\n\t\t\tlet timeProgress = this._time / this.duration;\r\n\t\t\tprogress = this.easing(timeProgress);\r\n\t\t\tif (this.duration == 0 || !$type.isNumber(progress) || timeProgress >= 1) {\r\n\t\t\t\tprogress = 1;\r\n\t\t\t}\r\n\r\n\t\t\tthis.setProgress(progress);\r\n\r\n\t\t\tif ($math.round(this._time / this.duration, 6) == 1) {\r\n\t\t\t\tthis.end();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if this animation is delayed.\r\n\t *\r\n\t * @readonly\r\n\t * @return [description]\r\n\t */\r\n\tpublic get delayed(): boolean {\r\n\t\treturn this._delayTimeout ? true : false;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks other animations currently running on the same object and removes\r\n\t * overlapping options from those other animations that are contained in\r\n\t * this animation.\r\n\t *\r\n\t * This is needed to ensure that no two confurent animations step on each\r\n\t * other's toes by trying to animate the same property.\r\n\t */\r\n\tprivate stopSameAnimations(): void {\r\n\t\t// stop animation of the same property\r\n\t\t// TODO make this more efficient\r\n\t\t// TODO don't copy the array\r\n\t\t$array.each($array.copy(this.object.animations), (animation) => {\r\n\t\t\tif (animation !== this && !animation.delayed) {\r\n\t\t\t\tconst killed: Array<IAnimationOptions> = [];\r\n\r\n\t\t\t\t$array.each(this.animationOptions, (newOptions) => {\r\n\t\t\t\t\t$array.each(animation.animationOptions, (oldOptions) => {\r\n\t\t\t\t\t\tif (newOptions.property == oldOptions.property && newOptions.childObject == oldOptions.childObject) {\r\n\t\t\t\t\t\t\tkilled.push(oldOptions);\r\n\r\n\t\t\t\t\t\t\tif (animation.animationOptions.length == 0) {\r\n\t\t\t\t\t\t\t\tanimation.kill();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\r\n\t\t\t\t$array.each(killed, (oldOptions) => {\r\n\t\t\t\t\t$array.remove(animation.animationOptions, oldOptions);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Adds easing functions to \"function\" fields.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @return Assign as function?\r\n\t */\r\n\tprotected asFunction(field: string): boolean {\r\n\t\treturn field == \"easing\" || super.asIs(field);\r\n\t}\r\n\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}