{"ast":null,"code":"/**\r\n * Handles formatting of pseudo-markup in text.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObject } from \"../Base\";\nimport { AMElement } from \"../rendering/AMElement\";\nimport { Adapter } from \"../utils/Adapter\";\nimport { registry } from \"../Registry\";\nimport * as $strings from \"../utils/Strings\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * Handles formatting of pseudo-markdown in text.\r\n *\r\n * @todo Encode < > in output\r\n * @todo Add more adapters\r\n * @important\r\n */\n\nvar TextFormatter =\n/** @class */\nfunction (_super) {\n  __extends(TextFormatter, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function TextFormatter() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Adapter.\r\n     */\n\n\n    _this.adapter = new Adapter(_this);\n    _this.className = \"TextFormatter\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  TextFormatter.prototype.debug = function () {};\n  /**\r\n   * Formats the text according to specifications passed in.\r\n   *\r\n   * @param text    Text to format\r\n   * @param output  Output format (svg, html)\r\n   * @return Formatted text\r\n   */\n\n\n  TextFormatter.prototype.format = function (text, output) {\n    // Apply default\n    if (!$type.hasValue(output)) {\n      output = \"svg\";\n    } // Init return value\n\n\n    var formatted = \"\"; // Replace double (escaped) square spaces with remporary codes\n\n    text = this.escape(text); // Divvy up the string by style tags\n\n    var styles = text.match(/\\[([^\\]]*?)\\]/gm);\n\n    if (!styles) {\n      // Nothing to do here - no formatting elements\n      return this.wrap(text, \"\", output);\n    } // Get pure text - no style tags\n\n\n    var texts = text.split(/\\[[^\\[\\]]*\\]/); // Go through each of the texts and wrap it in style tags\n\n    for (var i = 0, len = texts.length; i < len; i++) {\n      // Get text bit\n      var t = texts[i]; // Check if string is empty\n\n      if (t === \"\") {\n        continue;\n      } // Run through an adapter\n\n\n      t = this.adapter.apply(\"chunk\", t); // Get related style\n\n      var s = \"\";\n\n      if (i > 0) {\n        s = styles[i - 1].replace('[', '').replace(']', '');\n      } // Wrap text in tag\n\n\n      formatted += this.wrap(t, s, output);\n    } // Replace placeholders back\n\n\n    formatted = this.unescape(formatted); // Return result\n\n    return this.cleanUp(formatted);\n  };\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n\n\n  TextFormatter.prototype.escape = function (text) {\n    return text.replace(/\\[\\[/g, registry.getPlaceholder(\"1\")).replace(/([^\\/]{1})\\]\\]/g, \"$1\" + registry.getPlaceholder(\"2\")).replace(/\\]\\]/g, registry.getPlaceholder(\"2\")).replace(/\\{\\{/g, registry.getPlaceholder(\"3\")).replace(/\\}\\}/g, registry.getPlaceholder(\"4\")).replace(/\\'\\'/g, registry.getPlaceholder(\"5\"));\n  };\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n\n\n  TextFormatter.prototype.unescape = function (text) {\n    return text.replace(new RegExp(registry.getPlaceholder(\"1\"), \"g\"), \"[[\").replace(new RegExp(registry.getPlaceholder(\"2\"), \"g\"), \"]]\").replace(new RegExp(registry.getPlaceholder(\"3\"), \"g\"), \"{{\").replace(new RegExp(registry.getPlaceholder(\"4\"), \"g\"), \"}}\").replace(new RegExp(registry.getPlaceholder(\"5\"), \"g\"), \"'\");\n  };\n  /**\r\n   * Cleans up the text text for leftover double square brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Cleaned up text\r\n   */\n\n\n  TextFormatter.prototype.cleanUp = function (text) {\n    return text.replace(/\\[\\[/g, \"[\").replace(/\\]\\]/g, \"]\").replace(/\\{\\{/g, \"{\").replace(/\\}\\}/g, \"}\").replace(/\\'\\'/g, \"'\");\n  };\n  /**\r\n   * Wraps text into corresponding tags.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text to wrap\r\n   * @param style  Styles\r\n   * @param output  Format to output in (svg, html)\r\n   * @return Formatted string\r\n   */\n\n\n  TextFormatter.prototype.wrap = function (text, style, output) {\n    if (style === \"\" || style === \"/\") {\n      //return text;\n      style = \"\";\n    }\n\n    switch (output) {\n      case \"html\":\n        return this.wrapHtml(text, this.translateStyleShortcuts(style));\n\n      default:\n        return this.wrapSvg(text, this.translateStyleShortcuts(style));\n    }\n  };\n  /**\r\n   * Wraps text in styled SVG tag.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text to wrap\r\n   * @param style  Style property\r\n   * @return Formatted tag\r\n   */\n\n\n  TextFormatter.prototype.wrapSvg = function (text, style) {\n    if (style === \"\") {\n      return \"<tspan>\" + text + \"</tspan>\";\n    } else {\n      return \"<tspan style='\" + style + \"'>\" + text + \"</tspan>\";\n    }\n  };\n  /**\r\n   * Returns an SVG `<tspan>` element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text\r\n   * @param style  Style\r\n   * @return Element\r\n   */\n\n\n  TextFormatter.prototype.getSvgElement = function (text, style) {\n    var element = new AMElement(\"tspan\");\n    element.textContent = text;\n\n    if (style) {\n      element.node.setAttribute(\"style\", style);\n    }\n\n    return element;\n  };\n  /**\r\n   * Wraps text in HTML <span> tag.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text to wrap\r\n   * @param style  Style property\r\n   * @return Formatted tag\r\n   * @todo Translate SVG styles into HTML ones\r\n   */\n\n\n  TextFormatter.prototype.wrapHtml = function (text, style) {\n    if (style === \"\") {\n      return \"<span>\" + text + \"</span>\";\n    } else {\n      return \"<span style='\" + this.styleSvgToHtml(style) + \"'>\" + text + \"</span>\";\n    }\n  };\n  /**\r\n   * Returns an HTML `<span>` element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text/HTML\r\n   * @param style  Style definition\r\n   * @return HTML element\r\n   */\n\n\n  TextFormatter.prototype.getHtmlElement = function (text, style) {\n    var element = document.createElement(\"span\");\n    element.innerHTML = text;\n\n    if (style) {\n      element.setAttribute(\"style\", style);\n    }\n\n    return element;\n  };\n  /**\r\n   * Trabslates SVG CSS into HTML CSS.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param style  SVG CSS\r\n   * @return HTML CSS\r\n   * @todo Implement actual translation\r\n   */\n\n\n  TextFormatter.prototype.styleSvgToHtml = function (style) {\n    style = style.replace(/fill:/, \"color:\");\n    return style;\n  };\n  /**\r\n   * Translates style shortcuts into full styles, i.e.:\r\n   * \"bold\" => \"font-weight: bold\"\r\n   * \"#f00\" => \"fill: #f00\"\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param style  Untranslated style\r\n   * @return Translated style\r\n   * @todo Implement actual translation\r\n   */\n\n\n  TextFormatter.prototype.translateStyleShortcuts = function (style) {\n    if (style == \"\" || style == \"[ ]\") {\n      return \"\";\n    }\n\n    var cached = registry.getCache(\"translateStyleShortcuts_\" + style);\n\n    if (cached) {\n      return cached;\n    } // Pre-process quoted text\n\n\n    var q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\n\n    if (q) {\n      for (var i = 0; i < q.length; i++) {\n        style = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\n      }\n    } // Get style parts\n\n\n    var b = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w]+)|(\\/)/gi); // Empty?\n\n    if (!b) {\n      return style;\n    } // Check each part\n\n\n    for (var i = 0; i < b.length; i++) {\n      if (b[i].match(/^bold$/i)) {\n        // Bold\n        b[i] = \"font-weight:\" + b[i];\n      } else if (b[i] == \"/\") {\n        // Just closing tag\n        // Do nothing\n        b[i] = \"\";\n      } else if (!b[i].match(/:/)) {\n        // Color\n        b[i] = \"fill:\" + b[i];\n      } else {\n        b[i] = b[i].replace(/\\+/g, \" \");\n      }\n    }\n\n    var res = b.join(';');\n    registry.setCache(\"translateStyleShortcuts_\" + style, res);\n    return res;\n  };\n  /**\r\n   * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\r\n   *\r\n   * If the second parameter `quotedBlocks` is set to `true` this method will\r\n   * also single out text blocks enclosed within single quotes that no\r\n   * formatting should be applied to, and they should be displayed as is.\r\n   *\r\n   * Default for the above is `false`, so that you can use single quote in text\r\n   * without escaping it.\r\n   *\r\n   * If enabled, single quotes can be escaped by doubling it - adding two\r\n   * single quotes, which will be replaced by a one single quote in the final\r\n   * output.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text          Text to chunk\r\n   * @param quotedBlocks  Use quoted blocks\r\n   * @param noFormatting  Formatting blocks will be treated as regular text\r\n   * @return Array of string chunks\r\n   */\n\n\n  TextFormatter.prototype.chunk = function (text, quotedBlocks, noFormatting) {\n    if (quotedBlocks === void 0) {\n      quotedBlocks = false;\n    }\n\n    if (noFormatting === void 0) {\n      noFormatting = false;\n    } // Init result\n\n\n    var res = []; // Replace double (escaped) square spaces and quotes with temporary codes\n\n    text = this.escape(text); // Deal with style blocks\n\n    var chunks = quotedBlocks ? text.split(\"'\") : [text];\n\n    for (var i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i]; // Empty?\n\n      if (chunk === \"\") {\n        continue;\n      }\n\n      if (i % 2 === 0) {\n        // Text outside quotes\n        // Parse for style blocks which are \"text\" chunks, the rest chunks are\n        // \"value\"\n        chunk = chunk.replace(/\\]\\[/g, \"]\" + $strings.PLACEHOLDER + \"[\");\n        chunk = chunk.replace(/\\[\\]/g, \"[ ]\");\n        var chunks2 = chunk.split(/[\\[\\]]+/);\n\n        for (var i2 = 0; i2 < chunks2.length; i2++) {\n          var chunk2 = this.cleanUp(this.unescape(chunks2[i2])); // Placeholder?\n\n          if (chunk2 === $strings.PLACEHOLDER) {\n            continue;\n          } // Empty?\n\n\n          if (chunk2 === \"\") {\n            continue;\n          } // Block or value\n\n\n          if (i2 % 2 === 0) {\n            res.push({\n              \"type\": \"value\",\n              \"text\": this.adapter.apply(\"chunk\", chunk2)\n            });\n          } else {\n            res.push({\n              \"type\": noFormatting ? \"value\" : \"format\",\n              \"text\": \"[\" + chunk2 + \"]\"\n            });\n          }\n        }\n      } else {\n        // A text within doublequotes\n        // All chunks are \"text\"\n        var chunks2 = chunk.split(/[\\[\\]]+/);\n\n        for (var i2 = 0; i2 < chunks2.length; i2++) {\n          var chunk2 = this.cleanUp(this.unescape(chunks2[i2])); // Empty?\n\n          if (chunk2 === \"\") {\n            continue;\n          } // Block or text\n\n\n          if (i2 % 2 === 0) {\n            res.push({\n              \"type\": \"text\",\n              \"text\": chunk2\n            });\n          } else if (this.isImage(chunk2)) {\n            res.push({\n              \"type\": \"image\",\n              \"text\": \"[\" + chunk2 + \"]\"\n            });\n          } else {\n            res.push({\n              \"type\": \"format\",\n              \"text\": \"[\" + chunk2 + \"]\"\n            });\n          }\n        }\n      }\n    }\n\n    return res;\n  };\n  /**\r\n   * Checks if supplied format contains image information and should be\r\n   * formatted as such.\r\n   * I.e.: `[img: myImage.png]`\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Format\r\n   * @return `true` if it is an image\r\n   */\n\n\n  TextFormatter.prototype.isImage = function (text) {\n    return text.match(/img[ ]?:/) ? true : false;\n  };\n\n  return TextFormatter;\n}(BaseObject);\n\nexport { TextFormatter };\nvar formatter;\n/**\r\n * Returns the global instance of [[TextFormatter]].\r\n *\r\n * All classes and instances should reuse this universal text formatter,\r\n * rather than create their own instance of it.\r\n */\n\nexport function getTextFormatter() {\n  if (formatter == null) {\n    formatter = new TextFormatter();\n  }\n\n  return formatter;\n}\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"TextFormatter\"] = TextFormatter;","map":{"version":3,"sources":["../../../../../src/.internal/core/formatters/TextFormatter.ts"],"names":[],"mappings":"AAAA;;;;AAIA;;;;;;;AAMA,SAAS,UAAT,QAA2B,SAA3B;AACA,SAAS,SAAT,QAA0B,wBAA1B;AACA,SAAS,OAAT,QAAwB,kBAAxB;AACA,SAAS,QAAT,QAAyB,aAAzB;AACA,OAAO,KAAK,QAAZ,MAA0B,kBAA1B;AACA,OAAO,KAAK,KAAZ,MAAuB,eAAvB;AA+BA;;;;;;;;AAOA,IAAA,aAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAmC,EAAA,SAAA,CAAA,aAAA,EAAA,MAAA,CAAA;AAYlC;;;;;AAGA,WAAA,aAAA,GAAA;AAAA,QAAA,KAAA,GACC,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IADR;AARA;;;;;AAGO,IAAA,KAAA,CAAA,OAAA,GAAU,IAAI,OAAJ,CAAmD,KAAnD,CAAV;AAON,IAAA,KAAI,CAAC,SAAL,GAAiB,eAAjB;;AACA,IAAA,KAAI,CAAC,UAAL;;;AACA;;AAES,EAAA,aAAA,CAAA,SAAA,CAAA,KAAA,GAAV,YAAA,CAA2B,CAAjB;AAEV;;;;;;;;;AAOO,EAAA,aAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,IAAd,EAA4B,MAA5B,EAA2C;AAE1C;AACA,QAAI,CAAC,KAAK,CAAC,QAAN,CAAe,MAAf,CAAL,EAA6B;AAC5B,MAAA,MAAM,GAAG,KAAT;AACA,KALyC,CAO1C;;;AACA,QAAI,SAAS,GAAW,EAAxB,CAR0C,CAU1C;;AACA,IAAA,IAAI,GAAG,KAAK,MAAL,CAAY,IAAZ,CAAP,CAX0C,CAa1C;;AACA,QAAI,MAAM,GAAoB,IAAI,CAAC,KAAL,CAAW,iBAAX,CAA9B;;AAEA,QAAI,CAAC,MAAL,EAAa;AACZ;AACA,aAAO,KAAK,IAAL,CAAU,IAAV,EAAgB,EAAhB,EAAoB,MAApB,CAAP;AACA,KAnByC,CAqB1C;;;AACA,QAAI,KAAK,GAAa,IAAI,CAAC,KAAL,CAAW,cAAX,CAAtB,CAtB0C,CAwB1C;;AACA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,GAAG,GAAG,KAAK,CAAC,MAA5B,EAAoC,CAAC,GAAG,GAAxC,EAA6C,CAAC,EAA9C,EAAkD;AAEjD;AACA,UAAI,CAAC,GAAW,KAAK,CAAC,CAAD,CAArB,CAHiD,CAKjD;;AACA,UAAI,CAAC,KAAK,EAAV,EAAc;AACb;AACA,OARgD,CAUjD;;;AACA,MAAA,CAAC,GAAG,KAAK,OAAL,CAAa,KAAb,CAAmB,OAAnB,EAA4B,CAA5B,CAAJ,CAXiD,CAajD;;AACA,UAAI,CAAC,GAAW,EAAhB;;AACA,UAAI,CAAC,GAAG,CAAR,EAAW;AACV,QAAA,CAAC,GAAG,MAAM,CAAC,CAAC,GAAG,CAAL,CAAN,CAAc,OAAd,CAAsB,GAAtB,EAA2B,EAA3B,EAA+B,OAA/B,CAAuC,GAAvC,EAA4C,EAA5C,CAAJ;AACA,OAjBgD,CAmBjD;;;AACA,MAAA,SAAS,IAAI,KAAK,IAAL,CAAU,CAAV,EAAa,CAAb,EAAgB,MAAhB,CAAb;AACA,KA9CyC,CAgD1C;;;AACA,IAAA,SAAS,GAAG,KAAK,QAAL,CAAc,SAAd,CAAZ,CAjD0C,CAmD1C;;AACA,WAAO,KAAK,OAAL,CAAa,SAAb,CAAP;AAEA,GAtDM;AAwDP;;;;;;;;;AAOO,EAAA,aAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,IAAd,EAA0B;AACzB,WAAO,IAAI,CACV,OADM,CACE,OADF,EACW,QAAQ,CAAC,cAAT,CAAwB,GAAxB,CADX,EAEN,OAFM,CAEE,iBAFF,EAEqB,OAAO,QAAQ,CAAC,cAAT,CAAwB,GAAxB,CAF5B,EAGN,OAHM,CAGE,OAHF,EAGW,QAAQ,CAAC,cAAT,CAAwB,GAAxB,CAHX,EAIN,OAJM,CAIE,OAJF,EAIW,QAAQ,CAAC,cAAT,CAAwB,GAAxB,CAJX,EAKN,OALM,CAKE,OALF,EAKW,QAAQ,CAAC,cAAT,CAAwB,GAAxB,CALX,EAMN,OANM,CAME,OANF,EAMW,QAAQ,CAAC,cAAT,CAAwB,GAAxB,CANX,CAAP;AAOA,GARM;AAUP;;;;;;;;;AAOO,EAAA,aAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,IAAhB,EAA4B;AAC3B,WAAO,IAAI,CACV,OADM,CACE,IAAI,MAAJ,CAAW,QAAQ,CAAC,cAAT,CAAwB,GAAxB,CAAX,EAAyC,GAAzC,CADF,EACiD,IADjD,EAEN,OAFM,CAEE,IAAI,MAAJ,CAAW,QAAQ,CAAC,cAAT,CAAwB,GAAxB,CAAX,EAAyC,GAAzC,CAFF,EAEiD,IAFjD,EAGN,OAHM,CAGE,IAAI,MAAJ,CAAW,QAAQ,CAAC,cAAT,CAAwB,GAAxB,CAAX,EAAyC,GAAzC,CAHF,EAGiD,IAHjD,EAIN,OAJM,CAIE,IAAI,MAAJ,CAAW,QAAQ,CAAC,cAAT,CAAwB,GAAxB,CAAX,EAAyC,GAAzC,CAJF,EAIiD,IAJjD,EAKN,OALM,CAKE,IAAI,MAAJ,CAAW,QAAQ,CAAC,cAAT,CAAwB,GAAxB,CAAX,EAAyC,GAAzC,CALF,EAKiD,GALjD,CAAP;AAMA,GAPM;AASP;;;;;;;;;AAOO,EAAA,aAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,IAAf,EAA2B;AAC1B,WAAO,IAAI,CACV,OADM,CACE,OADF,EACW,GADX,EAEN,OAFM,CAEE,OAFF,EAEW,GAFX,EAGN,OAHM,CAGE,OAHF,EAGW,GAHX,EAIN,OAJM,CAIE,OAJF,EAIW,GAJX,EAKN,OALM,CAKE,OALF,EAKW,GALX,CAAP;AAMA,GAPM;AASP;;;;;;;;;;;AASO,EAAA,aAAA,CAAA,SAAA,CAAA,IAAA,GAAP,UAAY,IAAZ,EAA0B,KAA1B,EAAyC,MAAzC,EAAuD;AAEtD,QAAI,KAAK,KAAK,EAAV,IAAgB,KAAK,KAAK,GAA9B,EAAmC;AAClC;AACA,MAAA,KAAK,GAAG,EAAR;AACA;;AAED,YAAQ,MAAR;AACC,WAAK,MAAL;AACC,eAAO,KAAK,QAAL,CAAc,IAAd,EAAoB,KAAK,uBAAL,CAA6B,KAA7B,CAApB,CAAP;;AACD;AACC,eAAO,KAAK,OAAL,CAAa,IAAb,EAAmB,KAAK,uBAAL,CAA6B,KAA7B,CAAnB,CAAP;AAJF;AAOA,GAdM;AAgBP;;;;;;;;;;AAQO,EAAA,aAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,IAAf,EAA6B,KAA7B,EAA0C;AACzC,QAAI,KAAK,KAAK,EAAd,EAAkB;AACjB,aAAO,YAAY,IAAZ,GAAmB,UAA1B;AACA,KAFD,MAGK;AACJ,aAAO,mBAAmB,KAAnB,GAA2B,IAA3B,GAAkC,IAAlC,GAAyC,UAAhD;AACA;AACD,GAPM;AASP;;;;;;;;;;AAQO,EAAA,aAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,IAArB,EAAmC,KAAnC,EAAiD;AAChD,QAAI,OAAO,GAAG,IAAI,SAAJ,CAAc,OAAd,CAAd;AACA,IAAA,OAAO,CAAC,WAAR,GAAsB,IAAtB;;AACA,QAAI,KAAJ,EAAW;AACV,MAAA,OAAO,CAAC,IAAR,CAAa,YAAb,CAA0B,OAA1B,EAAmC,KAAnC;AACA;;AACD,WAAO,OAAP;AACA,GAPM;AASP;;;;;;;;;;;AASO,EAAA,aAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,IAAhB,EAA8B,KAA9B,EAA2C;AAC1C,QAAI,KAAK,KAAK,EAAd,EAAkB;AACjB,aAAO,WAAW,IAAX,GAAkB,SAAzB;AACA,KAFD,MAGK;AACJ,aAAO,kBAAkB,KAAK,cAAL,CAAoB,KAApB,CAAlB,GAA+C,IAA/C,GAAsD,IAAtD,GAA6D,SAApE;AACA;AACD,GAPM;AASP;;;;;;;;;;AAQO,EAAA,aAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,IAAtB,EAAoC,KAApC,EAAkD;AACjD,QAAI,OAAO,GAAG,QAAQ,CAAC,aAAT,CAAuB,MAAvB,CAAd;AACA,IAAA,OAAO,CAAC,SAAR,GAAoB,IAApB;;AACA,QAAI,KAAJ,EAAW;AACV,MAAA,OAAO,CAAC,YAAR,CAAqB,OAArB,EAA8B,KAA9B;AACA;;AACD,WAAO,OAAP;AACA,GAPM;AASP;;;;;;;;;;AAQO,EAAA,aAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,KAAtB,EAAmC;AAClC,IAAA,KAAK,GAAG,KAAK,CAAC,OAAN,CAAc,OAAd,EAAuB,QAAvB,CAAR;AACA,WAAO,KAAP;AACA,GAHM;AAKP;;;;;;;;;;;;AAUO,EAAA,aAAA,CAAA,SAAA,CAAA,uBAAA,GAAP,UAA+B,KAA/B,EAA4C;AAG3C,QAAI,KAAK,IAAI,EAAT,IAAe,KAAK,IAAI,KAA5B,EAAmC;AAClC,aAAO,EAAP;AACA;;AAED,QAAI,MAAM,GAAG,QAAQ,CAAC,QAAT,CAAkB,6BAA6B,KAA/C,CAAb;;AACA,QAAI,MAAJ,EAAY;AACX,aAAO,MAAP;AACA,KAV0C,CAY3C;;;AACA,QAAM,CAAC,GAAG,KAAK,CAAC,KAAN,CAAY,uBAAZ,CAAV;;AACA,QAAI,CAAJ,EAAO;AACN,WAAK,IAAI,CAAC,GAAW,CAArB,EAAwB,CAAC,GAAG,CAAC,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AAC1C,QAAA,KAAK,GAAG,KAAK,CAAC,OAAN,CAAc,CAAC,CAAC,CAAD,CAAf,EAAoB,CAAC,CAAC,CAAD,CAAD,CAAK,OAAL,CAAa,QAAb,EAAuB,EAAvB,EAA2B,OAA3B,CAAmC,OAAnC,EAA4C,GAA5C,CAApB,CAAR;AACA;AACD,KAlB0C,CAoB3C;;;AACA,QAAI,CAAC,GAAoB,KAAK,CAAC,KAAN,CAAY,uDAAZ,CAAzB,CArB2C,CAuB3C;;AACA,QAAI,CAAC,CAAL,EAAQ;AACP,aAAO,KAAP;AACA,KA1B0C,CA4B3C;;;AACA,SAAK,IAAI,CAAC,GAAW,CAArB,EAAwB,CAAC,GAAG,CAAC,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AAE1C,UAAI,CAAC,CAAC,CAAD,CAAD,CAAK,KAAL,CAAW,SAAX,CAAJ,EAA2B;AAC1B;AACA,QAAA,CAAC,CAAC,CAAD,CAAD,GAAO,iBAAiB,CAAC,CAAC,CAAD,CAAzB;AACA,OAHD,MAIK,IAAI,CAAC,CAAC,CAAD,CAAD,IAAQ,GAAZ,EAAiB;AACrB;AACA;AACA,QAAA,CAAC,CAAC,CAAD,CAAD,GAAO,EAAP;AACA,OAJI,MAKA,IAAI,CAAC,CAAC,CAAC,CAAD,CAAD,CAAK,KAAL,CAAW,GAAX,CAAL,EAAsB;AAC1B;AACA,QAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAU,CAAC,CAAC,CAAD,CAAlB;AACA,OAHI,MAIA;AACJ,QAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAAD,CAAK,OAAL,CAAa,KAAb,EAAoB,GAApB,CAAP;AACA;AAED;;AAED,QAAI,GAAG,GAAG,CAAC,CAAC,IAAF,CAAO,GAAP,CAAV;AACA,IAAA,QAAQ,CAAC,QAAT,CAAkB,6BAA6B,KAA/C,EAAsD,GAAtD;AAEA,WAAO,GAAP;AACA,GAtDM;AAwDP;;;;;;;;;;;;;;;;;;;;;;AAoBO,EAAA,aAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,IAAb,EAA2B,YAA3B,EAA0D,YAA1D,EAAuF;AAA5D,QAAA,YAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,YAAA,GAAA,KAAA;AAA6B;;AAAE,QAAA,YAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,YAAA,GAAA,KAAA;AAA6B,KAAA,CAEtF;;;AACA,QAAI,GAAG,GAAiB,EAAxB,CAHsF,CAKtF;;AACA,IAAA,IAAI,GAAG,KAAK,MAAL,CAAY,IAAZ,CAAP,CANsF,CAQtF;;AACA,QAAI,MAAM,GAAG,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAH,GAAqB,CAAC,IAAD,CAA9C;;AACA,SAAK,IAAI,CAAC,GAAW,CAArB,EAAwB,CAAC,GAAG,MAAM,CAAC,MAAnC,EAA2C,CAAC,EAA5C,EAAgD;AAC/C,UAAI,KAAK,GAAG,MAAM,CAAC,CAAD,CAAlB,CAD+C,CAG/C;;AACA,UAAI,KAAK,KAAK,EAAd,EAAkB;AACjB;AACA;;AAED,UAAK,CAAC,GAAG,CAAL,KAAY,CAAhB,EAAmB;AAElB;AACA;AACA;AAEA,QAAA,KAAK,GAAG,KAAK,CAAC,OAAN,CAAc,OAAd,EAAuB,MAAM,QAAQ,CAAC,WAAf,GAA6B,GAApD,CAAR;AACA,QAAA,KAAK,GAAG,KAAK,CAAC,OAAN,CAAc,OAAd,EAAuB,KAAvB,CAAR;AACA,YAAI,OAAO,GAAG,KAAK,CAAC,KAAN,CAAY,SAAZ,CAAd;;AACA,aAAK,IAAI,EAAE,GAAW,CAAtB,EAAyB,EAAE,GAAG,OAAO,CAAC,MAAtC,EAA8C,EAAE,EAAhD,EAAoD;AACnD,cAAI,MAAM,GAAG,KAAK,OAAL,CAAa,KAAK,QAAL,CAAc,OAAO,CAAC,EAAD,CAArB,CAAb,CAAb,CADmD,CAGnD;;AACA,cAAI,MAAM,KAAK,QAAQ,CAAC,WAAxB,EAAqC;AACpC;AACA,WANkD,CAQnD;;;AACA,cAAI,MAAM,KAAK,EAAf,EAAmB;AAClB;AACA,WAXkD,CAanD;;;AACA,cAAK,EAAE,GAAG,CAAN,KAAa,CAAjB,EAAoB;AACnB,YAAA,GAAG,CAAC,IAAJ,CAAS;AACR,sBAAQ,OADA;AAER,sBAAQ,KAAK,OAAL,CAAa,KAAb,CAAmB,OAAnB,EAA4B,MAA5B;AAFA,aAAT;AAIA,WALD,MAMK;AACJ,YAAA,GAAG,CAAC,IAAJ,CAAS;AACR,sBAAQ,YAAY,GAAG,OAAH,GAAa,QADzB;AAER,sBAAQ,MAAM,MAAN,GAAe;AAFf,aAAT;AAIA;AACD;AAED,OArCD,MAsCK;AAEJ;AACA;AAEA,YAAI,OAAO,GAAG,KAAK,CAAC,KAAN,CAAY,SAAZ,CAAd;;AACA,aAAK,IAAI,EAAE,GAAW,CAAtB,EAAyB,EAAE,GAAG,OAAO,CAAC,MAAtC,EAA8C,EAAE,EAAhD,EAAoD;AACnD,cAAI,MAAM,GAAG,KAAK,OAAL,CAAa,KAAK,QAAL,CAAc,OAAO,CAAC,EAAD,CAArB,CAAb,CAAb,CADmD,CAGnD;;AACA,cAAI,MAAM,KAAK,EAAf,EAAmB;AAClB;AACA,WANkD,CAQnD;;;AACA,cAAK,EAAE,GAAG,CAAN,KAAa,CAAjB,EAAoB;AACnB,YAAA,GAAG,CAAC,IAAJ,CAAS;AACR,sBAAQ,MADA;AAER,sBAAQ;AAFA,aAAT;AAIA,WALD,MAMK,IAAI,KAAK,OAAL,CAAa,MAAb,CAAJ,EAA0B;AAC9B,YAAA,GAAG,CAAC,IAAJ,CAAS;AACR,sBAAQ,OADA;AAER,sBAAQ,MAAM,MAAN,GAAe;AAFf,aAAT;AAIA,WALI,MAMA;AACJ,YAAA,GAAG,CAAC,IAAJ,CAAS;AACR,sBAAQ,QADA;AAER,sBAAQ,MAAM,MAAN,GAAe;AAFf,aAAT;AAIA;AACD;AAED;AACD;;AAED,WAAO,GAAP;AACA,GA/FM;AAiGP;;;;;;;;;;;AASO,EAAA,aAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,IAAf,EAA2B;AAC1B,WAAO,IAAI,CAAC,KAAL,CAAW,UAAX,IAAyB,IAAzB,GAAgC,KAAvC;AACA,GAFM;;AAIR,SAAA,aAAA;AAAC,CAtbD,CAAmC,UAAnC,CAAA;;;AAybA,IAAI,SAAJ;AAEA;;;;;;;AAMA,OAAM,SAAU,gBAAV,GAA0B;AAC/B,MAAI,SAAS,IAAI,IAAjB,EAAuB;AACtB,IAAA,SAAS,GAAG,IAAI,aAAJ,EAAZ;AACA;;AAED,SAAO,SAAP;AACA;AAED;;;;;;;AAMA,QAAQ,CAAC,iBAAT,CAA2B,eAA3B,IAA8C,aAA9C","sourcesContent":["/**\r\n * Handles formatting of pseudo-markup in text.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObject } from \"../Base\";\r\nimport { AMElement } from \"../rendering/AMElement\";\r\nimport { Adapter } from \"../utils/Adapter\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $strings from \"../utils/Strings\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n/**\r\n * Defines an interface for an object that holds a chunk of text.\r\n */\r\nexport interface ITextChunk {\r\n\r\n\t/**\r\n\t * Type of the chunk.\r\n\t */\r\n\t\"type\": \"value\" | \"text\" | \"format\" | \"image\",\r\n\r\n\t/**\r\n\t * Text.\r\n\t */\r\n\t\"text\": string\r\n\r\n}\r\n\r\n/**\r\n * A list of Adapters for [[TextFormatter]].\r\n */\r\nexport interface ITextFormatterAdapters {\r\n\r\n\t/**\r\n\t * Applied to each chunk of text when it is parsed and added to chunk list.\r\n\t */\r\n\tchunk: string\r\n\r\n}\r\n\r\n/**\r\n * Handles formatting of pseudo-markdown in text.\r\n *\r\n * @todo Encode < > in output\r\n * @todo Add more adapters\r\n * @important\r\n */\r\nexport class TextFormatter extends BaseObject {\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ITextFormatterAdapters;\r\n\r\n\t/**\r\n\t * Adapter.\r\n\t */\r\n\tpublic adapter = new Adapter<TextFormatter, ITextFormatterAdapters>(this);\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"TextFormatter\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\tprotected debug(): void { }\r\n\r\n\t/**\r\n\t * Formats the text according to specifications passed in.\r\n\t *\r\n\t * @param text    Text to format\r\n\t * @param output  Output format (svg, html)\r\n\t * @return Formatted text\r\n\t */\r\n\tpublic format(text: string, output?: string): string {\r\n\r\n\t\t// Apply default\r\n\t\tif (!$type.hasValue(output)) {\r\n\t\t\toutput = \"svg\";\r\n\t\t}\r\n\r\n\t\t// Init return value\r\n\t\tlet formatted: string = \"\";\r\n\r\n\t\t// Replace double (escaped) square spaces with remporary codes\r\n\t\ttext = this.escape(text);\r\n\r\n\t\t// Divvy up the string by style tags\r\n\t\tlet styles: string[] | null = text.match(/\\[([^\\]]*?)\\]/gm);\r\n\r\n\t\tif (!styles) {\r\n\t\t\t// Nothing to do here - no formatting elements\r\n\t\t\treturn this.wrap(text, \"\", output);\r\n\t\t}\r\n\r\n\t\t// Get pure text - no style tags\r\n\t\tlet texts: string[] = text.split(/\\[[^\\[\\]]*\\]/);\r\n\r\n\t\t// Go through each of the texts and wrap it in style tags\r\n\t\tfor (let i = 0, len = texts.length; i < len; i++) {\r\n\r\n\t\t\t// Get text bit\r\n\t\t\tlet t: string = texts[i];\r\n\r\n\t\t\t// Check if string is empty\r\n\t\t\tif (t === \"\") {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// Run through an adapter\r\n\t\t\tt = this.adapter.apply(\"chunk\", t);\r\n\r\n\t\t\t// Get related style\r\n\t\t\tlet s: string = \"\";\r\n\t\t\tif (i > 0) {\r\n\t\t\t\ts = styles[i - 1].replace('[', '').replace(']', '');\r\n\t\t\t}\r\n\r\n\t\t\t// Wrap text in tag\r\n\t\t\tformatted += this.wrap(t, s, output);\r\n\t\t}\r\n\r\n\t\t// Replace placeholders back\r\n\t\tformatted = this.unescape(formatted);\r\n\r\n\t\t// Return result\r\n\t\treturn this.cleanUp(formatted);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces brackets with temporary placeholders.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Input text\r\n\t * @return Escaped text\r\n\t */\r\n\tpublic escape(text: string): string {\r\n\t\treturn text.\r\n\t\t\treplace(/\\[\\[/g, registry.getPlaceholder(\"1\")).\r\n\t\t\treplace(/([^\\/]{1})\\]\\]/g, \"$1\" + registry.getPlaceholder(\"2\")).\r\n\t\t\treplace(/\\]\\]/g, registry.getPlaceholder(\"2\")).\r\n\t\t\treplace(/\\{\\{/g, registry.getPlaceholder(\"3\")).\r\n\t\t\treplace(/\\}\\}/g, registry.getPlaceholder(\"4\")).\r\n\t\t\treplace(/\\'\\'/g, registry.getPlaceholder(\"5\"));\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces placeholders back to brackets.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Escaped text\r\n\t * @return Unescaped text\r\n\t */\r\n\tpublic unescape(text: string): string {\r\n\t\treturn text.\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"1\"), \"g\"), \"[[\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"2\"), \"g\"), \"]]\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"3\"), \"g\"), \"{{\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"4\"), \"g\"), \"}}\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"5\"), \"g\"), \"'\");\r\n\t}\r\n\r\n\t/**\r\n\t * Cleans up the text text for leftover double square brackets.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Input text\r\n\t * @return Cleaned up text\r\n\t */\r\n\tpublic cleanUp(text: string): string {\r\n\t\treturn text.\r\n\t\t\treplace(/\\[\\[/g, \"[\").\r\n\t\t\treplace(/\\]\\]/g, \"]\").\r\n\t\t\treplace(/\\{\\{/g, \"{\").\r\n\t\t\treplace(/\\}\\}/g, \"}\").\r\n\t\t\treplace(/\\'\\'/g, \"'\");\r\n\t}\r\n\r\n\t/**\r\n\t * Wraps text into corresponding tags.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text to wrap\r\n\t * @param style  Styles\r\n\t * @param output  Format to output in (svg, html)\r\n\t * @return Formatted string\r\n\t */\r\n\tpublic wrap(text: string, style: string, output: string): string {\r\n\r\n\t\tif (style === \"\" || style === \"/\") {\r\n\t\t\t//return text;\r\n\t\t\tstyle = \"\";\r\n\t\t}\r\n\r\n\t\tswitch (output) {\r\n\t\t\tcase \"html\":\r\n\t\t\t\treturn this.wrapHtml(text, this.translateStyleShortcuts(style));\r\n\t\t\tdefault:\r\n\t\t\t\treturn this.wrapSvg(text, this.translateStyleShortcuts(style));\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Wraps text in styled SVG tag.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text to wrap\r\n\t * @param style  Style property\r\n\t * @return Formatted tag\r\n\t */\r\n\tpublic wrapSvg(text: string, style: string): string {\r\n\t\tif (style === \"\") {\r\n\t\t\treturn \"<tspan>\" + text + \"</tspan>\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn \"<tspan style='\" + style + \"'>\" + text + \"</tspan>\";\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an SVG `<tspan>` element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text\r\n\t * @param style  Style\r\n\t * @return Element\r\n\t */\r\n\tpublic getSvgElement(text: string, style?: string): AMElement {\r\n\t\tlet element = new AMElement(\"tspan\");\r\n\t\telement.textContent = text;\r\n\t\tif (style) {\r\n\t\t\telement.node.setAttribute(\"style\", style);\r\n\t\t}\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * Wraps text in HTML <span> tag.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text to wrap\r\n\t * @param style  Style property\r\n\t * @return Formatted tag\r\n\t * @todo Translate SVG styles into HTML ones\r\n\t */\r\n\tpublic wrapHtml(text: string, style: string): string {\r\n\t\tif (style === \"\") {\r\n\t\t\treturn \"<span>\" + text + \"</span>\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn \"<span style='\" + this.styleSvgToHtml(style) + \"'>\" + text + \"</span>\";\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an HTML `<span>` element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text/HTML\r\n\t * @param style  Style definition\r\n\t * @return HTML element\r\n\t */\r\n\tpublic getHtmlElement(text: string, style?: string): HTMLElement {\r\n\t\tlet element = document.createElement(\"span\");\r\n\t\telement.innerHTML = text;\r\n\t\tif (style) {\r\n\t\t\telement.setAttribute(\"style\", style);\r\n\t\t}\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * Trabslates SVG CSS into HTML CSS.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param style  SVG CSS\r\n\t * @return HTML CSS\r\n\t * @todo Implement actual translation\r\n\t */\r\n\tpublic styleSvgToHtml(style: string): string {\r\n\t\tstyle = style.replace(/fill:/, \"color:\");\r\n\t\treturn style;\r\n\t}\r\n\r\n\t/**\r\n\t * Translates style shortcuts into full styles, i.e.:\r\n\t * \"bold\" => \"font-weight: bold\"\r\n\t * \"#f00\" => \"fill: #f00\"\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param style  Untranslated style\r\n\t * @return Translated style\r\n\t * @todo Implement actual translation\r\n\t */\r\n\tpublic translateStyleShortcuts(style: string): string {\r\n\r\n\r\n\t\tif (style == \"\" || style == \"[ ]\") {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\r\n\t\tlet cached = registry.getCache(\"translateStyleShortcuts_\" + style);\r\n\t\tif (cached) {\r\n\t\t\treturn cached;\r\n\t\t}\r\n\r\n\t\t// Pre-process quoted text\r\n\t\tconst q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\r\n\t\tif (q) {\r\n\t\t\tfor (let i: number = 0; i < q.length; i++) {\r\n\t\t\t\tstyle = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Get style parts\r\n\t\tlet b: string[] | null = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w]+)|(\\/)/gi);\r\n\r\n\t\t// Empty?\r\n\t\tif (!b) {\r\n\t\t\treturn style;\r\n\t\t}\r\n\r\n\t\t// Check each part\r\n\t\tfor (let i: number = 0; i < b.length; i++) {\r\n\r\n\t\t\tif (b[i].match(/^bold$/i)) {\r\n\t\t\t\t// Bold\r\n\t\t\t\tb[i] = \"font-weight:\" + b[i];\r\n\t\t\t}\r\n\t\t\telse if (b[i] == \"/\") {\r\n\t\t\t\t// Just closing tag\r\n\t\t\t\t// Do nothing\r\n\t\t\t\tb[i] = \"\";\r\n\t\t\t}\r\n\t\t\telse if (!b[i].match(/:/)) {\r\n\t\t\t\t// Color\r\n\t\t\t\tb[i] = \"fill:\" + b[i];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tb[i] = b[i].replace(/\\+/g, \" \");\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet res = b.join(';');\r\n\t\tregistry.setCache(\"translateStyleShortcuts_\" + style, res);\r\n\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\r\n\t *\r\n\t * If the second parameter `quotedBlocks` is set to `true` this method will\r\n\t * also single out text blocks enclosed within single quotes that no\r\n\t * formatting should be applied to, and they should be displayed as is.\r\n\t *\r\n\t * Default for the above is `false`, so that you can use single quote in text\r\n\t * without escaping it.\r\n\t *\r\n\t * If enabled, single quotes can be escaped by doubling it - adding two\r\n\t * single quotes, which will be replaced by a one single quote in the final\r\n\t * output.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text          Text to chunk\r\n\t * @param quotedBlocks  Use quoted blocks\r\n\t * @param noFormatting  Formatting blocks will be treated as regular text\r\n\t * @return Array of string chunks\r\n\t */\r\n\tpublic chunk(text: string, quotedBlocks: boolean = false, noFormatting: boolean = false): ITextChunk[] {\r\n\r\n\t\t// Init result\r\n\t\tlet res: ITextChunk[] = [];\r\n\r\n\t\t// Replace double (escaped) square spaces and quotes with temporary codes\r\n\t\ttext = this.escape(text);\r\n\r\n\t\t// Deal with style blocks\r\n\t\tlet chunks = quotedBlocks ? text.split(\"'\") : [text];\r\n\t\tfor (let i: number = 0; i < chunks.length; i++) {\r\n\t\t\tlet chunk = chunks[i];\r\n\r\n\t\t\t// Empty?\r\n\t\t\tif (chunk === \"\") {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif ((i % 2) === 0) {\r\n\r\n\t\t\t\t// Text outside quotes\r\n\t\t\t\t// Parse for style blocks which are \"text\" chunks, the rest chunks are\r\n\t\t\t\t// \"value\"\r\n\r\n\t\t\t\tchunk = chunk.replace(/\\]\\[/g, \"]\" + $strings.PLACEHOLDER + \"[\");\r\n\t\t\t\tchunk = chunk.replace(/\\[\\]/g, \"[ ]\");\r\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\r\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\r\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\r\n\r\n\t\t\t\t\t// Placeholder?\r\n\t\t\t\t\tif (chunk2 === $strings.PLACEHOLDER) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Empty?\r\n\t\t\t\t\tif (chunk2 === \"\") {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Block or value\r\n\t\t\t\t\tif ((i2 % 2) === 0) {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"value\",\r\n\t\t\t\t\t\t\t\"text\": this.adapter.apply(\"chunk\", chunk2)\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": noFormatting ? \"value\" : \"format\",\r\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\telse {\r\n\r\n\t\t\t\t// A text within doublequotes\r\n\t\t\t\t// All chunks are \"text\"\r\n\r\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\r\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\r\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\r\n\r\n\t\t\t\t\t// Empty?\r\n\t\t\t\t\tif (chunk2 === \"\") {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Block or text\r\n\t\t\t\t\tif ((i2 % 2) === 0) {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"text\",\r\n\t\t\t\t\t\t\t\"text\": chunk2\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (this.isImage(chunk2)) {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"image\",\r\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"format\",\r\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if supplied format contains image information and should be\r\n\t * formatted as such.\r\n\t * I.e.: `[img: myImage.png]`\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Format\r\n\t * @return `true` if it is an image\r\n\t */\r\n\tpublic isImage(text: string): boolean {\r\n\t\treturn text.match(/img[ ]?:/) ? true : false;\r\n\t}\r\n\r\n}\r\n\r\n\r\nlet formatter: TextFormatter;\r\n\r\n/**\r\n * Returns the global instance of [[TextFormatter]].\r\n *\r\n * All classes and instances should reuse this universal text formatter,\r\n * rather than create their own instance of it.\r\n */\r\nexport function getTextFormatter(): TextFormatter {\r\n\tif (formatter == null) {\r\n\t\tformatter = new TextFormatter();\r\n\t}\r\n\r\n\treturn formatter;\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"TextFormatter\"] = TextFormatter;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}