{"ast":null,"code":"/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Dictionary } from \"./Dictionary\";\nimport * as $type from \"./Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Represents object cache.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Better storage\r\n * @todo TTL logging\r\n * @todo Garbage collector\r\n */\n\nvar Cache =\n/** @class */\nfunction () {\n  function Cache() {\n    /**\r\n     * Storage for cache items.\r\n     */\n    this._storage = new Dictionary();\n    /**\r\n     * Default TTL in milliseconds.\r\n     */\n\n    this.ttl = 1000;\n  }\n  /**\r\n   * Caches or updates cached value, resets TTL.\r\n   *\r\n   * If `ttl` is set to zero, item will never expire.\r\n   *\r\n   * @param owner  An id of the object that owns this cache\r\n   * @param key    Index key\r\n   * @param value  Value\r\n   * @param ttl    TTL of the cache to live in milliseconds\r\n   */\n\n\n  Cache.prototype.set = function (owner, key, value, ttl) {\n    // Create if storage does not exist for this owner\n    var ownerStorage = this._storage.insertKeyIfEmpty(owner, function () {\n      return new Dictionary();\n    }); // Create cache item\n\n\n    var item = {\n      \"touched\": new Date().getTime(),\n      \"ttl\": $type.isNumber(ttl) ? ttl : this.ttl,\n      \"value\": value\n    }; // Set\n\n    ownerStorage.setKey(key, item);\n  };\n  /**\r\n   * Rerturns cached item, respecting TTL.\r\n   *\r\n   * @param owner  An id of the object that owns this cache\r\n   * @param key    Index key\r\n   * @param value  Value to return if cache not available\r\n   * @return Value, or `undefined` if not set\r\n   */\n\n\n  Cache.prototype.get = function (owner, key, value) {\n    if (value === void 0) {\n      value = undefined;\n    } // \t\t || ypeof this._storage[owner][key] === \"undefined\" || this._storage[owner][key].expired === true) {\n\n\n    if (this._storage.hasKey(owner)) {\n      var ownerStorage = this._storage.getKey(owner);\n\n      if (ownerStorage.hasKey(key)) {\n        var cacheItem = ownerStorage.getKey(key);\n\n        if (cacheItem.ttl && cacheItem.touched + cacheItem.ttl < new Date().getTime()) {\n          cacheItem.expired = true;\n        }\n\n        if (cacheItem.expired) {\n          ownerStorage.removeKey(key);\n          return value;\n        }\n\n        return cacheItem.value;\n      } else {\n        return value;\n      }\n    } else {\n      return value;\n    }\n  };\n  /**\r\n   * Clears cache for specific owner or everything.\r\n   *\r\n   * @param owner Owner to clear cache for\r\n   */\n\n\n  Cache.prototype.clear = function (owner) {\n    if (owner) {\n      this._storage.removeKey(owner);\n    } else {\n      this._storage.clear();\n    }\n  };\n\n  return Cache;\n}();\n\nexport { Cache };\n/**\r\n * ============================================================================\r\n * GLOBAL INSTANCE\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A global instance of cache. Use this instance to cache any values.\r\n *\r\n * @ignore Exclude from docs\r\n */\n\nexport var cache = new Cache();","map":{"version":3,"sources":["../../../../../src/.internal/core/utils/Cache.ts"],"names":[],"mappings":"AAAA;;;;;;AAMA,SAAS,UAAT,QAA2B,cAA3B;AACA,OAAO,KAAK,KAAZ,MAAuB,QAAvB;AAwCA;;;;;;;AAOA;;;;;;;;;AAQA,IAAA,KAAA;AAAA;AAAA,YAAA;AAAA,WAAA,KAAA,GAAA;AAEC;;;AAGQ,SAAA,QAAA,GAAW,IAAI,UAAJ,EAAX;AAER;;;;AAGO,SAAA,GAAA,GAAc,IAAd;AA2EP;AAzEA;;;;;;;;;;;;AAUO,EAAA,KAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,KAAX,EAA0B,GAA1B,EAAuC,KAAvC,EAAiD,GAAjD,EAA6D;AAE5D;AACA,QAAI,YAAY,GAAG,KAAK,QAAL,CAAc,gBAAd,CAA+B,KAA/B,EAAsC,YAAA;AAAM,aAAA,IAAA,UAAA,EAAA;AAAsC,KAAlF,CAAnB,CAH4D,CAK5D;;;AACA,QAAI,IAAI,GAAiB;AACxB,iBAAW,IAAI,IAAJ,GAAW,OAAX,EADa;AAExB,aAAO,KAAK,CAAC,QAAN,CAAe,GAAf,IAAsB,GAAtB,GAA4B,KAAK,GAFhB;AAGxB,eAAS;AAHe,KAAzB,CAN4D,CAY5D;;AACA,IAAA,YAAY,CAAC,MAAb,CAAoB,GAApB,EAAyB,IAAzB;AACA,GAdM;AAgBP;;;;;;;;;;AAQO,EAAA,KAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,KAAX,EAA0B,GAA1B,EAAuC,KAAvC,EAA6D;AAAtB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,SAAA;AAAsB,KAAA,CAC5D;;;AACA,QAAI,KAAK,QAAL,CAAc,MAAd,CAAqB,KAArB,CAAJ,EAAiC;AAChC,UAAI,YAAY,GAAqC,KAAK,QAAL,CAAc,MAAd,CAAqB,KAArB,CAArD;;AAEA,UAAI,YAAY,CAAC,MAAb,CAAoB,GAApB,CAAJ,EAA8B;AAC7B,YAAI,SAAS,GAA+B,YAAY,CAAC,MAAb,CAAoB,GAApB,CAA5C;;AACA,YAAI,SAAS,CAAC,GAAV,IAAmB,SAAS,CAAC,OAAV,GAAoB,SAAS,CAAC,GAA/B,GAAsC,IAAI,IAAJ,GAAW,OAAX,EAA5D,EAAmF;AAClF,UAAA,SAAS,CAAC,OAAV,GAAoB,IAApB;AACA;;AACD,YAAI,SAAS,CAAC,OAAd,EAAuB;AACtB,UAAA,YAAY,CAAC,SAAb,CAAuB,GAAvB;AACA,iBAAO,KAAP;AACA;;AACD,eAAO,SAAS,CAAC,KAAjB;AACA,OAVD,MAWK;AACJ,eAAO,KAAP;AACA;AACD,KAjBD,MAkBK;AACJ,aAAO,KAAP;AACA;AACD,GAvBM;AAyBP;;;;;;;AAKO,EAAA,KAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,KAAb,EAA2B;AAC1B,QAAI,KAAJ,EAAW;AACV,WAAK,QAAL,CAAc,SAAd,CAAwB,KAAxB;AACA,KAFD,MAGK;AACJ,WAAK,QAAL,CAAc,KAAd;AACA;AACD,GAPM;;AASR,SAAA,KAAA;AAAC,CArFD,EAAA;;;AAuFA;;;;;;;AAOA;;;;;;AAKA,OAAO,IAAI,KAAK,GAAe,IAAI,KAAJ,EAAxB","sourcesContent":["/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Dictionary } from \"./Dictionary\";\r\nimport * as $type from \"./Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines an interface for cache items.\r\n */\r\ninterface CacheItem<A> {\r\n\r\n\t/**\r\n\t * A timestamp of when the item was created/updated.\r\n\t */\r\n\t\"touched\": number,\r\n\r\n\t/**\r\n\t * TTL (time to live) in milliseconds.\r\n\t */\r\n\t\"ttl\"?: number,\r\n\r\n\t/**\r\n\t * Cached value.\r\n\t */\r\n\t\"value\": A,\r\n\r\n\t/**\r\n\t * Is this item expired?\r\n\t *\r\n\t * @todo a system process that would check chace element TTLs and expire them\r\n\t */\r\n\t\"expired\"?: boolean\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Represents object cache.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Better storage\r\n * @todo TTL logging\r\n * @todo Garbage collector\r\n */\r\nexport class Cache<A> {\r\n\r\n\t/**\r\n\t * Storage for cache items.\r\n\t */\r\n\tprivate _storage = new Dictionary<string, Dictionary<string, CacheItem<A>>>();\r\n\r\n\t/**\r\n\t * Default TTL in milliseconds.\r\n\t */\r\n\tpublic ttl: number = 1000;\r\n\r\n\t/**\r\n\t * Caches or updates cached value, resets TTL.\r\n\t *\r\n\t * If `ttl` is set to zero, item will never expire.\r\n\t *\r\n\t * @param owner  An id of the object that owns this cache\r\n\t * @param key    Index key\r\n\t * @param value  Value\r\n\t * @param ttl    TTL of the cache to live in milliseconds\r\n\t */\r\n\tpublic set(owner: string, key: string, value: A, ttl?: number): void {\r\n\r\n\t\t// Create if storage does not exist for this owner\r\n\t\tlet ownerStorage = this._storage.insertKeyIfEmpty(owner, () => new Dictionary<string, CacheItem<A>>());\r\n\r\n\t\t// Create cache item\r\n\t\tlet item: CacheItem<A> = {\r\n\t\t\t\"touched\": new Date().getTime(),\r\n\t\t\t\"ttl\": $type.isNumber(ttl) ? ttl : this.ttl,\r\n\t\t\t\"value\": value\r\n\t\t};\r\n\r\n\t\t// Set\r\n\t\townerStorage.setKey(key, item);\r\n\t}\r\n\r\n\t/**\r\n\t * Rerturns cached item, respecting TTL.\r\n\t *\r\n\t * @param owner  An id of the object that owns this cache\r\n\t * @param key    Index key\r\n\t * @param value  Value to return if cache not available\r\n\t * @return Value, or `undefined` if not set\r\n\t */\r\n\tpublic get(owner: string, key: string, value: any = undefined): $type.Optional<A> {\r\n\t\t// \t\t || ypeof this._storage[owner][key] === \"undefined\" || this._storage[owner][key].expired === true) {\r\n\t\tif (this._storage.hasKey(owner)) {\r\n\t\t\tlet ownerStorage = <Dictionary<string, CacheItem<A>>>this._storage.getKey(owner);\r\n\r\n\t\t\tif (ownerStorage.hasKey(key)) {\r\n\t\t\t\tlet cacheItem: CacheItem<A> = <CacheItem<A>>ownerStorage.getKey(key);\r\n\t\t\t\tif (cacheItem.ttl && ((cacheItem.touched + cacheItem.ttl) < new Date().getTime())) {\r\n\t\t\t\t\tcacheItem.expired = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (cacheItem.expired) {\r\n\t\t\t\t\townerStorage.removeKey(key);\r\n\t\t\t\t\treturn value;\r\n\t\t\t\t}\r\n\t\t\t\treturn cacheItem.value;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn value;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Clears cache for specific owner or everything.\r\n\t *\r\n\t * @param owner Owner to clear cache for\r\n\t */\r\n\tpublic clear(owner?: string): void {\r\n\t\tif (owner) {\r\n\t\t\tthis._storage.removeKey(owner);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis._storage.clear();\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * ============================================================================\r\n * GLOBAL INSTANCE\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A global instance of cache. Use this instance to cache any values.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport let cache: Cache<any> = new Cache();\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}