{"ast":null,"code":"/**\r\n * Polygon module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Sprite } from \"../Sprite\";\nimport { Morpher } from \"../utils/Morpher\";\nimport { registry } from \"../Registry\";\nimport * as $path from \"../rendering/Path\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Draws a polygon.\r\n *\r\n * @see {@link IPolygonEvents} for a list of available events\r\n * @see {@link IPolygonAdapters} for a list of available Adapters\r\n */\n\nvar Polygon =\n/** @class */\nfunction (_super) {\n  __extends(Polygon, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Polygon() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"Polygon\";\n    _this.element = _this.paper.add(\"path\");\n    _this.shapeRendering = \"auto\";\n    _this._currentPoints = [];\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(Polygon.prototype, \"points\", {\n    /**\r\n     * @return Polygon points\r\n     */\n    get: function get() {\n      var points = this.getPropertyValue(\"points\");\n      var path = this.path;\n\n      if (path && (!points || points.length == 0)) {\n        var valueStr = path.slice(1, path.length - 1);\n        var segments = valueStr.split(\"ZM\");\n\n        for (var s = 0; s < segments.length; s++) {\n          var segment = segments[s];\n\n          if (segment.length > 0) {\n            var areaHole = segment.split(\"M\");\n            var areaArr = areaHole[0];\n            var holeArr = areaHole[1];\n\n            if (areaArr && areaArr.length > 0) {\n              var pointsArr = areaArr.split(\"L\");\n\n              if (pointsArr.length > 0) {\n                var area = [];\n                var areaAndHole = [area];\n                points.push(areaAndHole);\n\n                for (var p = 0; p < pointsArr.length; p++) {\n                  var coords = pointsArr[p].split(\",\");\n                  area.push({\n                    x: +coords[0],\n                    y: +coords[1]\n                  });\n                }\n\n                if (holeArr && holeArr.length > 0) {\n                  var pointsArr_1 = holeArr.split(\"L\");\n\n                  if (pointsArr_1.length > 0) {\n                    var hole = [];\n                    areaAndHole.push(hole);\n\n                    for (var p = pointsArr_1.length - 1; p >= 0; p--) {\n                      var coords = pointsArr_1[p].split(\",\");\n                      hole.push({\n                        x: +coords[0],\n                        y: +coords[1]\n                      });\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        this.setPropertyValue(\"points\", points);\n        this._currentPoints = points;\n      }\n\n      return points;\n    },\n\n    /**\r\n     * An array of X/Y coordinates for each elbow of the polygon.\r\n     *\r\n     * @todo Example\r\n     * @param points  Polygon points\r\n     */\n    set: function set(points) {\n      this.setPropertyValue(\"points\", points, true);\n      this._currentPoints = points;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polygon.prototype, \"currentPoints\", {\n    /**\r\n     * @return Polygon points\r\n     */\n    get: function get() {\n      if ((!this._currentPoints || this._currentPoints.length == 0) && this.path) {\n        this._currentPoints = this.points;\n      }\n\n      return this._currentPoints;\n    },\n\n    /**\r\n     * Current points. Used when morphing the element, so that original `points`\r\n     * are not overwritten.\r\n     *\r\n     * @param points  Polygon points\r\n     */\n    set: function set(points) {\n      if (this._currentPoints != points) {\n        this._currentPoints = points;\n        this.draw();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Draws the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Polygon.prototype.draw = function () {\n    var path = \"\";\n    var points = this._currentPoints;\n    var left;\n    var right;\n    var top;\n    var bottom;\n\n    if (points.length > 0) {\n      // separate areas\n      for (var i = 0, len = points.length; i < len; i++) {\n        // surface\n        var surface = points[i][0];\n        var hole = points[i][1];\n\n        if (surface && surface.length > 0) {\n          var point = surface[0];\n          path += $path.moveTo(point);\n\n          for (var s = 0; s < surface.length; s++) {\n            point = surface[s];\n            path += $path.lineTo(point);\n\n            if (!$type.isNumber(right) || right < point.x) {\n              right = point.x;\n            }\n\n            if (!$type.isNumber(left) || left > point.x) {\n              left = point.x;\n            }\n\n            if (!$type.isNumber(top) || top > point.y) {\n              top = point.y;\n            }\n\n            if (!$type.isNumber(bottom) || bottom < point.y) {\n              bottom = point.y;\n            }\n          }\n        } // hole\n\n\n        if (hole && hole.length > 0) {\n          var point = hole[0];\n          path += $path.moveTo(point);\n\n          for (var h = 0, hlen = hole.length; h < hlen; h++) {\n            point = hole[h];\n            path += $path.lineTo(point);\n          }\n        }\n      }\n\n      if (path) {\n        path += $path.closePath();\n      }\n\n      this.bbox.x = left;\n      this.bbox.y = top;\n      this.bbox.width = right - left;\n      this.bbox.height = bottom - top;\n\n      _super.prototype.setPath.call(this, path);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Polygon.prototype.setPath = function (value) {\n    if (_super.prototype.setPath.call(this, value)) {\n      this.points = [];\n      this._bbox = this.group.getBBox();\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Measures element\r\n   */\n\n\n  Polygon.prototype.measureElement = function () {// Overriding to avoid extra measurement.\n  };\n\n  Object.defineProperty(Polygon.prototype, \"centerPoint\", {\n    /**\r\n     * A calculated center point for the shape.\r\n     *\r\n     * @readonly\r\n     * @return Center\r\n     */\n    get: function get() {\n      return {\n        x: this.bbox.x + this.bbox.width / 2,\n        y: this.bbox.y + this.bbox.height / 2\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polygon.prototype, \"morpher\", {\n    /**\r\n     * A [[Morpher]] instance that is used to morph polygon into some other\r\n     * shape.\r\n     *\r\n     * @readonly\r\n     * @return Morpher instance\r\n     */\n    get: function get() {\n      if (!this._morpher) {\n        this._morpher = new Morpher(this);\n\n        this._disposers.push(this._morpher);\n      }\n\n      return this._morpher;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Polygon;\n}(Sprite);\n\nexport { Polygon };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Polygon\"] = Polygon;","map":{"version":3,"sources":["../../../../../src/.internal/core/elements/Polygon.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Polygon module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Sprite, ISpriteProperties, ISpriteAdapters, ISpriteEvents } from \"../Sprite\";\r\nimport { IPoint } from \"../defs/IPoint\";\r\nimport { Morpher } from \"../utils/Morpher\";\r\nimport { IMorphable } from \"../defs/IMorphable\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $path from \"../rendering/Path\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[Polygon]].\r\n */\r\nexport interface IPolygonProperties extends ISpriteProperties {\r\n\r\n\t/**\r\n\t * An array of X/Y coordinates for each elbow of the polygon.\r\n\t */\r\n\tpoints?: Array<Array<Array<IPoint>>>;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[Polygon]].\r\n */\r\nexport interface IPolygonEvents extends ISpriteEvents { }\r\n\r\n/**\r\n * Defines adapters for [[Polygon]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IPolygonAdapters extends ISpriteAdapters, IPolygonProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Draws a polygon.\r\n *\r\n * @see {@link IPolygonEvents} for a list of available events\r\n * @see {@link IPolygonAdapters} for a list of available Adapters\r\n */\r\nexport class Polygon extends Sprite implements IMorphable {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IPolygonProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IPolygonAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IPolygonEvents;\r\n\r\n\t/**\r\n\t * A morpher instance that is used to morph polygon into some other shape.\r\n\t */\r\n\tprotected _morpher: $type.Optional<Morpher>;\r\n\r\n\t/**\r\n\t * Current points that morpher uses. This is needed so that we don't\r\n\t * overwrite polygons original points.\r\n\t */\r\n\tprotected _currentPoints: Array<Array<Array<IPoint>>>;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"Polygon\";\r\n\t\tthis.element = this.paper.add(\"path\");\r\n\t\tthis.shapeRendering = \"auto\";\r\n\t\tthis._currentPoints = [];\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * An array of X/Y coordinates for each elbow of the polygon.\r\n\t *\r\n\t * @todo Example\r\n\t * @param points  Polygon points\r\n\t */\r\n\tpublic set points(points: Array<Array<Array<IPoint>>>) {\r\n\t\tthis.setPropertyValue(\"points\", points, true);\r\n\t\tthis._currentPoints = points;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Polygon points\r\n\t */\r\n\tpublic get points(): Array<Array<Array<IPoint>>> {\r\n\t\tlet points = this.getPropertyValue(\"points\");\r\n\t\tlet path = this.path;\r\n\r\n\t\tif (path && (!points || points.length == 0)) {\r\n\r\n\t\t\tlet valueStr = path.slice(1, path.length - 1);\r\n\r\n\t\t\tlet segments: string[] = valueStr.split(\"ZM\");\r\n\r\n\t\t\tfor (let s = 0; s < segments.length; s++) {\r\n\t\t\t\tlet segment = segments[s];\r\n\t\t\t\tif (segment.length > 0) {\r\n\t\t\t\t\tlet areaHole = segment.split(\"M\");\r\n\r\n\t\t\t\t\tlet areaArr = areaHole[0];\r\n\t\t\t\t\tlet holeArr = areaHole[1];\r\n\r\n\t\t\t\t\tif (areaArr && areaArr.length > 0) {\r\n\r\n\t\t\t\t\t\tlet pointsArr = areaArr.split(\"L\");\r\n\t\t\t\t\t\tif (pointsArr.length > 0) {\r\n\r\n\t\t\t\t\t\t\tlet area: IPoint[] = [];\r\n\r\n\t\t\t\t\t\t\tlet areaAndHole: Array<Array<IPoint>> = [area];\r\n\t\t\t\t\t\t\tpoints.push(areaAndHole);\r\n\r\n\t\t\t\t\t\t\tfor (let p = 0; p < pointsArr.length; p++) {\r\n\t\t\t\t\t\t\t\tlet coords = pointsArr[p].split(\",\");\r\n\t\t\t\t\t\t\t\tarea.push({ x: +coords[0], y: +coords[1] });\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (holeArr && holeArr.length > 0) {\r\n\t\t\t\t\t\t\t\tlet pointsArr = holeArr.split(\"L\");\r\n\t\t\t\t\t\t\t\tif (pointsArr.length > 0) {\r\n\t\t\t\t\t\t\t\t\tlet hole: IPoint[] = [];\r\n\t\t\t\t\t\t\t\t\tareaAndHole.push(hole);\r\n\t\t\t\t\t\t\t\t\tfor (let p = pointsArr.length - 1; p >= 0; p--) {\r\n\t\t\t\t\t\t\t\t\t\tlet coords = pointsArr[p].split(\",\");\r\n\t\t\t\t\t\t\t\t\t\thole.push({ x: +coords[0], y: +coords[1] });\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.setPropertyValue(\"points\", points);\r\n\t\t\tthis._currentPoints = points;\r\n\t\t}\r\n\t\treturn points;\r\n\t}\r\n\r\n\t/**\r\n\t * Current points. Used when morphing the element, so that original `points`\r\n\t * are not overwritten.\r\n\t *\r\n\t * @param points  Polygon points\r\n\t */\r\n\tpublic set currentPoints(points: Array<Array<Array<IPoint>>>) {\r\n\t\tif (this._currentPoints != points) {\r\n\t\t\tthis._currentPoints = points;\r\n\t\t\tthis.draw();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Polygon points\r\n\t */\r\n\tpublic get currentPoints(): Array<Array<Array<IPoint>>> {\r\n\t\tif((!this._currentPoints || this._currentPoints.length == 0) && this.path){\r\n\t\t\tthis._currentPoints = this.points;\r\n\t\t}\r\n\t\treturn this._currentPoints;\r\n\t}\r\n\r\n\t/**\r\n\t * Draws the element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic draw(): void {\r\n\t\tlet path: string = \"\";\r\n\t\tlet points: Array<Array<Array<IPoint>>> = this._currentPoints;\r\n\r\n\t\tlet left: $type.Optional<number>;\r\n\t\tlet right: $type.Optional<number>;\r\n\t\tlet top: $type.Optional<number>;\r\n\t\tlet bottom: $type.Optional<number>;\r\n\r\n\t\tif (points.length > 0) {\r\n\t\t\t// separate areas\r\n\t\t\tfor (let i = 0, len = points.length; i < len; i++) {\r\n\t\t\t\t// surface\r\n\t\t\t\tlet surface: IPoint[] = points[i][0];\r\n\t\t\t\tlet hole: IPoint[] = points[i][1];\r\n\r\n\t\t\t\tif (surface && surface.length > 0) {\r\n\t\t\t\t\tlet point: IPoint = surface[0];\r\n\r\n\t\t\t\t\tpath += $path.moveTo(point);\r\n\r\n\t\t\t\t\tfor (let s: number = 0; s < surface.length; s++) {\r\n\t\t\t\t\t\tpoint = surface[s];\r\n\t\t\t\t\t\tpath += $path.lineTo(point);\r\n\r\n\t\t\t\t\t\tif (!$type.isNumber(right) || (right < point.x)) {\r\n\t\t\t\t\t\t\tright = point.x;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!$type.isNumber(left) || (left > point.x)) {\r\n\t\t\t\t\t\t\tleft = point.x;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!$type.isNumber(top) || (top > point.y)) {\r\n\t\t\t\t\t\t\ttop = point.y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!$type.isNumber(bottom) || (bottom < point.y)) {\r\n\t\t\t\t\t\t\tbottom = point.y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// hole\r\n\t\t\t\tif (hole && hole.length > 0) {\r\n\t\t\t\t\tlet point: IPoint = hole[0];\r\n\t\t\t\t\tpath += $path.moveTo(point);\r\n\r\n\t\t\t\t\tfor (let h = 0, hlen = hole.length; h < hlen; h++) {\r\n\t\t\t\t\t\tpoint = hole[h];\r\n\t\t\t\t\t\tpath += $path.lineTo(point);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (path) {\r\n\t\t\t\tpath += $path.closePath();\r\n\t\t\t}\r\n\r\n\t\t\tthis.bbox.x = left;\r\n\t\t\tthis.bbox.y = top;\r\n\t\t\tthis.bbox.width = right - left;\r\n\t\t\tthis.bbox.height = bottom - top;\r\n\r\n\t\t\tsuper.setPath(path);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected setPath(value: string): boolean {\r\n\t\tif (super.setPath(value)) {\r\n\t\t\tthis.points = [];\r\n\t\t\tthis._bbox = this.group.getBBox();\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Measures element\r\n\t */\r\n\tprotected measureElement(): void {\r\n\r\n\t\t// Overriding to avoid extra measurement.\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A calculated center point for the shape.\r\n\t *\r\n\t * @readonly\r\n\t * @return Center\r\n\t */\r\n\tpublic get centerPoint(): IPoint {\r\n\t\treturn { x: this.bbox.x + this.bbox.width / 2, y: this.bbox.y + this.bbox.height / 2 };\r\n\t}\r\n\r\n\t/**\r\n\t * A [[Morpher]] instance that is used to morph polygon into some other\r\n\t * shape.\r\n\t *\r\n\t * @readonly\r\n\t * @return Morpher instance\r\n\t */\r\n\tpublic get morpher(): Morpher {\r\n\t\tif (!this._morpher) {\r\n\t\t\tthis._morpher = new Morpher(this);\r\n\t\t\tthis._disposers.push(this._morpher);\r\n\t\t}\r\n\t\treturn this._morpher;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Polygon\"] = Polygon;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}