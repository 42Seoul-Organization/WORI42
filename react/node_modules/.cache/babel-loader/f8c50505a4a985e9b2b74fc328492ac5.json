{"ast":null,"code":"/**\r\n * Base functionality\r\n*/\nimport { __extends } from \"tslib\";\nimport { List, ListTemplate } from \"./utils/List\";\nimport { OrderedListTemplate, SortedListTemplate } from \"./utils/SortedList\";\nimport { Dictionary, DictionaryTemplate } from \"./utils/Dictionary\";\nimport { Disposer } from \"./utils/Disposer\";\nimport { EventDispatcher } from \"./utils/EventDispatcher\";\nimport { Adapter } from \"./utils/Adapter\";\nimport { Color, color } from \"./utils/Color\";\nimport { Percent, percent } from \"./utils/Percent\";\nimport { registry } from \"./Registry\";\nimport { cache } from \"./utils/Cache\";\nimport * as $array from \"./utils/Array\";\nimport * as $object from \"./utils/Object\";\nimport * as $type from \"./utils/Type\"; //import * as $debug from \"./utils/Debug\";\n\n/**\r\n * Provides base functionality for all derivative objects, like generating ids,\r\n * handling cache, etc.\r\n */\n\nvar BaseObject =\n/** @class */\nfunction () {\n  //protected _classes: { [index: string]: any } = {};\n\n  /**\r\n   * Constructor\r\n   * * Sets class name\r\n   */\n  function BaseObject() {\n    /**\r\n     * Indicates if this object has already been deleted. Any\r\n     * destruction/disposal code should take this into account when deciding\r\n     * wheter to run potentially costly disposal operations if they already have\r\n     * been run.\r\n     */\n    this._disposed = false;\n    /**\r\n     * List of IDisposer which will be disposed when the BaseObject is disposed.\r\n     */\n\n    this._disposers = [];\n    this.className = \"BaseObject\"; //this.debug();\n  }\n\n  BaseObject.prototype.debug = function () {//$debug.debug(this);\n  };\n\n  Object.defineProperty(BaseObject.prototype, \"uid\", {\n    /**\r\n     * Returns object's internal unique ID.\r\n     *\r\n     * @return Unique ID\r\n     */\n    get: function get() {\n      if (!this._uid) {\n        this._uid = registry.getUniqueId();\n        registry.map.setKey(this._uid, this);\n      }\n\n      return this._uid;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseObject.prototype, \"id\", {\n    /**\r\n     * @return Id\r\n     */\n    get: function get() {\n      return this._id;\n    },\n\n    /**\r\n     * Sets the user-defined id of the element.\r\n     *\r\n     * @param value Id\r\n     */\n    set: function set(value) {\n      //registry.map.setKey(value, this); // registry.map only stores by uid\n      this._id = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseObject.prototype, \"map\", {\n    /**\r\n     * Returns a universal collection for mapping ids with objects.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Map collection\r\n     */\n    get: function get() {\n      if (!this._map) {\n        this._map = new Dictionary();\n      }\n\n      return this._map;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseObject.prototype, \"delayedMap\", {\n    /**\r\n     * Returns mapping for objects referenced by id in JSON config that are not yet\r\n     * available at processing time.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Map collection\r\n     */\n    get: function get() {\n      if (!this._delayedMap) {\n        this._delayedMap = new Dictionary();\n      }\n\n      return this._delayedMap;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Logs an id and property of the target element that is not yet available\r\n   * for later assignment.\r\n   *\r\n   * @ignore\r\n   * @param  property  Property to set\r\n   * @param  id        ID of the target element\r\n   */\n\n  BaseObject.prototype.addDelayedMap = function (property, id) {\n    var map = this.delayedMap;\n\n    if (!map.hasKey(id)) {\n      map.setKey(id, []);\n    }\n\n    var list = map.getKey(id);\n    list.push({\n      property: property,\n      target: this\n    });\n  };\n  /**\r\n   * Processes delayed JSON config items.\r\n   *\r\n   * @ignore\r\n   */\n\n\n  BaseObject.prototype.processDelayedMap = function () {\n    var _this = this;\n\n    this.delayedMap.each(function (id, list) {\n      if (_this.map.hasKey(id)) {\n        var target_1 = _this.map.getKey(id);\n\n        $array.each(list, function (item) {\n          item.target[item.property] = target_1;\n        });\n\n        _this.delayedMap.removeKey(id);\n      }\n    });\n  };\n  /**\r\n   * Applies properties from all assigned themes.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  BaseObject.prototype.applyTheme = function () {\n    var _this = this; // TODO is this needed ?\n\n\n    if (registry) {\n      var themes = this.getCurrentThemes(); // TODO is this needed ?\n\n      if (themes) {\n        $array.each(themes, function (theme, index) {\n          theme(_this);\n        });\n      }\n    }\n  };\n\n  Object.defineProperty(BaseObject.prototype, \"themes\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return An array of themes\r\n     */\n    get: function get() {\n      return this._themes;\n    },\n\n    /**\r\n     * A list of themes to be used for this element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value An array of themes\r\n     */\n    set: function set(value) {\n      this._themes = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns a list of themes that should be applied to this element. It could\r\n   * either be a list of themes set explicitly on this element, or system-wide.\r\n   *\r\n   * @return List of themes\r\n   */\n\n  BaseObject.prototype.getCurrentThemes = function () {\n    return this.themes || registry.themes;\n  };\n  /**\r\n   * Returns if this object has been already been disposed.\r\n   *\r\n   * @return Is disposed?\r\n   */\n\n\n  BaseObject.prototype.isDisposed = function () {\n    return this._disposed;\n  };\n  /**\r\n   * Destroys this object and all related data.\r\n   */\n\n\n  BaseObject.prototype.dispose = function () {\n    if (!this._disposed) {\n      this._disposed = true;\n      var a = this._disposers;\n      this._disposers = null;\n\n      while (a.length !== 0) {\n        var disposer = a.shift();\n        disposer.dispose();\n      } // Clear cache\n\n\n      this.clearCache(); // remove from clones list\n\n      if (this.clonedFrom) {\n        this.clonedFrom.clones.removeValue(this);\n      }\n\n      var uid = this._uid;\n\n      if (uid != null) {\n        registry.map.removeKey(uid);\n      }\n    }\n  };\n  /**\r\n   * Adds an IDisposer, which will be disposed when this object is disposed.\r\n   *\r\n   * @param target Object to dispose\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  BaseObject.prototype.addDisposer = function (target) {\n    this._disposers.push(target);\n  };\n  /**\r\n   * Disposes disposable object and removes it from `_disposers`.\r\n   *\r\n   * @param target Object to dispose\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  BaseObject.prototype.removeDispose = function (target) {\n    //if(target){\n    if (!this._disposed) {\n      var index = $array.indexOf(this._disposers, target);\n\n      if (index > -1) {\n        this._disposers.splice(index, 1);\n      }\n    }\n\n    target.dispose(); //}\n  };\n  /**\r\n   * Makes a copy of this object and returns the clone. Try to avoid cloning complex objects like chart, create new instances if you need them.\r\n   *\r\n   * @param cloneId  An id to use for clone (if not set a unique id will be generated)\r\n   * @returns Clone\r\n   */\n\n\n  BaseObject.prototype.clone = function (cloneId) {\n    if (!cloneId) {\n      cloneId = \"clone-\" + registry.getUniqueId();\n    }\n\n    var newObject = new this.constructor();\n    newObject.cloneId = cloneId;\n    newObject.copyFrom(this); // add to clones list\n    // this.clones.push(newObject); // moved this to copyFrom\n\n    return newObject;\n  };\n\n  Object.defineProperty(BaseObject.prototype, \"clones\", {\n    /**\r\n     * Returns a collection of object's clones.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Clones\r\n     */\n    get: function get() {\n      if (!this._clones) {\n        this._clones = new List();\n      }\n\n      return this._clones;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies all properties and related data from different element.\r\n   *\r\n   * @param object Source element\r\n   */\n\n  BaseObject.prototype.copyFrom = function (object) {\n    object.clones.push(this); // do not moveValue, as it is expensive! even if there will be several items in clones list, it's not that bad.\n\n    this.clonedFrom = object;\n  };\n\n  Object.defineProperty(BaseObject.prototype, \"className\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Class name\r\n     */\n    get: function get() {\n      return this._className;\n    },\n\n    /**\r\n     * Element's class name. (a class that was used to instantiate the element)\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value  Class name\r\n     */\n    set: function set(value) {\n      this._className = value;\n      /*if (registry) {\r\n          registry.registeredClasses[value] = typeof this;\r\n      }*/\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Caches value in object's cache.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param key    Key\r\n   * @param value  Value\r\n   * @param ttl    TTL in seconds\r\n   */\n\n  BaseObject.prototype.setCache = function (key, value, ttl) {\n    cache.set(this.uid, key, value, ttl);\n  };\n  /**\r\n   * Retrieves cached value.\r\n   *\r\n   * If optional second padarameter is specified, it will return that value\r\n   * if cache is not available or is expired.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param key    Key\r\n   * @param value  Value to return if cache is not available\r\n   * @return Value\r\n   */\n\n\n  BaseObject.prototype.getCache = function (key, value) {\n    if (value === void 0) {\n      value = undefined;\n    }\n\n    return cache.get(this.uid, key, value);\n  };\n  /**\r\n   * Clears object's local cache.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  BaseObject.prototype.clearCache = function () {\n    cache.clear(this.uid);\n  };\n  /**\r\n   * Creates [[Disposer]] for `setTimeout` function call. This ensures that all\r\n   * timeouts created by the object will be cleared when object itself is\r\n   * disposed.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param fn     Callback function\r\n   * @param delay  Timeout (ms)\r\n   * @return Disposer for timeout\r\n   */\n\n\n  BaseObject.prototype.setTimeout = function (fn, delay) {\n    var _this = this;\n\n    var id = setTimeout(function () {\n      _this.removeDispose(disposer);\n\n      fn();\n    }, delay);\n    var disposer = new Disposer(function () {\n      clearTimeout(id);\n    });\n\n    this._disposers.push(disposer);\n\n    return disposer;\n  };\n  /**\r\n   * Creates [[Disposer]] for `setInterval` function call. This ensures that all\r\n   * timeouts created by the object will be cleared when object itself is\r\n   * disposed.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param fn     Callback function\r\n   * @param delay  Timeout (ms)\r\n   * @return Disposer for timeout\r\n   */\n\n\n  BaseObject.prototype.setInterval = function (fn, delay) {\n    var _this = this;\n\n    var id = setInterval(function () {\n      _this.removeDispose(disposer);\n\n      fn();\n    }, delay);\n    var disposer = new Disposer(function () {\n      clearTimeout(id);\n    });\n\n    this._disposers.push(disposer);\n\n    return disposer;\n  };\n\n  Object.defineProperty(BaseObject.prototype, \"config\", {\n    /**\r\n     * ==========================================================================\r\n     * JSON-BASED CONFIG PROCESSING\r\n     * ==========================================================================\r\n     * @hidden\r\n     */\n\n    /**\r\n     * Use this property to set JSON-based config. When set, triggers processing\r\n     * routine, which will go through all properties, and try to apply values,\r\n     * create instances, etc.\r\n     *\r\n     * Use this with caution, as it is a time-consuming process. It's used for\r\n     * initialchart setup only, not routine operations.\r\n     *\r\n     * @param json JSON config\r\n     */\n    set: function set(config) {\n      try {\n        this.processConfig(config);\n      } catch (e) {\n        /*if (this instanceof Sprite) {\r\n            this.raiseCriticalError(e);\r\n        }*/\n        this.raiseCriticalError(e);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes the JSON config.\r\n   *\r\n   * @param json  JSON config\r\n   * @ignore Exclude from docs\r\n   */\n\n  BaseObject.prototype.processConfig = function (config) {\n    var _this = this;\n\n    if (!config) {\n      return;\n    } // Get target\n\n\n    var target = this; // Iterate through all of the items\n\n    $object.eachOrdered(config, function (configKey, value) {\n      var configValue = value; // Is this a callback?\n\n      if (configKey == \"callback\" && typeof value == \"function\") {\n        value.call(target);\n      } // Check if there's a property in target\n\n\n      if (_this.hasProperty(configKey)) {\n        var item_1; // Do we have instructions to create an object?\n        // We create a new object if \"type\" key is set, but only if the\n        // target object is of different type.\n\n        if ($type.isObject(configValue) && $type.hasValue(configValue[\"type\"]) && (!$type.isObject(target[configKey]) || !$type.hasValue(target[configKey].className) || configValue[\"forceCreate\"] || target[configKey].className != configValue[\"type\"]) && !_this.asIs(configKey)) {\n          item_1 = _this.createClassInstance(configValue[\"type\"]); // Create new instance\n\n          if (item_1) {\n            target[configKey] = item_1;\n          } else {\n            item_1 = target[configKey];\n          }\n        } else {\n          // Get item from the object\n          item_1 = target[configKey];\n        }\n        /**\r\n         * It is...\r\n         * --------------------------------------------------------------------\r\n         */\n\n\n        if (item_1 instanceof Adapter) {\n          // ... an Adapter, try to add handlers to it\n          // ------------------------------------------------------------------\n          _this.processAdapters(item_1, configValue);\n        } else if (item_1 instanceof EventDispatcher) {\n          // ... an EventDispatcher, try to add handlers to it\n          // ------------------------------------------------------------------\n          _this.processEvents(item_1, configValue);\n        } else if (configKey == \"locale\" && $type.isString(configValue)) {\n          // ... a locale specified as string, e.g. \"fr_FR\"\n          // ------------------------------------------------------------------\n          if (window[\"am4lang_\" + configValue]) {\n            target[configKey] = window[\"am4lang_\" + configValue];\n          }\n        } else if (configKey == \"parent\" && $type.isString(configValue)) {\n          // ... a parent referred via its it\n          // ------------------------------------------------------------------\n          var parent_1 = _this.map.getKey(configValue);\n\n          if (parent_1) {\n            target[configKey] = parent_1;\n          } else {\n            _this.addDelayedMap(\"parent\", configValue);\n          }\n        } else if (_this.asIs(configKey)) {\n          // ... a special field, just set it to new value\n          // ------------------------------------------------------------------\n          // (no need to add each indvidual item)\n          target[configKey] = configValue;\n        } else if (_this.asFunction(configKey) && $type.isString(configValue)) {\n          // ... a field indicating function name to look for in registry\n          // ------------------------------------------------------------------\n          if ($type.hasValue(registry.registeredClasses[configValue])) {\n            target[configKey] = registry.registeredClasses[configValue];\n          } else {\n            throw Error(\"Invalid easing function: \" + configValue);\n          }\n        } else if (configValue instanceof BaseObject) {\n          // ... a BaseObject object, we just going to use it as it is\n          // ------------------------------------------------------------------\n          target[configKey] = configValue;\n        } else if (item_1 instanceof BaseObject) {\n          // ... another child BaseObject\n          // ------------------------------------------------------------------\n          // Let's just pass in config part in and let itself deal with it\n          item_1.config = configValue;\n        } else if (item_1 instanceof ListTemplate || item_1 instanceof OrderedListTemplate || item_1 instanceof SortedListTemplate) {\n          // ... a list with template\n          // ------------------------------------------------------------------\n          // Let's see what we can do with it\n          if ($type.isArray(configValue)) {\n            // It's an array.\n            // Create a list item for entry, or try to apply properties to an\n            // existing entry if possible and it is present.\n            if (item_1 instanceof ListTemplate) {\n              _this.processListTemplate(configValue, item_1);\n            } else {\n              _this.processOrderedTemplate(configValue, item_1);\n            }\n          } else if ($type.isObject(configValue)) {\n            // It's a single oject.\n            // Treat it as a template.\n            if (configValue instanceof BaseObject) {\n              // Item is already a BaseObject, no need to process it further\n              item_1.template = configValue;\n            } else {\n              // Now let's find out if the whole object if a template, or we\n              // need to get it from `template` key\n              var templateValue = void 0;\n\n              if ($type.hasValue(configValue.template)) {\n                templateValue = configValue.template;\n              } else {\n                templateValue = configValue;\n              }\n\n              if (item_1.template instanceof BaseObject) {\n                // Template is a BaseObject so we will just let its config\n                // deal with the configuration\n                item_1.template.config = templateValue;\n              } else {\n                $object.each(templateValue, function (entryKey, entryValue) {\n                  var listItem = item_1.template[entryKey];\n\n                  if (listItem instanceof Adapter) {\n                    _this.processAdapters(listItem, entryValue);\n                  } else if (listItem instanceof EventDispatcher) {\n                    _this.processEvents(listItem, entryValue);\n                  } else if (listItem instanceof DictionaryTemplate) {\n                    _this.processDictionaryTemplate(listItem, entryValue);\n                  } else if (item_1.template[entryKey] instanceof BaseObject) {\n                    // Template is a BaseObject. Let it deal with its own config.\n                    item_1.template[entryKey].config = entryValue;\n                  } else if ($type.isObject(entryValue) && $type.hasValue(entryValue[\"type\"])) {\n                    listItem = _this.createClassInstance(entryValue[\"type\"]);\n\n                    if (listItem) {\n                      if (listItem instanceof BaseObject) {\n                        listItem.config = entryValue;\n                      }\n\n                      item_1.template[entryKey] = listItem;\n                    } else {\n                      item_1.template[entryKey] = entryValue;\n                    }\n                  } else if (listItem instanceof List) {\n                    // It's List, process it\n                    _this.processList(entryValue, listItem);\n                  } else {\n                    // Aything else. Just assing and be done with it.\n                    item_1.template[entryKey] = _this.maybeColorOrPercent(entryValue);\n                  }\n                });\n              } // Check maybe there are `values` to insert\n\n\n              if ($type.hasValue(configValue.values)) {\n                if (item_1 instanceof ListTemplate) {\n                  _this.processListTemplate(configValue.values, item_1);\n                } else {\n                  _this.processOrderedTemplate(configValue.values, item_1);\n                }\n              }\n            }\n          } else {// Something else?\n            // Not sure what to do with it on a list - ignore\n          }\n        } else if (item_1 instanceof List) {\n          // ... a list\n          // ------------------------------------------------------------------\n          if (configKey == \"children\") {\n            _this.processList(configValue, item_1, _this);\n          } else {\n            _this.processList(configValue, item_1);\n          }\n        } else if (item_1 instanceof DictionaryTemplate) {\n          // ... a dictionary with template\n          // ------------------------------------------------------------------\n          _this.processDictionaryTemplate(item_1, configValue);\n        } else if (item_1 instanceof Dictionary) {\n          // ... a dictionary\n          // ------------------------------------------------------------------\n          _this.processDictionary(item_1, configValue);\n        } else if (item_1 instanceof Color || item_1 instanceof Percent) {\n          // ... it's a Color or Percent\n          // ------------------------------------------------------------------\n          target[configKey] = _this.maybeColorOrPercent(configValue);\n        } else if ($type.isObject(item_1) && $type.isObject(configValue)) {\n          // ... a regular object\n          // ------------------------------------------------------------------\n          $object.copyAllProperties(configValue, item_1);\n        } else {\n          // ... something else - probably a simple property or object\n          // ------------------------------------------------------------------\n          // Maybe convert to `Percent` or `Color`?\n          configValue = _this.maybeColorOrPercent(configValue); // Assign\n\n          target[configKey] = configValue;\n        }\n      } else if (!_this.isReserved(configKey)) {\n        // Doesn't have property set. But we're going to assume JSON config\n        // creator knows what he/she is doing and set it anyway.\n        target[configKey] = configValue;\n      }\n    }, this.configOrder); // Any errors?\n\n    if (this.processingErrors.length) {\n      var errors = this.processingErrors.join(\"\\n\");\n      this._processingErrors = [];\n      throw Error(errors);\n    }\n  };\n  /**\r\n   * Tries to detect if value is color or percent and converts to proper object\r\n   * if necessary.\r\n   *\r\n   * Returns the same source value if no color/percent detected\r\n   *\r\n   * @param value  Source value\r\n   * @return Converted value\r\n   */\n\n\n  BaseObject.prototype.maybeColorOrPercent = function (value) {\n    if ($type.isString(value)) {\n      if (value.match(/^[\\-]?[0-9.]+\\%$/)) {\n        return percent($type.toNumber(value));\n      } else if (value.match(/^\\#[0-9abcdef]{3,}$/i)) {\n        return color(value);\n      }\n    }\n\n    return value;\n  };\n\n  BaseObject.prototype.processAdapters = function (item, config) {\n    var _this = this;\n\n    if ($type.isArray(config)) {\n      $array.each(config, function (entry, index) {\n        item.add(entry.key, entry.callback, entry.priority || 0, _this);\n      });\n    } else if ($type.isObject(config)) {\n      $object.each(config, function (key, entry) {\n        if (!item.has(key, entry)) {\n          item.add(key, entry);\n        }\n      });\n    }\n  };\n\n  BaseObject.prototype.processEvents = function (item, config) {\n    var _this = this;\n\n    if ($type.isObject(config)) {\n      $object.each(config, function (key, entry) {\n        if (!item.has(key, entry)) {\n          item.on(key, entry);\n        }\n      });\n    } else if ($type.isArray(config)) {\n      $array.each(config, function (entry, index) {\n        item.on(entry.type, entry.callback, _this);\n      });\n    }\n  };\n  /**\r\n   * Processes JSON config for a [[DictionaryTemplate]] item.\r\n   *\r\n   * @todo Description\r\n   * @param item    Item\r\n   * @param config  Config\r\n   */\n\n\n  BaseObject.prototype.processDictionaryTemplate = function (item, config) {\n    // We can only process object\n    // Not sure what to do with other types - ignore\n    if ($type.isObject(config)) {\n      // Create an entry for each item, or override properties for\n      // existing one.\n      $object.each(config, function (entryKey, entryValue) {\n        var listItem; // Get existing one, or create a new one\n\n        if (entryKey == \"template\") {\n          listItem = item.template;\n        } else if (item.hasKey(entryKey)) {\n          listItem = item.getKey(entryKey);\n        } else {\n          listItem = item.create(entryKey);\n        } // Set data\n\n\n        if (listItem instanceof BaseObject) {\n          listItem.config = entryValue;\n        } else if ($type.isObject(listItem) && $type.isObject(entryValue)) {\n          $object.copyAllProperties(entryValue, listItem);\n        } else {\n          listItem.setKey(entryKey, entryValue);\n        }\n      });\n    }\n  };\n  /**\r\n   * Processes JSON config for a [[Dictionary]] item.\r\n   *\r\n   * @todo Description\r\n   * @param item    Item\r\n   * @param config  Config\r\n   */\n\n\n  BaseObject.prototype.processDictionary = function (item, config) {\n    // We can only process object\n    // Not sure what to do with other types - ignore\n    if ($type.isObject(config)) {\n      // Create an entry for each item, or override properties for\n      // existing one.\n      // @todo support for non-basic types\n      $object.each(config, function (entryKey, entryValue) {\n        item.setKey(entryKey, entryValue);\n      });\n    }\n  };\n  /**\r\n   * Processes [[ListTemplate]].\r\n   *\r\n   * @param configValue  Config value\r\n   * @param item         Item\r\n   */\n\n\n  BaseObject.prototype.processListTemplate = function (configValue, item) {\n    var _this = this;\n\n    $array.each(configValue, function (entry, index) {\n      var type = _this.getConfigEntryType(entry);\n\n      var listItem;\n\n      if (item.hasIndex(index) && !entry[\"forceCreate\"]) {\n        listItem = item.getIndex(index);\n      } else if (entry instanceof BaseObject) {\n        // Item is already a BaseObject, no need to process it further\n        item.push(entry);\n        return;\n      } else if (type) {\n        listItem = item.create(type);\n      } else {\n        listItem = item.create();\n      }\n\n      if (entry === listItem) {// It's already the same item, do nothing\n      } else {\n        if ($type.isObject(entry)) {\n          // If the list item is BaseObject, we just need to let it\n          // deal if its own config\n          if (listItem instanceof BaseObject) {\n            listItem.config = entry;\n          } else if ($type.isObject(listItem) && $type.isObject(entry)) {\n            $object.copyAllProperties(entry, listItem);\n          } else {\n            item.setIndex(item.indexOf(listItem), entry);\n          }\n        }\n      }\n    }); // Truncate the list if it contains less items than the config\n    // array\n\n    while (configValue.length > item.length) {\n      item.pop();\n    }\n  };\n  /**\r\n   * Processes [[OrdererListTemplate]] or [[SortedListTemplate]].\r\n   *\r\n   * @param configValue  Config value\r\n   * @param item         Item\r\n   */\n\n\n  BaseObject.prototype.processOrderedTemplate = function (configValue, item) {\n    var _this = this;\n\n    $array.each(configValue, function (entry, index) {\n      var type = _this.getConfigEntryType(entry);\n\n      var listItem;\n\n      if (type) {\n        listItem = item.create(type);\n      } else {\n        listItem = item.create();\n      }\n\n      if ($type.isObject(entry)) {\n        // If the list item is BaseObject, we just need to let it\n        // deal if its own config\n        if (listItem instanceof BaseObject) {\n          listItem.config = entry;\n        } else if ($type.isObject(listItem) && $type.isObject(entry)) {\n          $object.copyAllProperties(entry, listItem);\n        } else {\n          item.insert(entry);\n        }\n      }\n    });\n  };\n  /**\r\n   * Processes [[List]].\r\n   *\r\n   * @param configValue  Config value\r\n   * @param item         Item\r\n   */\n\n\n  BaseObject.prototype.processList = function (configValue, item, parent) {\n    var _this = this; // Convert to array if necessary\n\n\n    if (!$type.isArray(configValue)) {\n      configValue = [configValue];\n    } // It's an array\n    // Create a list item for entry\n\n\n    var itemCount = item.length;\n    $array.each(configValue, function (entry, index) {\n      if ($type.isObject(entry)) {\n        // An object.\n        //\n        // Let's see if we can instantiate a class out of it, or we need\n        // to push it into list as it is.\n        //\n        // If there are items already at the specified index in the list,\n        // apply properties rather than create a new one.\n        var listItem = void 0;\n\n        if (index < itemCount && !entry[\"forceCreate\"]) {\n          listItem = item.getIndex(index);\n        } else if (entry instanceof BaseObject) {\n          // Item is already a BaseObject, no need to process it further\n          item.push(entry);\n          return;\n        } else {\n          listItem = _this.createEntryInstance(entry);\n\n          if (parent) {\n            listItem.parent = parent;\n          } else {\n            item.push(listItem);\n          }\n        } // If the list item is BaseObject, we just need to let it\n        // deal if its own config\n\n\n        if (listItem instanceof BaseObject) {\n          listItem.config = entry;\n        } else if ($type.isObject(listItem) && $type.isObject(entry)) {\n          $object.copyAllProperties(entry, listItem);\n        }\n      } else {\n        // Basic value.\n        // Just push it into list, or override existing value\n        if (item.hasIndex(index)) {\n          item.setIndex(index, entry);\n        } else {\n          item.push(entry);\n        }\n      }\n    }); // Truncate the list if it contains less items than the config\n    // array\n\n    while (configValue.length > item.length) {\n      item.pop();\n    }\n  };\n  /**\r\n   * This function is used to sort element's JSON config properties, so that\r\n   * some properties that absolutely need to be processed last, can be put at\r\n   * the end.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param a  Element 1\r\n   * @param b  Element 2\r\n   * @return Sorting number\r\n   */\n\n\n  BaseObject.prototype.configOrder = function (a, b) {\n    if (a == b) {\n      return 0;\n    } // Language must come first, so it's all set up when the rest of the\n    // elements are being instantiated\n    else if (a == \"language\") {\n        return -1;\n      } else if (b == \"language\") {\n        return 1;\n      } else {\n        return 0;\n      }\n  };\n  /**\r\n   * Checks if field should be just assigned as is, without any checking when\r\n   * processing JSON config.\r\n   *\r\n   * Extending functions can override this function to do their own checks.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as is?\r\n   */\n\n\n  BaseObject.prototype.asIs = function (field) {\n    return $array.indexOf([\"locale\"], field) != -1;\n  };\n  /**\r\n   * Checks if field needs to be converted to function, if it is specified\r\n   * as string.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as function?\r\n   */\n\n\n  BaseObject.prototype.asFunction = function (field) {\n    return false;\n  };\n  /**\r\n   * Creates a relevant class instance if such class definition exists.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param className  Class name\r\n   * @return Instance\r\n   */\n\n\n  BaseObject.prototype.createClassInstance = function (className) {\n    if ($type.hasValue(registry.registeredClasses[className])) {\n      return new registry.registeredClasses[className]();\n    } else {\n      throw Error(\"Invalid type: \\\"\" + className + \"\\\".\");\n    }\n  };\n  /**\r\n   * Creates a class instance for a config entry using it's type. (as set in\r\n   * `type` property)\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config part\r\n   * @return Instance\r\n   */\n\n\n  BaseObject.prototype.createEntryInstance = function (config) {\n    var res;\n\n    if ($type.hasValue(config[\"type\"])) {\n      res = this.createClassInstance(config[\"type\"]);\n    }\n\n    if (!res) {\n      return config;\n    }\n\n    return res;\n  };\n  /**\r\n   * Determines config object type.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config part\r\n   * @return Type\r\n   */\n\n\n  BaseObject.prototype.getConfigEntryType = function (config) {\n    if ($type.hasValue(config[\"type\"])) {\n      if ($type.hasValue(registry.registeredClasses[config[\"type\"]])) {\n        return registry.registeredClasses[config[\"type\"]];\n      } else {\n        throw Error(\"Invalid type: \\\"\" + config[\"type\"] + \"\\\".\");\n      }\n    }\n\n    return;\n  };\n  /**\r\n   * Checks if this element has a property.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param prop  Property name\r\n   * @return Has property?\r\n   */\n\n\n  BaseObject.prototype.hasProperty = function (prop) {\n    return prop in this ? true : false;\n  };\n  /**\r\n   * Checkes whether JSON key is a reserved keyword.\r\n   *\r\n   * @param key  Key\r\n   * @return Reserved\r\n   */\n\n\n  BaseObject.prototype.isReserved = function (key) {\n    return [\"type\", \"forceCreate\"].indexOf(key) !== -1;\n  };\n\n  Object.defineProperty(BaseObject.prototype, \"processingErrors\", {\n    /**\r\n     * A list of errors that happened during JSON processing.\r\n     *\r\n     * @return Errors\r\n     */\n    get: function get() {\n      if (!this._processingErrors) {\n        this._processingErrors = [];\n      }\n\n      return this._processingErrors;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return BaseObject;\n}();\n\nexport { BaseObject };\n;\n/**\r\n * A version of [[BaseObject]] with events properties and methods.\r\n * Classes that use [[EventDispatcher]] should extend this instead of\r\n * [[BaseObject]] directly.\r\n */\n\nvar BaseObjectEvents =\n/** @class */\nfunction (_super) {\n  __extends(BaseObjectEvents, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function BaseObjectEvents() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"BaseObjectEvents\";\n    return _this;\n  }\n\n  Object.defineProperty(BaseObjectEvents.prototype, \"events\", {\n    /**\r\n     * An [[EventDispatcher]] instance\r\n     */\n    get: function get() {\n      if (!this._eventDispatcher) {\n        this._eventDispatcher = new EventDispatcher();\n\n        this._disposers.push(this._eventDispatcher);\n      }\n\n      return this._eventDispatcher;\n    },\n    enumerable: true,\n    configurable: true\n  }); //public set events(value:EventDispatcher<AMEvent<this, this[\"_events\"]>>){\n  //\tthis._eventDispatcher = value;\n  //}\n\n  /**\r\n   * Dispatches an event using own event dispatcher. Will automatically\r\n   * populate event data object with event type and target (this element).\r\n   * It also checks if there are any handlers registered for this sepecific\r\n   * event.\r\n   *\r\n   * @param eventType Event type (name)\r\n   * @param data      Data to pass into event handler(s)\r\n   */\n\n  BaseObjectEvents.prototype.dispatch = function (eventType, data) {\n    // @todo Implement proper type check\n    if (this._eventDispatcher) {\n      if (this.events.isEnabled(eventType)) {\n        if (data) {\n          data.type = eventType;\n          data.target = data.target || this;\n          this.events.dispatch(eventType, {\n            type: eventType,\n            target: this\n          });\n        } else {\n          this.events.dispatch(eventType, {\n            type: eventType,\n            target: this\n          });\n        }\n      }\n    }\n  };\n  /**\r\n   * Works like `dispatch`, except event is triggered immediately, without\r\n   * waiting for the next frame cycle.\r\n   *\r\n   * @param eventType Event type (name)\r\n   * @param data      Data to pass into event handler(s)\r\n   */\n\n\n  BaseObjectEvents.prototype.dispatchImmediately = function (eventType, data) {\n    // @todo Implement proper type check\n    if (this._eventDispatcher) {\n      if (this.events.isEnabled(eventType)) {\n        if (data) {\n          data.type = eventType;\n          data.target = data.target || this;\n          this.events.dispatchImmediately(eventType, data);\n        } else {\n          this.events.dispatchImmediately(eventType, {\n            type: eventType,\n            target: this\n          });\n        }\n      }\n    }\n  };\n  /**\r\n   * Copies all parameters from another [[Sprite]].\r\n   *\r\n   * @param source Source object\r\n   */\n\n\n  BaseObjectEvents.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    if (source._eventDispatcher) {\n      this.events.copyFrom(source._eventDispatcher);\n    }\n  };\n\n  return BaseObjectEvents;\n}(BaseObject);\n\nexport { BaseObjectEvents };","map":{"version":3,"sources":["../../../../src/.internal/core/Base.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Base functionality\r\n*/\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { IClone } from \"./utils/Clone\";\r\nimport { List, ListTemplate } from \"./utils/List\";\r\nimport { OrderedListTemplate, SortedListTemplate } from \"./utils/SortedList\";\r\nimport { Dictionary, DictionaryTemplate } from \"./utils/Dictionary\";\r\nimport { Disposer, IDisposer } from \"./utils/Disposer\";\r\nimport { EventDispatcher, AMEvent } from \"./utils/EventDispatcher\";\r\nimport { Adapter } from \"./utils/Adapter\";\r\nimport { Color, color } from \"./utils/Color\";\r\nimport { Percent, percent } from \"./utils/Percent\";\r\nimport { ITheme } from \"../themes/ITheme\";\r\nimport { Ordering } from \"./utils/Order\";\r\n\r\nimport { registry } from \"./Registry\";\r\nimport { cache } from \"./utils/Cache\";\r\n\r\nimport * as $array from \"./utils/Array\";\r\nimport * as $object from \"./utils/Object\";\r\nimport * as $type from \"./utils/Type\";\r\n\r\n//import * as $debug from \"./utils/Debug\";\r\n\r\n/**\r\n * Provides base functionality for all derivative objects, like generating ids,\r\n * handling cache, etc.\r\n */\r\nexport class BaseObject implements IClone<BaseObject>, IDisposer {\r\n\r\n\t/**\r\n\t * A unique ID for this object.\r\n\t *\r\n\t * Generated on first access by `uid()` getter.\r\n\t */\r\n\tprotected _uid: $type.Optional<string>;\r\n\r\n\t/**\r\n\t * Indicates if this object has already been deleted. Any\r\n\t * destruction/disposal code should take this into account when deciding\r\n\t * wheter to run potentially costly disposal operations if they already have\r\n\t * been run.\r\n\t */\r\n\tprotected _disposed: boolean = false;\r\n\r\n\t/**\r\n\t * List of IDisposer which will be disposed when the BaseObject is disposed.\r\n\t */\r\n\tprotected _disposers: Array<IDisposer> = [];\r\n\r\n\t/**\r\n\t * User-defined id of the object.\r\n\t */\r\n\tprotected _id: $type.Optional<string>;\r\n\r\n\t/**\r\n\t * Holds a universal mapping collection, so that elements and their children\r\n\t * can create and look up all kinds of relations between id and object.\r\n\t */\r\n\tprotected _map: $type.Optional<Dictionary<string, any>>;\r\n\r\n\t/**\r\n\t * Holds mapping for objects referenced by id in JSON config that are not yet\r\n\t * available at processing time.\r\n\t */\r\n\tprotected _delayedMap: $type.Optional<Dictionary<string, any>>;\r\n\r\n\t/**\r\n\t * The theme used by this object.\r\n\t */\r\n\tprotected _themes: $type.Optional<ITheme[]>;\r\n\r\n\t// @review\r\n\t/**\r\n\t * A list of objects that are clones of this object. An object needs to\r\n\t * maintain a list of its clones so that properties can be re-applied to\r\n\t * clones whenever property on the object they were cloned from changes.\r\n\t */\r\n\tprotected _clones: $type.Optional<List<this>>;\r\n\r\n\r\n\t// @review\r\n\t/**\r\n\t * Reference to the original object this object was cloned from. We need to\r\n\t * keep this so we can disassociate it from source object when this object\r\n\t * is disposed.\r\n\t */\r\n\tpublic clonedFrom: $type.Optional<this>;\r\n\r\n\t/**\r\n\t * A class name for the object.\r\n\t *\r\n\t * This property is used by deriving classes to identify which class it is.\r\n\t * We could derive the class name from the object itself, however method of\r\n\t * doing so is too costly, so we are relying on this property to quickly\r\n\t * access type of class.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected _className: $type.Optional<string>;\r\n\r\n\t/**\r\n\t * [cloneId description]\r\n\t *\r\n\t * @todo Needs description\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic cloneId: $type.Optional<string>;\r\n\r\n\t/**\r\n\t * Holds processing error list.\r\n\t */\r\n\tprotected _processingErrors: string[];\r\n\r\n\t//protected _classes: { [index: string]: any } = {};\r\n\r\n\t/**\r\n\t * Constructor\r\n\t * * Sets class name\r\n\t */\r\n\tconstructor() {\r\n\t\tthis.className = \"BaseObject\";\r\n\t\t//this.debug();\r\n\t}\r\n\r\n\tprotected debug(): void {\r\n\t\t//$debug.debug(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns object's internal unique ID.\r\n\t *\r\n\t * @return Unique ID\r\n\t */\r\n\tpublic get uid(): string {\r\n\t\tif (!this._uid) {\r\n\t\t\tthis._uid = registry.getUniqueId();\r\n\t\t\tregistry.map.setKey(this._uid, this);\r\n\t\t}\r\n\t\treturn this._uid;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the user-defined id of the element.\r\n\t *\r\n\t * @param value Id\r\n\t */\r\n\tpublic set id(value: $type.Optional<string>) {\r\n\t\t//registry.map.setKey(value, this); // registry.map only stores by uid\r\n\t\tthis._id = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Id\r\n\t */\r\n\tpublic get id(): $type.Optional<string> {\r\n\t\treturn this._id;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a universal collection for mapping ids with objects.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Map collection\r\n\t */\r\n\tpublic get map(): Dictionary<string, any> {\r\n\t\tif (!this._map) {\r\n\t\t\tthis._map = new Dictionary<string, any>();\r\n\t\t}\r\n\t\treturn this._map;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns mapping for objects referenced by id in JSON config that are not yet\r\n\t * available at processing time.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Map collection\r\n\t */\r\n\tpublic get delayedMap(): Dictionary<string, any> {\r\n\t\tif (!this._delayedMap) {\r\n\t\t\tthis._delayedMap = new Dictionary<string, any>();\r\n\t\t}\r\n\t\treturn this._delayedMap;\r\n\t}\r\n\r\n\t/**\r\n\t * Logs an id and property of the target element that is not yet available\r\n\t * for later assignment.\r\n\t * \r\n\t * @ignore\r\n\t * @param  property  Property to set\r\n\t * @param  id        ID of the target element\r\n\t */\r\n\tpublic addDelayedMap(property: string, id: string): void {\r\n\t\tconst map = this.delayedMap;\r\n\t\tif (!map.hasKey(id)) {\r\n\t\t\tmap.setKey(id, []);\r\n\t\t}\r\n\t\tconst list = map.getKey(id);\r\n\t\tlist.push({\r\n\t\t\tproperty: property,\r\n\t\t\ttarget: this\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Processes delayed JSON config items.\r\n\t * \r\n\t * @ignore\r\n\t */\r\n\tpublic processDelayedMap(): void {\r\n\t\tthis.delayedMap.each((id, list) => {\r\n\t\t\tif (this.map.hasKey(id)) {\r\n\t\t\t\tconst target = this.map.getKey(id);\r\n\t\t\t\t$array.each(list, (item: any) => {\r\n\t\t\t\t\titem.target[item.property] = target;\r\n\t\t\t\t});\r\n\t\t\t\tthis.delayedMap.removeKey(id);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Applies properties from all assigned themes.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic applyTheme(): void {\r\n\t\t// TODO is this needed ?\r\n\t\tif (registry) {\r\n\t\t\tlet themes = this.getCurrentThemes();\r\n\r\n\t\t\t// TODO is this needed ?\r\n\t\t\tif (themes) {\r\n\t\t\t\t$array.each(themes, (theme, index) => {\r\n\t\t\t\t\ttheme(this);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * A list of themes to be used for this element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param value An array of themes\r\n\t */\r\n\tpublic set themes(value: $type.Optional<ITheme[]>) {\r\n\t\tthis._themes = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs\r\n\t * @return An array of themes\r\n\t */\r\n\tpublic get themes(): $type.Optional<ITheme[]> {\r\n\t\treturn this._themes;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a list of themes that should be applied to this element. It could\r\n\t * either be a list of themes set explicitly on this element, or system-wide.\r\n\t *\r\n\t * @return List of themes\r\n\t */\r\n\tpublic getCurrentThemes(): ITheme[] {\r\n\t\treturn this.themes || registry.themes;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns if this object has been already been disposed.\r\n\t *\r\n\t * @return Is disposed?\r\n\t */\r\n\tpublic isDisposed(): boolean {\r\n\t\treturn this._disposed;\r\n\t}\r\n\r\n\t/**\r\n\t * Destroys this object and all related data.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tif (!this._disposed) {\r\n\t\t\tthis._disposed = true;\r\n\r\n\t\t\tconst a = this._disposers;\r\n\r\n\t\t\tthis._disposers = <any>null;\r\n\r\n\t\t\twhile (a.length !== 0) {\r\n\t\t\t\tconst disposer = a.shift();\r\n\t\t\t\tdisposer.dispose();\r\n\t\t\t}\r\n\r\n\t\t\t// Clear cache\r\n\t\t\tthis.clearCache();\r\n\r\n\t\t\t// remove from clones list\r\n\t\t\tif (this.clonedFrom) {\r\n\t\t\t\tthis.clonedFrom.clones.removeValue(this);\r\n\t\t\t}\r\n\r\n\t\t\tconst uid = this._uid;\r\n\r\n\t\t\tif (uid != null) {\r\n\t\t\t\tregistry.map.removeKey(uid);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds an IDisposer, which will be disposed when this object is disposed.\r\n\t *\r\n\t * @param target Object to dispose\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic addDisposer(target: IDisposer): void {\r\n\t\tthis._disposers.push(target);\r\n\t}\r\n\r\n\t/**\r\n\t * Disposes disposable object and removes it from `_disposers`.\r\n\t *\r\n\t * @param target Object to dispose\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic removeDispose(target: IDisposer): void {\r\n\t\t//if(target){\r\n\t\tif (!this._disposed) {\r\n\t\t\tlet index = $array.indexOf(this._disposers, target);\r\n\t\t\tif (index > -1) {\r\n\t\t\t\tthis._disposers.splice(index, 1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ttarget.dispose();\r\n\t\t//}\r\n\t}\r\n\r\n\t/**\r\n\t * Makes a copy of this object and returns the clone. Try to avoid cloning complex objects like chart, create new instances if you need them.\r\n\t *\r\n\t * @param cloneId  An id to use for clone (if not set a unique id will be generated)\r\n\t * @returns Clone\r\n\t */\r\n\tpublic clone<A extends this>(cloneId?: string): this {\r\n\t\tif (!cloneId) {\r\n\t\t\tcloneId = \"clone-\" + registry.getUniqueId();\r\n\t\t}\r\n\r\n\t\tlet newObject: this = new (<{ new(): A; }>this.constructor)();\r\n\t\tnewObject.cloneId = cloneId;\r\n\r\n\t\tnewObject.copyFrom(this);\r\n\r\n\t\t// add to clones list\r\n\t\t// this.clones.push(newObject); // moved this to copyFrom\r\n\r\n\r\n\t\treturn newObject;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a collection of object's clones.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Clones\r\n\t */\r\n\tpublic get clones(): List<this> {\r\n\t\tif (!this._clones) {\r\n\t\t\tthis._clones = new List<this>();\r\n\t\t}\r\n\t\treturn this._clones;\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all properties and related data from different element.\r\n\t *\r\n\t * @param object Source element\r\n\t */\r\n\tpublic copyFrom(object: this): void {\r\n\t\tobject.clones.push(this); // do not moveValue, as it is expensive! even if there will be several items in clones list, it's not that bad.\r\n\t\tthis.clonedFrom = object;\r\n\t}\r\n\r\n\t/**\r\n\t * Element's class name. (a class that was used to instantiate the element)\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param value  Class name\r\n\t */\r\n\tpublic set className(value: $type.Optional<string>) {\r\n\t\tthis._className = value;\r\n\t\t/*if (registry) {\r\n\t\t\tregistry.registeredClasses[value] = typeof this;\r\n\t\t}*/\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs\r\n\t * @return Class name\r\n\t */\r\n\tpublic get className(): $type.Optional<string> {\r\n\t\treturn this._className;\r\n\t}\r\n\r\n\t/**\r\n\t * Caches value in object's cache.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param key    Key\r\n\t * @param value  Value\r\n\t * @param ttl    TTL in seconds\r\n\t */\r\n\tpublic setCache(key: string, value: any, ttl?: number): void {\r\n\t\tcache.set(this.uid, key, value, ttl);\r\n\t}\r\n\r\n\t/**\r\n\t * Retrieves cached value.\r\n\t *\r\n\t * If optional second padarameter is specified, it will return that value\r\n\t * if cache is not available or is expired.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param key    Key\r\n\t * @param value  Value to return if cache is not available\r\n\t * @return Value\r\n\t */\r\n\tpublic getCache(key: string, value: any = undefined): any {\r\n\t\treturn cache.get(this.uid, key, value);\r\n\t}\r\n\r\n\t/**\r\n\t * Clears object's local cache.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic clearCache(): void {\r\n\t\tcache.clear(this.uid);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates [[Disposer]] for `setTimeout` function call. This ensures that all\r\n\t * timeouts created by the object will be cleared when object itself is\r\n\t * disposed.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param fn     Callback function\r\n\t * @param delay  Timeout (ms)\r\n\t * @return Disposer for timeout\r\n\t */\r\n\tpublic setTimeout(fn: () => void, delay: number): IDisposer {\r\n\t\tconst id = setTimeout(() => {\r\n\t\t\tthis.removeDispose(disposer);\r\n\t\t\tfn();\r\n\t\t}, delay);\r\n\r\n\t\tconst disposer = new Disposer(() => {\r\n\t\t\tclearTimeout(id);\r\n\t\t});\r\n\r\n\t\tthis._disposers.push(disposer);\r\n\t\treturn disposer;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates [[Disposer]] for `setInterval` function call. This ensures that all\r\n\t * timeouts created by the object will be cleared when object itself is\r\n\t * disposed.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param fn     Callback function\r\n\t * @param delay  Timeout (ms)\r\n\t * @return Disposer for timeout\r\n\t */\r\n\tpublic setInterval(fn: () => void, delay: number): IDisposer {\r\n\t\tconst id = setInterval(() => {\r\n\t\t\tthis.removeDispose(disposer);\r\n\t\t\tfn();\r\n\t\t}, delay);\r\n\r\n\t\tconst disposer = new Disposer(() => {\r\n\t\t\tclearTimeout(id);\r\n\t\t});\r\n\r\n\t\tthis._disposers.push(disposer);\r\n\t\treturn disposer;\r\n\t}\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * JSON-BASED CONFIG PROCESSING\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Use this property to set JSON-based config. When set, triggers processing\r\n\t * routine, which will go through all properties, and try to apply values,\r\n\t * create instances, etc.\r\n\t *\r\n\t * Use this with caution, as it is a time-consuming process. It's used for\r\n\t * initialchart setup only, not routine operations.\r\n\t *\r\n\t * @param json JSON config\r\n\t */\r\n\tpublic set config(config: object) {\r\n\t\ttry {\r\n\t\t\tthis.processConfig(config);\r\n\t\t}\r\n\t\tcatch (e) {\r\n\t\t\t/*if (this instanceof Sprite) {\r\n\t\t\t\tthis.raiseCriticalError(e);\r\n\t\t\t}*/\r\n\t\t\t(<any>this).raiseCriticalError(e);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Processes the JSON config.\r\n\t *\r\n\t * @param json  JSON config\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected processConfig(config?: object): void {\r\n\r\n\t\tif (!config) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Get target\r\n\t\tlet target = <any>this;\r\n\r\n\t\t// Iterate through all of the items\r\n\t\t$object.eachOrdered(config, (configKey, value) => {\r\n\t\t\tlet configValue: any = value;\r\n\r\n\t\t\t// Is this a callback?\r\n\t\t\tif (configKey == \"callback\" && typeof value == \"function\") {\r\n\t\t\t\t(<any>value).call(target);\r\n\t\t\t}\r\n\r\n\t\t\t// Check if there's a property in target\r\n\t\t\tif (this.hasProperty(configKey)) {\r\n\r\n\t\t\t\tlet item: any;\r\n\r\n\t\t\t\t// Do we have instructions to create an object?\r\n\t\t\t\t// We create a new object if \"type\" key is set, but only if the\r\n\t\t\t\t// target object is of different type.\r\n\t\t\t\tif (\r\n\t\t\t\t\t$type.isObject(configValue)\r\n\t\t\t\t\t&& $type.hasValue((<any>configValue)[\"type\"])\r\n\t\t\t\t\t&& (\r\n\t\t\t\t\t\t!$type.isObject(target[configKey])\r\n\t\t\t\t\t\t|| !$type.hasValue(target[configKey].className)\r\n\t\t\t\t\t\t|| (<any>configValue)[\"forceCreate\"]\r\n\t\t\t\t\t\t|| target[configKey].className != (<any>configValue)[\"type\"]\r\n\t\t\t\t\t)\r\n\t\t\t\t\t&& !this.asIs(configKey)\r\n\t\t\t\t) {\r\n\t\t\t\t\titem = this.createClassInstance((<any>configValue)[\"type\"]);\r\n\r\n\t\t\t\t\t// Create new instance\r\n\t\t\t\t\tif (item) {\r\n\t\t\t\t\t\ttarget[configKey] = item;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\titem = target[configKey];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Get item from the object\r\n\t\t\t\t\titem = target[configKey];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/**\r\n\t\t\t\t * It is...\r\n\t\t\t\t * --------------------------------------------------------------------\r\n\t\t\t\t */\r\n\r\n\t\t\t\tif (item instanceof Adapter) {\r\n\r\n\t\t\t\t\t// ... an Adapter, try to add handlers to it\r\n\t\t\t\t\t// ------------------------------------------------------------------\r\n\t\t\t\t\tthis.processAdapters(item, configValue);\r\n\r\n\t\t\t\t}\r\n\t\t\t\telse if (item instanceof EventDispatcher) {\r\n\r\n\t\t\t\t\t// ... an EventDispatcher, try to add handlers to it\r\n\t\t\t\t\t// ------------------------------------------------------------------\r\n\t\t\t\t\tthis.processEvents(item, configValue);\r\n\r\n\t\t\t\t}\r\n\t\t\t\telse if (configKey == \"locale\" && $type.isString(configValue)) {\r\n\r\n\t\t\t\t\t// ... a locale specified as string, e.g. \"fr_FR\"\r\n\t\t\t\t\t// ------------------------------------------------------------------\r\n\t\t\t\t\tif ((<any>window)[\"am4lang_\" + configValue]) {\r\n\t\t\t\t\t\ttarget[configKey] = (<any>window)[\"am4lang_\" + configValue];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\telse if (configKey == \"parent\" && $type.isString(configValue)) {\r\n\r\n\t\t\t\t\t// ... a parent referred via its it\r\n\t\t\t\t\t// ------------------------------------------------------------------\r\n\t\t\t\t\tconst parent = this.map.getKey(configValue);\r\n\t\t\t\t\tif (parent) {\r\n\t\t\t\t\t\ttarget[configKey] = parent;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.addDelayedMap(\"parent\", configValue);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.asIs(configKey)) {\r\n\r\n\t\t\t\t\t// ... a special field, just set it to new value\r\n\t\t\t\t\t// ------------------------------------------------------------------\r\n\t\t\t\t\t// (no need to add each indvidual item)\r\n\t\t\t\t\ttarget[configKey] = configValue;\r\n\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.asFunction(configKey) && $type.isString(configValue)) {\r\n\r\n\t\t\t\t\t// ... a field indicating function name to look for in registry\r\n\t\t\t\t\t// ------------------------------------------------------------------\r\n\t\t\t\t\tif ($type.hasValue(registry.registeredClasses[configValue])) {\r\n\t\t\t\t\t\ttarget[configKey] = registry.registeredClasses[configValue];\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow Error(\"Invalid easing function: \" + configValue);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\telse if (<any>configValue instanceof BaseObject) {\r\n\r\n\t\t\t\t\t// ... a BaseObject object, we just going to use it as it is\r\n\t\t\t\t\t// ------------------------------------------------------------------\r\n\t\t\t\t\ttarget[configKey] = configValue;\r\n\r\n\t\t\t\t}\r\n\t\t\t\telse if (item instanceof BaseObject) {\r\n\r\n\t\t\t\t\t// ... another child BaseObject\r\n\t\t\t\t\t// ------------------------------------------------------------------\r\n\t\t\t\t\t// Let's just pass in config part in and let itself deal with it\r\n\t\t\t\t\titem.config = configValue;\r\n\r\n\t\t\t\t}\r\n\t\t\t\telse if (item instanceof ListTemplate || item instanceof OrderedListTemplate || item instanceof SortedListTemplate) {\r\n\r\n\t\t\t\t\t// ... a list with template\r\n\t\t\t\t\t// ------------------------------------------------------------------\r\n\r\n\t\t\t\t\t// Let's see what we can do with it\r\n\t\t\t\t\tif ($type.isArray(configValue)) {\r\n\r\n\t\t\t\t\t\t// It's an array.\r\n\t\t\t\t\t\t// Create a list item for entry, or try to apply properties to an\r\n\t\t\t\t\t\t// existing entry if possible and it is present.\r\n\t\t\t\t\t\tif (item instanceof ListTemplate) {\r\n\t\t\t\t\t\t\tthis.processListTemplate(configValue, item);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tthis.processOrderedTemplate(configValue, item);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ($type.isObject(configValue)) {\r\n\t\t\t\t\t\t// It's a single oject.\r\n\t\t\t\t\t\t// Treat it as a template.\r\n\t\t\t\t\t\tif (<any>configValue instanceof BaseObject) {\r\n\t\t\t\t\t\t\t// Item is already a BaseObject, no need to process it further\r\n\t\t\t\t\t\t\titem.template = configValue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\t// Now let's find out if the whole object if a template, or we\r\n\t\t\t\t\t\t\t// need to get it from `template` key\r\n\t\t\t\t\t\t\tlet templateValue;\r\n\t\t\t\t\t\t\tif ($type.hasValue((<any>configValue).template)) {\r\n\t\t\t\t\t\t\t\ttemplateValue = (<any>configValue).template;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\ttemplateValue = configValue;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (item.template instanceof BaseObject) {\r\n\t\t\t\t\t\t\t\t// Template is a BaseObject so we will just let its config\r\n\t\t\t\t\t\t\t\t// deal with the configuration\r\n\t\t\t\t\t\t\t\t(<any>item.template).config = templateValue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\t\t$object.each(templateValue, (entryKey, entryValue) => {\r\n\r\n\t\t\t\t\t\t\t\t\tlet listItem = (<any>item.template)[entryKey];\r\n\r\n\t\t\t\t\t\t\t\t\tif (listItem instanceof Adapter) {\r\n\t\t\t\t\t\t\t\t\t\tthis.processAdapters(listItem, entryValue);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse if (listItem instanceof EventDispatcher) {\r\n\t\t\t\t\t\t\t\t\t\tthis.processEvents(listItem, entryValue);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse if (listItem instanceof DictionaryTemplate) {\r\n\t\t\t\t\t\t\t\t\t\tthis.processDictionaryTemplate(listItem, entryValue);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse if (item.template[entryKey] instanceof BaseObject) {\r\n\t\t\t\t\t\t\t\t\t\t// Template is a BaseObject. Let it deal with its own config.\r\n\t\t\t\t\t\t\t\t\t\t(<any>item.template[entryKey]).config = entryValue;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse if ($type.isObject(entryValue) && $type.hasValue((<any>entryValue)[\"type\"])) {\r\n\t\t\t\t\t\t\t\t\t\tlistItem = this.createClassInstance((<any>entryValue)[\"type\"])\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (listItem) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (listItem instanceof BaseObject) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tlistItem.config = <any>entryValue;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\titem.template[entryKey] = listItem;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\titem.template[entryKey] = entryValue;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse if (listItem instanceof List) {\r\n\t\t\t\t\t\t\t\t\t\t// It's List, process it\r\n\t\t\t\t\t\t\t\t\t\tthis.processList(entryValue, listItem);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t// Aything else. Just assing and be done with it.\r\n\t\t\t\t\t\t\t\t\t\titem.template[entryKey] = this.maybeColorOrPercent(entryValue);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Check maybe there are `values` to insert\r\n\t\t\t\t\t\t\tif ($type.hasValue((<any>configValue).values)) {\r\n\t\t\t\t\t\t\t\tif (item instanceof ListTemplate) {\r\n\t\t\t\t\t\t\t\t\tthis.processListTemplate((<any>configValue).values, item);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tthis.processOrderedTemplate((<any>configValue).values, item);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t// Something else?\r\n\t\t\t\t\t\t// Not sure what to do with it on a list - ignore\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\telse if (item instanceof List) {\r\n\r\n\t\t\t\t\t// ... a list\r\n\t\t\t\t\t// ------------------------------------------------------------------\r\n\r\n\t\t\t\t\tif (configKey == \"children\") {\r\n\t\t\t\t\t\tthis.processList(configValue, item, this);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.processList(configValue, item);\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\telse if (item instanceof DictionaryTemplate) {\r\n\r\n\t\t\t\t\t// ... a dictionary with template\r\n\t\t\t\t\t// ------------------------------------------------------------------\r\n\r\n\t\t\t\t\tthis.processDictionaryTemplate(item, configValue);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\telse if (item instanceof Dictionary) {\r\n\r\n\t\t\t\t\t// ... a dictionary\r\n\t\t\t\t\t// ------------------------------------------------------------------\r\n\r\n\t\t\t\t\tthis.processDictionary(item, configValue);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\telse if (item instanceof Color || item instanceof Percent) {\r\n\r\n\t\t\t\t\t// ... it's a Color or Percent\r\n\t\t\t\t\t// ------------------------------------------------------------------\r\n\t\t\t\t\ttarget[configKey] = this.maybeColorOrPercent(configValue);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\telse if ($type.isObject(item) && $type.isObject(configValue)) {\r\n\r\n\t\t\t\t\t// ... a regular object\r\n\t\t\t\t\t// ------------------------------------------------------------------\r\n\r\n\t\t\t\t\t$object.copyAllProperties(<Object>configValue, <Object>item);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\telse {\r\n\r\n\t\t\t\t\t// ... something else - probably a simple property or object\r\n\t\t\t\t\t// ------------------------------------------------------------------\r\n\r\n\t\t\t\t\t// Maybe convert to `Percent` or `Color`?\r\n\t\t\t\t\tconfigValue = this.maybeColorOrPercent(configValue);\r\n\r\n\t\t\t\t\t// Assign\r\n\t\t\t\t\ttarget[configKey] = configValue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\telse if (!this.isReserved(configKey)) {\r\n\r\n\t\t\t\t// Doesn't have property set. But we're going to assume JSON config\r\n\t\t\t\t// creator knows what he/she is doing and set it anyway.\r\n\t\t\t\ttarget[configKey] = configValue;\r\n\r\n\t\t\t}\r\n\t\t}, this.configOrder);\r\n\r\n\t\t// Any errors?\r\n\t\tif (this.processingErrors.length) {\r\n\t\t\tlet errors = this.processingErrors.join(\"\\n\");\r\n\t\t\tthis._processingErrors = [];\r\n\t\t\tthrow Error(errors);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Tries to detect if value is color or percent and converts to proper object\r\n\t * if necessary.\r\n\t *\r\n\t * Returns the same source value if no color/percent detected\r\n\t *\r\n\t * @param value  Source value\r\n\t * @return Converted value\r\n\t */\r\n\tprotected maybeColorOrPercent(value: any): any {\r\n\t\tif ($type.isString(value)) {\r\n\t\t\tif (value.match(/^[\\-]?[0-9.]+\\%$/)) {\r\n\t\t\t\treturn percent($type.toNumber(value));\r\n\t\t\t}\r\n\t\t\telse if (value.match(/^\\#[0-9abcdef]{3,}$/i)) {\r\n\t\t\t\treturn color(value);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\tprotected processAdapters(item: Adapter<any, any>, config: any): void {\r\n\t\tif ($type.isArray(config)) {\r\n\t\t\t$array.each(config, (entry: { key: string, callback: any, priority?: number }, index) => {\r\n\t\t\t\titem.add(entry.key, entry.callback, entry.priority || 0, this);\r\n\t\t\t});\r\n\t\t}\r\n\t\telse if ($type.isObject(config)) {\r\n\t\t\t$object.each(config, (key, entry) => {\r\n\t\t\t\tif (!item.has(key, entry)) {\r\n\t\t\t\t\titem.add(key, entry);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tprotected processEvents(item: EventDispatcher<any>, config: any): void {\r\n\t\tif ($type.isObject(config)) {\r\n\t\t\t$object.each(config, (key, entry) => {\r\n\t\t\t\tif (!item.has(key, entry)) {\r\n\t\t\t\t\titem.on(key, entry);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\telse if ($type.isArray(config)) {\r\n\t\t\t$array.each(config, (entry: { type: string, callback: any }, index) => {\r\n\t\t\t\titem.on(entry.type, entry.callback, this);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON config for a [[DictionaryTemplate]] item.\r\n\t *\r\n\t * @todo Description\r\n\t * @param item    Item\r\n\t * @param config  Config\r\n\t */\r\n\tprotected processDictionaryTemplate(item: DictionaryTemplate<any, any>, config: any): void {\r\n\r\n\t\t// We can only process object\r\n\t\t// Not sure what to do with other types - ignore\r\n\t\tif ($type.isObject(config)) {\r\n\r\n\t\t\t// Create an entry for each item, or override properties for\r\n\t\t\t// existing one.\r\n\t\t\t$object.each(config, (entryKey, entryValue) => {\r\n\t\t\t\tlet listItem;\r\n\r\n\t\t\t\t// Get existing one, or create a new one\r\n\t\t\t\tif (entryKey == \"template\") {\r\n\t\t\t\t\tlistItem = item.template;\r\n\t\t\t\t}\r\n\t\t\t\telse if (item.hasKey(entryKey)) {\r\n\t\t\t\t\tlistItem = item.getKey(entryKey);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlistItem = item.create(entryKey);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Set data\r\n\t\t\t\tif (listItem instanceof BaseObject) {\r\n\t\t\t\t\tlistItem.config = entryValue;\r\n\t\t\t\t}\r\n\t\t\t\telse if ($type.isObject(listItem) && $type.isObject(entryValue)) {\r\n\t\t\t\t\t$object.copyAllProperties(<Object>entryValue, <Object>listItem);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlistItem.setKey(entryKey, entryValue);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON config for a [[Dictionary]] item.\r\n\t *\r\n\t * @todo Description\r\n\t * @param item    Item\r\n\t * @param config  Config\r\n\t */\r\n\tprotected processDictionary(item: Dictionary<any, any>, config: any): void {\r\n\r\n\t\t// We can only process object\r\n\t\t// Not sure what to do with other types - ignore\r\n\t\tif ($type.isObject(config)) {\r\n\r\n\t\t\t// Create an entry for each item, or override properties for\r\n\t\t\t// existing one.\r\n\t\t\t// @todo support for non-basic types\r\n\t\t\t$object.each(config, (entryKey, entryValue) => {\r\n\t\t\t\titem.setKey(entryKey, entryValue);\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Processes [[ListTemplate]].\r\n\t *\r\n\t * @param configValue  Config value\r\n\t * @param item         Item\r\n\t */\r\n\tprotected processListTemplate(configValue: any, item: ListTemplate<any>): void {\r\n\r\n\t\t$array.each(configValue, (entry, index) => {\r\n\t\t\tlet type = this.getConfigEntryType(entry);\r\n\t\t\tlet listItem;\r\n\t\t\tif (item.hasIndex(index) && !(<any>entry)[\"forceCreate\"]) {\r\n\t\t\t\tlistItem = item.getIndex(index);\r\n\t\t\t}\r\n\t\t\telse if (<any>entry instanceof BaseObject) {\r\n\t\t\t\t// Item is already a BaseObject, no need to process it further\r\n\t\t\t\titem.push(entry);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\telse if (type) {\r\n\t\t\t\tlistItem = item.create(type);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlistItem = item.create();\r\n\t\t\t}\r\n\r\n\t\t\tif (entry === listItem) {\r\n\t\t\t\t// It's already the same item, do nothing\r\n\t\t\t}\r\n\t\t\telse {\r\n\r\n\t\t\t\tif ($type.isObject(entry)) {\r\n\r\n\t\t\t\t\t// If the list item is BaseObject, we just need to let it\r\n\t\t\t\t\t// deal if its own config\r\n\t\t\t\t\tif (listItem instanceof BaseObject) {\r\n\t\t\t\t\t\t(<any>listItem).config = entry;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ($type.isObject(listItem) && $type.isObject(entry)) {\r\n\t\t\t\t\t\t$object.copyAllProperties(<Object>entry, <Object>listItem);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\titem.setIndex(item.indexOf(listItem), entry);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Truncate the list if it contains less items than the config\r\n\t\t// array\r\n\t\twhile (configValue.length > item.length) {\r\n\t\t\titem.pop();\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Processes [[OrdererListTemplate]] or [[SortedListTemplate]].\r\n\t *\r\n\t * @param configValue  Config value\r\n\t * @param item         Item\r\n\t */\r\n\tprotected processOrderedTemplate(configValue: any, item: OrderedListTemplate<any> | SortedListTemplate<any>): void {\r\n\r\n\t\t$array.each(configValue, (entry, index) => {\r\n\t\t\tlet type = this.getConfigEntryType(entry);\r\n\t\t\tlet listItem;\r\n\t\t\tif (type) {\r\n\t\t\t\tlistItem = item.create(type);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlistItem = item.create();\r\n\t\t\t}\r\n\r\n\t\t\tif ($type.isObject(entry)) {\r\n\r\n\t\t\t\t// If the list item is BaseObject, we just need to let it\r\n\t\t\t\t// deal if its own config\r\n\t\t\t\tif (listItem instanceof BaseObject) {\r\n\t\t\t\t\t(<any>listItem).config = entry;\r\n\t\t\t\t}\r\n\t\t\t\telse if ($type.isObject(listItem) && $type.isObject(entry)) {\r\n\t\t\t\t\t$object.copyAllProperties(<Object>entry, <Object>listItem);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\titem.insert(entry);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Processes [[List]].\r\n\t *\r\n\t * @param configValue  Config value\r\n\t * @param item         Item\r\n\t */\r\n\tprotected processList(configValue: any, item: List<any>, parent?: any): void {\r\n\r\n\t\t// Convert to array if necessary\r\n\t\tif (!$type.isArray(configValue)) {\r\n\t\t\tconfigValue = [configValue];\r\n\t\t}\r\n\r\n\t\t// It's an array\r\n\t\t// Create a list item for entry\r\n\t\tconst itemCount = item.length;\r\n\t\t$array.each(configValue, (entry, index) => {\r\n\r\n\t\t\tif ($type.isObject(entry)) {\r\n\r\n\r\n\t\t\t\t// An object.\r\n\t\t\t\t//\r\n\t\t\t\t// Let's see if we can instantiate a class out of it, or we need\r\n\t\t\t\t// to push it into list as it is.\r\n\t\t\t\t//\r\n\t\t\t\t// If there are items already at the specified index in the list,\r\n\t\t\t\t// apply properties rather than create a new one.\r\n\r\n\t\t\t\tlet listItem;\r\n\t\t\t\tif ((index < itemCount) && !(<any>entry)[\"forceCreate\"]) {\r\n\t\t\t\t\tlistItem = item.getIndex(index);\r\n\t\t\t\t}\r\n\t\t\t\telse if (<any>entry instanceof BaseObject) {\r\n\t\t\t\t\t// Item is already a BaseObject, no need to process it further\r\n\t\t\t\t\titem.push(entry);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlistItem = this.createEntryInstance(entry);\r\n\t\t\t\t\tif (parent) {\r\n\t\t\t\t\t\tlistItem.parent = parent;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\titem.push(listItem);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If the list item is BaseObject, we just need to let it\r\n\t\t\t\t// deal if its own config\r\n\t\t\t\tif (listItem instanceof BaseObject) {\r\n\t\t\t\t\t(<any>listItem).config = entry;\r\n\t\t\t\t}\r\n\t\t\t\telse if ($type.isObject(listItem) && $type.isObject(entry)) {\r\n\t\t\t\t\t$object.copyAllProperties(<Object>entry, <Object>listItem);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\telse {\r\n\r\n\t\t\t\t// Basic value.\r\n\t\t\t\t// Just push it into list, or override existing value\r\n\t\t\t\tif (item.hasIndex(index)) {\r\n\t\t\t\t\titem.setIndex(index, entry);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\titem.push(entry);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t\t// Truncate the list if it contains less items than the config\r\n\t\t// array\r\n\t\twhile (configValue.length > item.length) {\r\n\t\t\titem.pop();\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * This function is used to sort element's JSON config properties, so that\r\n\t * some properties that absolutely need to be processed last, can be put at\r\n\t * the end.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param a  Element 1\r\n\t * @param b  Element 2\r\n\t * @return Sorting number\r\n\t */\r\n\tprotected configOrder(a: string, b: string): Ordering {\r\n\t\tif (a == b) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// Language must come first, so it's all set up when the rest of the\r\n\t\t// elements are being instantiated\r\n\t\telse if (a == \"language\") {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\telse if (b == \"language\") {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\telse {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if field should be just assigned as is, without any checking when\r\n\t * processing JSON config.\r\n\t *\r\n\t * Extending functions can override this function to do their own checks.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @return Assign as is?\r\n\t */\r\n\tprotected asIs(field: string): boolean {\r\n\t\treturn $array.indexOf([\"locale\"], field) != -1;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if field needs to be converted to function, if it is specified\r\n\t * as string.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @return Assign as function?\r\n\t */\r\n\tprotected asFunction(field: string): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a relevant class instance if such class definition exists.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param className  Class name\r\n\t * @return Instance\r\n\t */\r\n\tprotected createClassInstance(className: string): Object {\r\n\t\tif ($type.hasValue(registry.registeredClasses[className])) {\r\n\t\t\treturn new registry.registeredClasses[className]();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthrow Error(\"Invalid type: \\\"\" + className + \"\\\".\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a class instance for a config entry using it's type. (as set in\r\n\t * `type` property)\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param config  Config part\r\n\t * @return Instance\r\n\t */\r\n\tprotected createEntryInstance(config: any): any {\r\n\t\tlet res: Object;\r\n\t\tif ($type.hasValue(config[\"type\"])) {\r\n\t\t\tres = this.createClassInstance(config[\"type\"]);\r\n\t\t}\r\n\t\tif (!res) {\r\n\t\t\treturn config;\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Determines config object type.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param config  Config part\r\n\t * @return Type\r\n\t */\r\n\tprotected getConfigEntryType(config: any): any {\r\n\t\tif ($type.hasValue(config[\"type\"])) {\r\n\t\t\tif ($type.hasValue(registry.registeredClasses[config[\"type\"]])) {\r\n\t\t\t\treturn registry.registeredClasses[config[\"type\"]];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthrow Error(\"Invalid type: \\\"\" + config[\"type\"] + \"\\\".\");\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this element has a property.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param prop  Property name\r\n\t * @return Has property?\r\n\t */\r\n\tprotected hasProperty(prop: string): boolean {\r\n\t\treturn prop in this ? true : false;\r\n\t}\r\n\r\n\t/**\r\n\t * Checkes whether JSON key is a reserved keyword.\r\n\t *\r\n\t * @param key  Key\r\n\t * @return Reserved\r\n\t */\r\n\tprotected isReserved(key: string): boolean {\r\n\t\treturn [\"type\", \"forceCreate\"].indexOf(key) !== -1;\r\n\t}\r\n\r\n\t/**\r\n\t * A list of errors that happened during JSON processing.\r\n\t *\r\n\t * @return Errors\r\n\t */\r\n\tprotected get processingErrors(): string[] {\r\n\t\tif (!this._processingErrors) {\r\n\t\t\tthis._processingErrors = [];\r\n\t\t}\r\n\t\treturn this._processingErrors;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[BaseObjectEvents]].\r\n */\r\nexport interface IBaseObjectEvents { };\r\n\r\n/**\r\n * A version of [[BaseObject]] with events properties and methods.\r\n * Classes that use [[EventDispatcher]] should extend this instead of\r\n * [[BaseObject]] directly.\r\n */\r\nexport class BaseObjectEvents extends BaseObject {\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"BaseObjectEvents\";\r\n\t}\r\n\r\n\tpublic _events!: IBaseObjectEvents;\r\n\r\n\t/**\r\n\t * An [[EventDispatcher]] instance\r\n\t * @ignore\r\n\t */\r\n\tpublic _eventDispatcher: EventDispatcher<AMEvent<this, this[\"_events\"]>>;\r\n\r\n\t/**\r\n\t * An [[EventDispatcher]] instance\r\n\t */\r\n\tpublic get events(): EventDispatcher<AMEvent<this, this[\"_events\"]>> {\r\n\t\tif (!this._eventDispatcher) {\r\n\t\t\tthis._eventDispatcher = new EventDispatcher();\r\n\t\t\tthis._disposers.push(this._eventDispatcher);\r\n\t\t}\r\n\t\treturn this._eventDispatcher;\r\n\t}\r\n\r\n\t//public set events(value:EventDispatcher<AMEvent<this, this[\"_events\"]>>){\r\n\t//\tthis._eventDispatcher = value;\r\n\t//}\r\n\r\n\t/**\r\n\t * Dispatches an event using own event dispatcher. Will automatically\r\n\t * populate event data object with event type and target (this element).\r\n\t * It also checks if there are any handlers registered for this sepecific\r\n\t * event.\r\n\t *\r\n\t * @param eventType Event type (name)\r\n\t * @param data      Data to pass into event handler(s)\r\n\t */\r\n\tpublic dispatch<Key extends keyof this[\"_events\"]>(eventType: Key, data?: any): void {\r\n\t\t// @todo Implement proper type check\r\n\t\tif (this._eventDispatcher) {\r\n\t\t\tif (this.events.isEnabled(eventType)) {\r\n\t\t\t\tif (data) {\r\n\t\t\t\t\tdata.type = eventType;\r\n\t\t\t\t\tdata.target = data.target || this;\r\n\t\t\t\t\t(<any>this.events).dispatch(eventType, {\r\n\t\t\t\t\t\ttype: eventType,\r\n\t\t\t\t\t\ttarget: this\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t(<any>this.events).dispatch(eventType, {\r\n\t\t\t\t\t\ttype: eventType,\r\n\t\t\t\t\t\ttarget: this\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Works like `dispatch`, except event is triggered immediately, without\r\n\t * waiting for the next frame cycle.\r\n\t *\r\n\t * @param eventType Event type (name)\r\n\t * @param data      Data to pass into event handler(s)\r\n\t */\r\n\tpublic dispatchImmediately<Key extends keyof this[\"_events\"]>(eventType: Key, data?: any): void {\r\n\t\t// @todo Implement proper type check\r\n\t\tif (this._eventDispatcher) {\r\n\t\t\tif (this.events.isEnabled(eventType)) {\r\n\t\t\t\tif (data) {\r\n\t\t\t\t\tdata.type = eventType;\r\n\t\t\t\t\tdata.target = data.target || this;\r\n\t\t\t\t\t(<any>this.events).dispatchImmediately(eventType, data);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t(<any>this.events).dispatchImmediately(eventType, {\r\n\t\t\t\t\t\ttype: eventType,\r\n\t\t\t\t\t\ttarget: this\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all parameters from another [[Sprite]].\r\n\t *\r\n\t * @param source Source object\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tsuper.copyFrom(source);\r\n\t\tif (source._eventDispatcher) {\r\n\t\t\tthis.events.copyFrom(source._eventDispatcher);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}