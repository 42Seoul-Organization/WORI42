{"ast":null,"code":"/**\r\n * Container module\r\n * @todo Needs description\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Sprite } from \"./Sprite\";\nimport { SpriteState } from \"./SpriteState\";\nimport { List } from \"./utils/List\";\nimport { MultiDisposer } from \"./utils/Disposer\";\nimport { Dictionary, DictionaryDisposer } from \"./utils/Dictionary\";\nimport { getInteraction } from \"./interaction/Interaction\";\nimport { Rectangle } from \"./elements/Rectangle\";\nimport { Percent } from \"./utils/Percent\";\nimport { registry } from \"./Registry\";\nimport { InterfaceColorSet } from \"../core/utils/InterfaceColorSet\";\nimport * as $iter from \"./utils/Iterator\";\nimport * as $array from \"./utils/Array\";\nimport * as $math from \"./utils/Math\";\nimport * as $type from \"./utils/Type\";\nimport * as $dom from \"./utils/DOM\";\nimport { system } from \"./System\";\nimport { options } from \"./Options\";\n;\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Container can contain multiple sprites and arrange them in various layouts.\r\n *\r\n * @see {@link IContainerEvents} for a list of available events\r\n * @see {@link IContainerAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar Container =\n/** @class */\nfunction (_super) {\n  __extends(Container, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Container() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * Container children. (sorted by layout)\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n\n    _this._childrenByLayout = [];\n    /**\r\n     * Container's disposers for its child elements.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._childrenDisposers = new Dictionary();\n    /**\r\n     * Indicates if this container contains any focused elements, including\r\n     * itself.\r\n     */\n\n    _this.hasFocused = false;\n    /**\r\n     * An array of references to elements the state should be set, when it is set\r\n     * on this element.\r\n     */\n\n    _this.setStateOnSprites = [];\n    /*\r\n     * @ignore\r\n     */\n\n    _this.layoutInvalid = false;\n    _this._absoluteWidth = 0;\n    _this._absoluteHeight = 0;\n    /**\r\n     * An array of child Sprites that should be ready before this object can\r\n     * fire a \"ready\" event.\r\n     */\n\n    _this._shouldBeReady = [];\n    /**\r\n     * Enables touch tap protection.\r\n     */\n\n    _this._tapToActivate = false;\n    /**\r\n     * If `tapToActivate` is used, this setting will determine how long the chart\r\n     * will stay in \"active\" mode.\r\n     *\r\n     * @default 3000\r\n     * @since 4.4.0\r\n     */\n\n    _this.tapTimeout = 3000;\n    _this.className = \"Container\";\n    _this._element = _this.paper.addGroup(\"g\");\n\n    _this.group.add(_this.element);\n\n    _this.setPropertyValue(\"pixelPerfect\", false);\n\n    _this.setPropertyValue(\"layout\", \"absolute\");\n\n    _this.setPropertyValue(\"fixedWidthGrid\", false);\n\n    _this.setPropertyValue(\"verticalCenter\", \"none\");\n\n    _this.setPropertyValue(\"horizontalCenter\", \"none\");\n\n    _this._positionPrecision = 4;\n\n    _this._disposers.push(new DictionaryDisposer(_this._childrenDisposers));\n\n    _this.children.events.on(\"inserted\", _this.handleChildAdded, _this);\n\n    _this.children.events.on(\"removed\", _this.handleChildRemoved, _this);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Handles adding of a new child into `children`. Adding new children might\r\n   * affect the whole layout so it needs to be revalidated.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param event Event object\r\n   * @todo Throw an exception on adding a disposed object. Of course it's better NOT TO add disposed objects, so that what we should focus on.\r\n   */\n\n\n  Container.prototype.handleChildAdded = function (event) {\n    this.processChild(event.newValue);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Container.prototype.processChild = function (child) {\n    // try solves the problem when somedy adds child directly to children\n    try {\n      this._childrenDisposers.insertKey(child.uid, new MultiDisposer([// it's not enough to listen to POSITION_CHANGED only, as some extra redrawals will happen.\n      child.events.on(\"transformed\", this.handleChildTransform, this), child.events.on(\"zIndexChanged\", this.sortAndAdd, this)]));\n    } catch (err) {// void\n    }\n\n    if (this.element) {\n      var group = this.element;\n      group.add(child.group);\n    }\n\n    child.parent = this;\n    child.paper = this.paper;\n    this.dispatchImmediately(\"childadded\", {\n      type: \"childadded\",\n      newValue: child\n    });\n    this.invalidate();\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Container.prototype.sortAndAdd = function () {\n    this.sortChildren();\n    this.addChildren();\n  };\n  /**\r\n   * Handles child removal. Changing size of the child may change the\r\n   * whole layout of the Container, hence layout needs to be invalidated.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param event Event object\r\n   */\n\n\n  Container.prototype.handleChildRemoved = function (event) {\n    var child = event.oldValue; // TODO figure out why the key sometimes doesn't exist\n\n    this._childrenDisposers.removeKey(child.uid);\n\n    if (this.element) {\n      var group = this.element;\n      group.removeElement(child.group);\n    }\n\n    if (child.isMeasured) {\n      this.invalidateLayout();\n    }\n\n    this.dispatchImmediately(\"childremoved\", {\n      type: \"childremoved\",\n      oldValue: child\n    });\n  };\n  /**\r\n   * Handles child transformation. Changing size of the child may change the\r\n   * whole layout of the Container, hence layout needs to be invalidated.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param event Event object\r\n   */\n\n\n  Container.prototype.handleChildTransform = function (event) {\n    var child = event.target;\n\n    if (child.isMeasured) {\n      // && this.layout != \"none\" && this.layout != \"absolute\") {\n      this.invalidateLayout();\n    }\n  };\n  /**\r\n   * Invalidates Container's layout, causing it to be re-evaluated again.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Container.prototype.invalidateLayout = function () {\n    if (this.layoutInvalid || this.disabled || this.isTemplate || this.layout == \"none\" || this.__disabled) {\n      return;\n    }\n\n    this.layoutInvalid = true;\n    registry.addToInvalidLayouts(this);\n    system.requestFrame();\n  };\n  /**\r\n   * Invalidates element.\r\n   *\r\n   * Object will be redrawn during the next update cycle.\r\n   *\r\n   * Please note that in most cases elements will auto-invalidate when needed. If\r\n   * everything works, DO NOT use this method. Use it only if some changes do\r\n   * not take otherwise.\r\n   */\n\n\n  Container.prototype.invalidate = function () {\n    _super.prototype.invalidate.call(this);\n\n    this.invalidateLayout();\n  };\n  /**\r\n   * Invalidates the whole element, including layout AND all its child\r\n   * elements.\r\n   *\r\n   * As this will essentially force all elements to redraw, use only if\r\n   * absolutely necessary.\r\n   */\n\n\n  Container.prototype.deepInvalidate = function () {\n    _super.prototype.invalidate.call(this); //this.sortChildren();\n\n\n    $array.each(this._childrenByLayout, function (child) {\n      if (child instanceof Container) {\n        child.deepInvalidate();\n      } else {\n        child.invalidate();\n      }\n    });\n    this.invalidateLayout();\n  };\n\n  Object.defineProperty(Container.prototype, \"children\", {\n    /**\r\n     * Returns a list of the child [[Sprite]] elements contained in this\r\n     * Container.\r\n     *\r\n     * @return List of child elements (Sprites)\r\n     */\n    get: function () {\n      // @todo Review if we can add all children to disposers\n      if (!this._children) {\n        this._children = new List(); //this._disposers.push(new ListDisposer(this._children));\n      }\n\n      return this._children;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Container.prototype, \"minWidth\", {\n    /**\r\n     * @return Width (px)\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"minWidth\");\n    },\n\n    /**\r\n     * Minimum width (px) for the Container. A container will not\r\n     * auto-shrink beyond this value, even if child elements are smaller.\r\n     *\r\n     * @param value  Width (px)\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"minWidth\", value)) {\n        this.invalidateLayout();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Container.prototype, \"minHeight\", {\n    /**\r\n     * @return Height (px)\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"minHeight\");\n    },\n\n    /**\r\n     * Minimum height (px) for the Container. A container will not\r\n     * auto-shrink beyond this value, even if child elements are smaller.\r\n     *\r\n     * @param value  Height (px)\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"minHeight\", value)) {\n        this.invalidateLayout();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Overrides the original `removeElement` so that Container's actual element\r\n   * is not removed. We do not need to remove element of a Container.\r\n   *\r\n   * We do this because remove element each time will fail the `getBBox`.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Container.prototype.removeElement = function () {};\n  /**\r\n   * Sorts Container's children: the ones with variable width and height are\r\n   * put at the end of the list (depending on layout type), so that fixed-width\r\n   * ones can be drawn first.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Container.prototype.sortChildren = function () {\n    var _this = this;\n\n    this._childrenByLayout = [];\n\n    if (this.layout == \"none\" || this.layout == \"absolute\" || !this.layout) {\n      //$iter.each(this.children.iterator(), (child) => {\n      //\tthis._childrenByLayout.push(child);\n      //});\n      this._childrenByLayout = this.children.values;\n    } else {\n      // Assemble fixed-size and relative lists\n      var fixed_1 = [];\n      var relative_1 = [];\n      $iter.each(this.children.iterator(), function (child) {\n        if (_this.layout == \"horizontal\" || _this.layout == \"grid\") {\n          if (!$type.isNumber(child.percentWidth)) {\n            fixed_1.push(child);\n          } else {\n            relative_1.push(child);\n          }\n        } else if (_this.layout == \"vertical\") {\n          if (!$type.isNumber(child.percentHeight)) {\n            fixed_1.push(child);\n          } else {\n            relative_1.push(child);\n          }\n        } else {\n          fixed_1.push(child);\n        }\n      }); // Concat everything into list\n\n      this._childrenByLayout = fixed_1.concat(relative_1);\n    }\n\n    this.calculateRelativeSize();\n  };\n  /**\r\n   * Calculates relative sizes for all Container's children.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Make it protected?\r\n   */\n\n\n  Container.prototype.calculateRelativeSize = function () {\n    var _this = this;\n\n    var totalRelativeWidth = 0;\n    var totalRelativeHeight = 0;\n    $array.each(this._childrenByLayout, function (child) {\n      // if child is not measured, we do not care about it at all.\n      if (child.isMeasured) {\n        if ($type.isNumber(child.percentWidth)) {\n          totalRelativeWidth += child.percentWidth;\n        }\n\n        if ($type.isNumber(child.percentHeight)) {\n          totalRelativeHeight += child.percentHeight;\n        }\n      }\n    });\n    $array.each(this._childrenByLayout, function (child) {\n      if (child.isMeasured) {\n        if (_this.layout == \"horizontal\") {\n          if ($type.isNumber(child.percentWidth)) {\n            child.relativeWidth = child.percentWidth / totalRelativeWidth;\n          }\n\n          if ($type.isNumber(child.percentHeight)) {\n            child.relativeHeight = child.percentHeight / 100;\n          }\n        }\n\n        if (_this.layout == \"vertical\") {\n          if ($type.isNumber(child.percentHeight)) {\n            child.relativeHeight = child.percentHeight / totalRelativeHeight;\n          }\n\n          if ($type.isNumber(child.percentWidth)) {\n            child.relativeWidth = child.percentWidth / 100;\n          }\n        }\n\n        if (_this.layout == \"grid\") {\n          if ($type.isNumber(child.percentHeight)) {\n            child.relativeHeight = child.percentHeight / 100;\n          }\n\n          if ($type.isNumber(child.percentWidth)) {\n            child.relativeWidth = child.percentWidth / 100;\n          }\n        }\n      }\n\n      if (_this.layout == \"absolute\" || !child.isMeasured) {\n        if ($type.isNumber(child.percentWidth)) {\n          child.relativeWidth = child.percentWidth / 100;\n        }\n\n        if ($type.isNumber(child.percentHeight)) {\n          child.relativeHeight = child.percentHeight / 100;\n        }\n      }\n    });\n  };\n  /**\r\n   * Adds all children to Container's SVG element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Container.prototype.addChildren = function () {\n    /*\r\n      Need this check because a child might be assigned to parent even before element is created, for example a theme\r\n      access scrollbar.thumb\r\n    */\n    if (this.element) {\n      var zindexed = $array.copy(this.children.values); // not children by layout!\n\n      var sortArray = zindexed.map(function (data, idx) {\n        return {\n          idx: idx,\n          data: data\n        };\n      });\n      sortArray.sort(function (a, b) {\n        var ai = a.data.zIndex || 0;\n        var bi = b.data.zIndex || 0;\n\n        if (ai < bi) {\n          return -1;\n        }\n\n        if (ai > bi) {\n          return 1;\n        }\n\n        return a.idx - b.idx;\n      });\n      zindexed = sortArray.map(function (val) {\n        return val.data;\n      });\n      var group_1 = this.element; // check, maybe the order is good already\n\n      var isCorrect = true;\n\n      if (group_1.node && group_1.node.childNodes) {\n        for (var i = 0, len = group_1.node.childNodes.length; i < len; i++) {\n          if (group_1.node.childNodes[i] != zindexed[i].group.node) {\n            isCorrect = false;\n            break;\n          }\n        }\n      }\n\n      if (!isCorrect) {\n        $array.each(zindexed, function (child) {\n          if (child.group) {\n            group_1.add(child.group);\n          }\n        });\n\n        if (this._background) {\n          this.group.addToBack(this._background.group);\n        }\n\n        this.invalidateLayout();\n      }\n    }\n  };\n  /**\r\n   * Creates a new element of specific type and assigns as a child to the\r\n   * Container.\r\n   *\r\n   * @param Class type for the new element\r\n   * @return New element\r\n   */\n\n\n  Container.prototype.createChild = function (classType) {\n    var sprite = new classType();\n    sprite.parent = this;\n    return sprite;\n  };\n  /**\r\n   * Removes all Container's children without actually destroying them.\r\n   *\r\n   * To destroy children use `disposeChildren()` instead.\r\n   */\n\n\n  Container.prototype.removeChildren = function () {\n    // remove all children\n    // TODO use iteration instead\n    while (this.children.length > 0) {\n      var child = this.children.getIndex(0);\n      child.parent = undefined;\n      this.children.removeValue(child);\n    }\n  };\n  /**\r\n   * Removes and destroys all Container's children.\r\n   *\r\n   * To remove children from Container without destroying them, use\r\n   * `removeChildren()`.\r\n   */\n\n\n  Container.prototype.disposeChildren = function () {\n    // TODO use iteration instead\n    while (this.children.length > 0) {\n      var child = this.children.getIndex(0);\n      child.dispose();\n      this.children.removeValue(child);\n    }\n  };\n\n  Object.defineProperty(Container.prototype, \"background\", {\n    /**\r\n     * @return Background element\r\n     */\n    get: function () {\n      if (!this._background) {\n        this._background = this.createBackground();\n        this.processBackground();\n      }\n\n      return this._background;\n    },\n\n    /**\r\n     * An element to use as container background.\r\n     *\r\n     * @param background  Background element\r\n     */\n    set: function (background) {\n      if (this._background && this.background != background) {\n        this.removeDispose(this._background);\n      }\n\n      if (background) {\n        this._background = background;\n\n        this._disposers.push(background);\n\n        this.processBackground();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Handles the situation where parent element is resized.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Container.prototype.handleGlobalScale = function () {\n    _super.prototype.handleGlobalScale.call(this);\n\n    this.children.each(function (child) {\n      child.handleGlobalScale();\n    });\n  };\n  /**\r\n   * Creates and returns a [[Rectangle]] to use as a background for Container.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @return Background Rectangle element\r\n   */\n\n\n  Container.prototype.createBackground = function () {\n    return new Rectangle();\n  };\n  /**\r\n   * Decorates background element with required properties.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Container.prototype.processBackground = function () {\n    var background = this._background;\n\n    if (background) {\n      background.isMeasured = false;\n      this._background.fill = new InterfaceColorSet().getFor(\"background\");\n      background.parent = this;\n      background.isMeasured = false;\n      this.children.removeValue(background);\n\n      this._disposers.push(background);\n\n      this.group.addToBack(this._background.group);\n    }\n  };\n  /**\r\n   * Measures the size of container and informs its children of how much size\r\n   * they can occupy, by setting their relative `maxWidth` and `maxHeight`\r\n   * properties.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Container.prototype.validateLayout = function () {\n    var _this = this;\n\n    registry.removeFromInvalidLayouts(this);\n    this.layoutInvalid = false; // prevents from drawing if topparent is 0x0\n\n    /*\r\n    let topParent = this.topParent;\r\n    if (topParent) {\r\n        if (!topParent.maxWidth || !topParent.maxHeight) {\r\n            this._disposers.push(topParent.events.once(\"maxsizechanged\", this.invalidateLayout, this));\r\n        }\r\n    }*/\n\n    this._availableWidth = this.innerWidth;\n    this._availableHeight = this.innerHeight;\n    var measuredWidth = 0;\n    var measuredHeight = 0;\n    var allValid = true;\n\n    if (this.children) {\n      this.sortChildren(); // we itterate through list of children, sorted by layout priority. sprites which width non-relative width/height will go first, so we will reduce available width before proceeding to sprites with relative width/height\n\n      $array.each(this._childrenByLayout, function (child) {\n        var maxWidth;\n        var maxHeight;\n\n        if ($type.isNumber(child.relativeWidth)) {\n          maxWidth = $math.round(_this._availableWidth * child.relativeWidth, 2);\n\n          if (_this.layout == \"horizontal\") {\n            // || this.layout == \"absolute\") {\n            maxWidth -= child.pixelMarginRight + child.pixelMarginLeft;\n          }\n        } else {\n          if (_this.layout == \"horizontal\") {\n            if (child.invalid) {\n              child.validate();\n            }\n          }\n        }\n\n        if ($type.isNumber(child.relativeHeight)) {\n          maxHeight = $math.round(_this._availableHeight * child.relativeHeight, 2);\n\n          if (_this.layout == \"vertical\") {\n            //  || this.layout == \"absolute\") {\n            maxHeight -= child.pixelMarginTop + child.pixelMarginBottom;\n          }\n        } else {\n          if (_this.layout == \"vertical\") {\n            if (child.invalid) {\n              child.validate();\n            }\n          }\n        } // if child is valid\n\n\n        if (child.invalid == false) {\n          if ($type.isNumber(child.relativeWidth)) {\n            child.maxWidth = maxWidth;\n          }\n\n          if ($type.isNumber(child.relativeHeight)) {\n            child.maxHeight = maxHeight;\n          }\n\n          if (child.isMeasured) {\n            // reduce available width if this is horizontal layout\n            if (_this.layout == \"horizontal\") {\n              if (!$type.isNumber(child.percentWidth)) {\n                if (child.measuredWidth > 0) {\n                  _this._availableWidth -= child.measuredWidth + child.pixelMarginLeft + child.pixelMarginRight;\n                }\n              }\n            } // reduce available height if this is vertical layout\n\n\n            if (_this.layout == \"vertical\") {\n              if (!$type.isNumber(child.percentHeight)) {\n                if (child.measuredHeight > 0) {\n                  _this._availableHeight -= child.measuredHeight + child.pixelMarginTop + child.pixelMarginBottom;\n                }\n              }\n            }\n\n            var childMeasuredWidth = child.measuredWidth;\n            var childMeasuredHeight = child.measuredHeight;\n\n            if (child.align != \"none\") {\n              childMeasuredWidth += child.pixelMarginLeft + child.pixelMarginRight;\n            }\n\n            if (child.valign != \"none\") {\n              childMeasuredHeight += child.pixelMarginTop + child.pixelMarginBottom;\n            }\n\n            measuredWidth = Math.max(measuredWidth, childMeasuredWidth);\n            measuredHeight = Math.max(measuredHeight, childMeasuredHeight);\n          }\n        } // if child is not valid\n        else {\n            // tell child what maximum width/ height it can occupy\n            if (child.isMeasured) {\n              if ($type.isNumber(child.relativeWidth)) {\n                if (child.maxWidth != maxWidth) {\n                  // need to check this because of allValid\n                  child.maxWidth = maxWidth;\n                  allValid = false;\n                }\n              }\n\n              if ($type.isNumber(child.relativeHeight)) {\n                if (child.maxHeight != maxHeight) {\n                  // need to check this because of allValid\n                  child.maxHeight = maxHeight;\n                  allValid = false;\n                }\n              }\n            }\n          }\n      });\n    }\n\n    this._absoluteWidth = measuredWidth;\n    this._absoluteHeight = measuredHeight; // arrange after measuring, only if all children are valid already\n\n    if (allValid) {\n      this.arrange();\n    }\n  };\n  /**\r\n   * Arranges children according to layout specs and available space / child\r\n   * sizes.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Container.prototype.arrange = function () {\n    var _this = this;\n\n    var children = this.children;\n    /*\r\n       in this method we not only arrange children but also find out the size of the container\r\n       it might seem it would be easier to get container size using sprite's measure method,\r\n       however it would return only actual size of the bbox. However as each child meight have\r\n       margins set, we need to check each child - we do it here.\r\n         This method doesn't do anything with DOM, so it's not expensive\r\n    */\n\n    var measuredWidth = 0;\n    var measuredHeight = 0; //let innerWidth: number = this.innerWidth; //$math.max(this.innerWidth, this._measuredWidth - paddingLeft - paddingRight);\n    //let innerHeight: number = this.innerHeight; //$math.max(this.innerHeight, this._measuredHeight - paddingTop - paddingBottom);\n    // above is wrong, as if a w/h is not specified, it is 0 and alignment doesn't work at all.\n\n    var innerWidth = $math.max(this.innerWidth, this._absoluteWidth);\n    var innerHeight = $math.max(this.innerHeight, this._absoluteHeight);\n    var left; // = 0;\n\n    var right; // = innerWidth;\n\n    var top; // = 0;\n\n    var bottom; // = innerHeight;\n\n    var paddingLeft = this.pixelPaddingLeft;\n    var paddingRight = this.pixelPaddingRight;\n    var paddingTop = this.pixelPaddingTop;\n    var paddingBottom = this.pixelPaddingBottom;\n    var nextX = 0;\n    var nextY = 0;\n    var row = 0;\n    var column = 0;\n    var columnWidth = [];\n    var rowHeight = [];\n    var maxCellWidth;\n    var minCellWidth;\n    var columnCount;\n    var maxWidth = this.maxWidth;\n    var maxHeight = this.maxHeight;\n    var minWidth = this.minWidth;\n    var minHeight = this.minHeight;\n    var childrenCopy = $array.copy(children.values);\n\n    if (this.reverseOrder) {\n      childrenCopy.reverse();\n    } // GRID PRECALCULATIONS\n\n\n    if (this.layout == \"grid\") {\n      minCellWidth = maxWidth;\n      maxCellWidth = 1;\n\n      for (var i = 0, len = childrenCopy.length; i < len; i++) {\n        var child = childrenCopy[i];\n\n        if (child.isMeasured && !child.disabled && !child.__disabled) {\n          var childMeasuredWidth = child.measuredWidth;\n\n          if (childMeasuredWidth < minCellWidth) {\n            minCellWidth = childMeasuredWidth;\n          }\n\n          if (childMeasuredWidth > maxCellWidth) {\n            maxCellWidth = childMeasuredWidth;\n          }\n        }\n      }\n\n      minCellWidth = $math.fitToRange(minCellWidth, 1, maxWidth);\n      maxCellWidth = $math.fitToRange(maxCellWidth, 1, maxWidth);\n\n      if (this.fixedWidthGrid) {\n        columnCount = maxWidth / maxCellWidth;\n      } else {\n        columnCount = maxWidth / minCellWidth; // predicted number of columns, yes it is usually much more than real number, but we fix that later\n      }\n\n      columnCount = $math.max(1, Math.floor(columnCount));\n      columnCount = $math.min(this.maxColumns, columnCount);\n      columnWidth = this.getColumnWidth(childrenCopy, columnCount, maxCellWidth);\n    }\n\n    var contentLeft;\n    var contentRight;\n    var contentTop;\n    var contentBottom; // we itterate through array of children\n    // TODO use iterator instead\n\n    for (var i = 0, len = childrenCopy.length; i < len; i++) {\n      var child = childrenCopy[i];\n\n      if (child.isMeasured && !child.disabled && !child.__disabled) {\n        var x = undefined; //child.pixelX; // must reset\n\n        var y = undefined; //child.pixelY; // must reset\n\n        var childMarginLeft = child.pixelMarginLeft;\n        var childMarginRight = child.pixelMarginRight;\n        var childMarginTop = child.pixelMarginTop;\n        var childMarginBottom = child.pixelMarginBottom;\n        var childWidth = child.measuredWidth;\n        var childHeight = child.measuredHeight;\n        var childLeft = void 0;\n        var childRight = void 0;\n        var childTop = void 0;\n        var childBottom = void 0;\n\n        switch (this.layout) {\n          case \"none\":\n            break;\n          // absolute layout\n\n          case \"absolute\":\n            // horizontal alignment\n            switch (child.align) {\n              case \"left\":\n                x = childMarginLeft - child.maxLeft;\n                break;\n\n              case \"center\":\n                x = (innerWidth - childWidth) / 2 - child.maxLeft;\n                break;\n\n              case \"right\":\n                x = innerWidth - childMarginRight - child.maxRight;\n                break;\n\n              default:\n                if (!(child.x instanceof Percent)) {\n                  x = child.pixelX;\n                }\n\n                break;\n            } // vertical alignment\n\n\n            switch (child.valign) {\n              case \"top\":\n                y = childMarginTop - child.maxTop;\n                break;\n\n              case \"middle\":\n                y = (innerHeight - childHeight) / 2 - child.maxTop;\n                break;\n\n              case \"bottom\":\n                y = innerHeight - childMarginBottom - child.maxBottom;\n                break;\n\n              default:\n                if (!(child.y instanceof Percent)) {\n                  y = child.pixelY;\n                }\n\n                break;\n            }\n\n            break;\n          // vertical layout\n\n          case \"vertical\":\n            //if ($type.isNumber(child.relativeHeight)) {\n            //\tchildHeight = child.maxHeight;\n            //}\n            switch (child.align) {\n              case \"left\":\n                x = childMarginLeft - child.maxLeft;\n                break;\n\n              case \"center\":\n                x = (innerWidth - childWidth) / 2 - child.maxLeft;\n                break;\n\n              case \"right\":\n                x = innerWidth - childMarginRight - child.maxRight;\n                break;\n\n              default:\n                x = child.pixelX;\n                break;\n            }\n\n            y = nextY + childMarginTop - child.maxTop;\n            nextY = y + child.maxBottom + childMarginBottom;\n            break;\n          // horizontal layout\n\n          case \"horizontal\":\n            //if ($type.isNumber(child.relativeHeight)) {\n            //\tchildHeight = child.maxHeight;\n            //}\n            switch (child.valign) {\n              case \"top\":\n                y = childMarginTop - child.maxTop;\n                break;\n\n              case \"middle\":\n                y = (innerHeight - childHeight) / 2 - child.maxTop;\n                break;\n\n              case \"bottom\":\n                y = innerHeight - childMarginBottom - child.maxBottom;\n                break;\n\n              default:\n                y = child.pixelY;\n                break;\n            }\n\n            x = nextX + childMarginLeft - child.maxLeft;\n            nextX = x + child.maxRight + childMarginRight;\n            break;\n\n          case \"grid\":\n            x = nextX + childMarginLeft - child.maxLeft;\n\n            switch (child.valign) {\n              case \"top\":\n                y = nextY + childMarginTop - child.maxTop;\n                break;\n\n              case \"middle\":\n                y = nextY + (innerHeight - childHeight) / 2 - child.maxTop;\n                break;\n\n              case \"bottom\":\n                y = nextY + innerHeight - childMarginBottom - child.maxBottom;\n                break;\n\n              default:\n                y = nextY - child.maxTop;\n                break;\n            }\n\n            nextX += columnWidth[column];\n            rowHeight[row] = $math.max(rowHeight[row], childHeight);\n            column++;\n            var nextColumnWidth = columnWidth[column];\n\n            if (!$type.isNumber(nextColumnWidth)) {\n              nextColumnWidth = maxCellWidth;\n            }\n\n            if (nextX > $math.min(this.innerWidth, maxWidth) - nextColumnWidth + 1 && column < columnCount) {\n              columnCount = column;\n              nextX = 0;\n              nextY = 0;\n              row = 0;\n              column = 0;\n              columnWidth = this.getColumnWidth(childrenCopy, columnCount, maxCellWidth);\n              rowHeight = [];\n              i = -1;\n              continue;\n            }\n\n            if (column >= columnCount) {\n              column = 0;\n              nextY += rowHeight[row];\n              row++;\n              nextX = 0;\n            }\n\n            break;\n        }\n\n        if (this.layout !== \"none\") {\n          child.moveTo({\n            x: x,\n            y: y\n          }); // must use moveTo, otherwise x/y set in percent won't work\n\n          childLeft = x + child.maxLeft - childMarginLeft;\n          childRight = x + child.maxRight + childMarginRight;\n          childTop = y + child.maxTop - childMarginTop;\n          childBottom = y + child.maxBottom + childMarginBottom;\n\n          if (childRight > right || !$type.isNumber(right)) {\n            right = childRight;\n          }\n\n          if (childLeft < left || !$type.isNumber(left)) {\n            left = childLeft;\n          }\n\n          if (childTop < top || !$type.isNumber(top)) {\n            top = childTop;\n          }\n\n          if (childBottom > bottom || !$type.isNumber(bottom)) {\n            bottom = childBottom;\n          }\n\n          if (childRight > contentRight || !$type.isNumber(contentRight)) {\n            contentRight = childRight;\n          }\n\n          if (childLeft < contentLeft || !$type.isNumber(contentLeft)) {\n            contentLeft = childLeft;\n          }\n\n          if (childTop < contentTop || !$type.isNumber(contentTop)) {\n            contentTop = childTop;\n          }\n\n          if (childBottom > contentBottom || !$type.isNumber(contentBottom)) {\n            contentBottom = contentBottom;\n          }\n        }\n      } else {\n        child.validatePosition();\n      }\n    }\n\n    if (this.layout == \"none\") {\n      var noneBBox = this.bbox;\n      left = noneBBox.x;\n      right = noneBBox.x + noneBBox.width;\n      top = noneBBox.y;\n      bottom = noneBBox.y + noneBBox.height;\n    }\n\n    if (!$type.isNumber(left)) {\n      left = 0;\n      contentLeft = 0;\n    }\n\n    if (!$type.isNumber(right)) {\n      right = this._availableWidth;\n      contentRight = right;\n    }\n\n    if (!$type.isNumber(top)) {\n      top = 0;\n      contentTop = 0;\n    }\n\n    if (!$type.isNumber(bottom)) {\n      bottom = this._availableHeight;\n      contentBottom = bottom;\n    }\n\n    if (!$type.isNumber(contentTop)) {\n      contentTop = 0;\n    }\n\n    if (!$type.isNumber(contentBottom)) {\n      contentBottom = contentTop;\n    }\n\n    if (!$type.isNumber(contentLeft)) {\n      contentLeft = 0;\n    }\n\n    if (!$type.isNumber(contentRight)) {\n      contentRight = contentLeft;\n    }\n\n    measuredWidth = right - left;\n    measuredHeight = bottom - top;\n\n    if ($type.isNumber(this.relativeWidth)) {\n      measuredWidth = maxWidth - paddingLeft - paddingRight;\n      left = 0;\n      right = measuredWidth;\n    }\n\n    if ($type.isNumber(this.relativeHeight)) {\n      measuredHeight = maxHeight - paddingTop - paddingBottom;\n      top = 0;\n      bottom = measuredHeight;\n    }\n\n    if ($type.isNumber(this._pixelWidth)) {\n      left = 0;\n      measuredWidth = this._pixelWidth - paddingLeft - paddingRight;\n    }\n\n    if ($type.isNumber(minWidth) && measuredWidth < minWidth) {\n      left = 0;\n      measuredWidth = this.minWidth - paddingLeft - paddingRight;\n    }\n\n    if ($type.isNumber(this._pixelHeight)) {\n      top = 0;\n      measuredHeight = this._pixelHeight - paddingTop - paddingBottom;\n    }\n\n    if ($type.isNumber(minHeight) && measuredHeight < minHeight) {\n      top = 0;\n      measuredHeight = minHeight - paddingTop - paddingBottom;\n    }\n\n    var measuredContentWidth = contentRight - contentLeft;\n    var measuredContentHeight = contentBottom - contentTop; /// handle content alignment\n\n    if (this.layout != \"none\" && (this.contentAlign || this.contentValign) && children.length > 0) {\n      var dx_1;\n      var dy_1;\n      var mwa = measuredWidth;\n      var mha = measuredHeight;\n\n      if (mwa < measuredContentWidth) {\n        mwa = measuredContentWidth;\n      }\n\n      if (mha < measuredContentHeight) {\n        mha = measuredContentHeight;\n      }\n\n      if (this.contentAlign == \"center\") {\n        dx_1 = (mwa - measuredContentWidth) / 2;\n      }\n\n      if (this.contentAlign == \"right\") {\n        dx_1 = mwa - measuredContentWidth;\n      }\n\n      if (this.contentValign == \"middle\") {\n        dy_1 = (mha - measuredContentHeight) / 2;\n      }\n\n      if (this.contentValign == \"bottom\") {\n        dy_1 = mha - measuredContentHeight;\n      }\n\n      if ($type.isNumber(dx_1)) {\n        $iter.each(children.iterator(), function (child) {\n          var childLeft = child.maxLeft;\n          var ddx = dx_1;\n\n          if (_this.layout == \"horizontal\") {\n            child.x = child.pixelX + ddx;\n          } // individual grid elements can not be aligned vertically, that's why it's different from horizontal\n\n\n          if (_this.layout == \"grid\") {\n            child.x = child.pixelX + ddx;\n          }\n\n          if (_this.layout == \"vertical\") {\n            ddx += child.pixelMarginLeft;\n\n            if (child.align == \"none\") {\n              child.x = ddx - childLeft;\n            }\n          }\n\n          if (_this.layout == \"absolute\") {\n            ddx += child.pixelMarginLeft;\n\n            if (child.align == \"none\") {\n              child.x = ddx - childLeft;\n            }\n          }\n        });\n      }\n\n      if ($type.isNumber(dy_1)) {\n        $iter.each(children.iterator(), function (child) {\n          var childTop = child.maxTop;\n          var ddy = dy_1;\n\n          if (_this.layout == \"horizontal\") {\n            ddy += child.pixelMarginTop;\n\n            if (child.valign == \"none\") {\n              child.y = ddy - childTop;\n            }\n          } // individual grid elements can not be aligned vertically, that's why it's different from horizontal\n\n\n          if (_this.layout == \"grid\") {\n            ddy += child.pixelMarginTop;\n            child.y = ddy - childTop;\n          }\n\n          if (_this.layout == \"vertical\") {\n            child.y = child.pixelY + ddy;\n          }\n\n          if (_this.layout == \"absolute\") {\n            ddy += child.pixelMarginTop;\n\n            if (child.valign == \"none\") {\n              child.y = ddy - childTop;\n            }\n          }\n        });\n      }\n    }\n\n    var oldBBox = this.bbox; // this will mess up maxw/maxh set by container layout, we need a separate min/maxwidth for users\n    // this prevents invalidating layout in such cases as scrolling category axis, when labels go outside bounds and results transformed event\n    // todo: need to check if this doesn't cause other problems.\n    //if (this.maxWidth > 0) {\n    //measuredWidth = $math.min(measuredWidth, this.maxWidth);\n    //measuredWidth = $math.max(measuredWidth, this.minWidth);\n    //}\n    //if (this.maxHeight > 0) {\n    //measuredHeight = $math.min(measuredHeight, this.maxHeight);\n    //measuredHeight = $math.max(measuredHeight, this.minHeight);\n    //}\n\n    measuredWidth = $math.max(measuredWidth, minWidth);\n    measuredHeight = $math.max(measuredHeight, minHeight);\n    this.contentWidth = measuredWidth;\n    this.contentHeight = measuredHeight; // new\n\n    measuredWidth = $math.min(measuredWidth, maxWidth);\n    measuredHeight = $math.min(measuredHeight, maxHeight);\n    this._bbox = {\n      x: left,\n      y: top,\n      width: measuredWidth,\n      height: measuredHeight\n    };\n    var prevLeft = this.maxLeft;\n    var prevTop = this.maxTop;\n    var prevBotttom = this.maxBottom;\n    var prevRight = this.maxRight;\n    this.measure();\n\n    if (prevLeft != this.maxLeft || prevRight != this.maxRight || prevTop != this.maxTop || prevBotttom != this.maxBottom) {\n      if (this.events.isEnabled(\"transformed\")) {\n        var event_1 = {\n          type: \"transformed\",\n          target: this\n        };\n\n        if (oldBBox) {\n          event_1.dummyData = oldBBox.width + \" \" + measuredWidth + \"  \" + oldBBox.height + \" \" + measuredHeight;\n        }\n\n        this.events.dispatchImmediately(\"transformed\", event_1);\n      }\n    }\n\n    this.dispatchImmediately(\"layoutvalidated\");\n  };\n  /**\r\n   * Positions element according its center settings.\r\n   *\r\n   * @todo Description (review)\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Container.prototype.updateCenter = function () {\n    _super.prototype.updateCenter.call(this);\n\n    this.updateBackground();\n  };\n  /**\r\n   * Update the background to fit into specific dimensions.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Make it protected?\r\n   */\n\n\n  Container.prototype.updateBackground = function () {\n    var background = this._background; // accessing protected, as getter creates instance if it doesn't exist\n\n    if (background) {\n      background.x = this.maxLeft;\n      background.y = this.maxTop;\n      background.width = this.maxRight - this.maxLeft;\n      background.height = this.maxBottom - this.maxTop;\n    }\n  };\n  /**\r\n   * Returns widths of all columns in a horizontal Container layout.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param columnCount   Number of columns\r\n   * @param maxCellWidth  Maximum width of one grid cell\r\n   * @return An array of column widths\r\n   */\n\n\n  Container.prototype.getColumnWidth = function (children, columnCount, maxCellWidth) {\n    var _this = this;\n\n    var columnWidth = [];\n    var column = 0;\n    $array.each(children, function (child) {\n      if (child.isMeasured && !child.disabled && !child.__disabled) {\n        if (_this.fixedWidthGrid) {\n          columnWidth[column] = maxCellWidth;\n        } else {\n          columnWidth[column] = $math.max(columnWidth[column], child.measuredWidth + child.pixelMarginRight + child.pixelMarginLeft);\n        }\n\n        column++;\n\n        if (column == columnCount) {\n          column = 0;\n        }\n      }\n    });\n    return columnWidth;\n  };\n\n  Object.defineProperty(Container.prototype, \"layout\", {\n    /**\r\n     * @return Layout\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"layout\");\n    },\n\n    /**\r\n     * Container layout.\r\n     *\r\n     * Options: \"absolute\" (default), \"vertical\", \"horizontal\", \"grid\", \"none\". \"none\" is quite the same as \"absolute\" - the objects will\r\n     * be positioned at their x, y coordinates, the difference is that with \"absolute\" you can still use align/valign for children and with \"none\" you can not.\r\n     * Use \"none\" as much as you can as it's most cpu-saving layout.\r\n     *\r\n     * @default \"absolute\"\r\n     * @param value Layout\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"layout\", value)) {\n        this.invalidateLayout();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Container.prototype, \"contentValign\", {\n    /**\r\n     * @return Vertical alignment\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"contentValign\");\n    },\n\n    /**\r\n     * Vertical alignment of the elements for the vertical Container.\r\n     *\r\n     * This is used when Container is larger than the height of all its children.\r\n     *\r\n     * @param value vertical alignment\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"contentValign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Container.prototype, \"contentAlign\", {\n    /**\r\n     * @return Horizontal alignment\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"contentAlign\");\n    },\n\n    /**\r\n     * Horizontal alignment of the elements for the horizontal Container.\r\n     *\r\n     * This is used when Container is larger than the height of all its children.\r\n     *\r\n     * @param value  Horizontal alignment\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"contentAlign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Container.prototype, \"fixedWidthGrid\", {\n    /**\r\n     * @return Should use fixed width grid?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"fixedWidthGrid\");\n    },\n\n    /**\r\n     * Controls if the grid of the Container should use fixed width. Fixed width\r\n     * grid will divide available space to all its columns/rows equally, without\r\n     * adapting to actual child sizes or size requirements.\r\n     *\r\n     * @default false\r\n     * @param value  Should use fixed width grid?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"fixedWidthGrid\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Container.prototype, \"maxColumns\", {\n    /**\r\n     * @return Should use fixed width grid?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxColumns\");\n    },\n\n    /**\r\n     * Maximum number of columns (when using `\"grid\"` layout).\r\n     *\r\n     * @param value  Should use fixed width grid?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"maxColumns\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Container.prototype, \"reverseOrder\", {\n    /**\r\n     * @return Reverse children?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"reverseOrder\");\n    },\n\n    /**\r\n     * If set to `true`, the children of the container will be drawn in reverse\r\n     * order.\r\n     *\r\n     * @default false\r\n     * @param value  Reverse children?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"reverseOrder\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Container.prototype, \"setStateOnChildren\", {\n    /**\r\n     * @return Set state on children\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"setStateOnChildren\");\n    },\n\n    /**\r\n     * Specifies if, when state is applied on this container, the same state\r\n     * should be applied to container's children as well as `background`.\r\n     *\r\n     * @default false\r\n     * @param value  Set state on children\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"setStateOnChildren\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Checks if point is within bounds of a container.\r\n   *\r\n   * @param point  A coordinate to check\r\n   * @return `true` if it fits within container\r\n   */\n\n  Container.prototype.fitsToBounds = function (point) {\n    var x = point.x;\n    var y = point.y;\n    var deviation = 0.5; // sometimes coordinates are rounded to numbers like .999 so we add deviation here\n\n    if (x >= -deviation && x <= this.pixelWidth + deviation && y >= -deviation && y <= this.pixelHeight + deviation) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\r\n   * Copies all properties from different Container, including background\r\n   * clone.\r\n   *\r\n   * @param source  Source Container to copy from\r\n   */\n\n\n  Container.prototype.copyFrom = function (source) {\n    var _this = this;\n\n    _super.prototype.copyFrom.call(this, source);\n\n    this.layout = source.layout;\n    this.setStateOnChildren = source.setStateOnChildren;\n\n    if (source._background) {\n      this.background = source._background.clone();\n      this.background.copyFrom(source._background); // won't work without this\n    }\n\n    $iter.each(source.children.iterator(), function (child) {\n      if (child.shouldClone) {\n        var clonedChild = child.clone();\n        clonedChild.parent = _this;\n      }\n    });\n  };\n\n  Object.defineProperty(Container.prototype, \"preloader\", {\n    /**\r\n     * @return Preloader instance\r\n     */\n    get: function () {\n      var preloader = this._preloader;\n\n      if (preloader) {\n        return preloader;\n      } else if (this.parent) {\n        return this.parent.preloader;\n      }\n    },\n\n    /**\r\n     * A [[Preloader]] instance to be used when Container is busy.\r\n     *\r\n     * @param preloader  Preloader instance\r\n     */\n    set: function (preloader) {\n      if (this._preloader) {\n        this.removeDispose(this._preloader);\n      }\n\n      this._preloader = preloader;\n\n      if (preloader) {\n        preloader.parent = this.tooltipContainer;\n\n        this._disposers.push(preloader);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Sets [[Paper]] instance to use to draw elements.\r\n   * @ignore\r\n   * @param paper Paper\r\n   * @return true if paper was changed, false, if it's the same\r\n   */\n\n  Container.prototype.setPaper = function (paper) {\n    var _this = this;\n\n    var changed = _super.prototype.setPaper.call(this, paper);\n\n    if (changed) {\n      if (this._background) {\n        this._background.paper = paper;\n        this._background.topParent = this.topParent;\n      }\n\n      this.children.each(function (child) {\n        child.setPaper(paper);\n        child.topParent = _this.topParent;\n      });\n    }\n\n    return changed;\n  };\n  /**\r\n   * Removes Container from the system-wide list of invalid Containers.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Container.prototype.removeFromInvalids = function () {\n    _super.prototype.removeFromInvalids.call(this);\n\n    registry.removeFromInvalidLayouts(this);\n  };\n  /**\r\n   * Sets a [[DataItem]] to be used as data for the Container.\r\n   *\r\n   * @todo Description\r\n   * @param dataItem DataItem\r\n   */\n\n\n  Container.prototype.setDataItem = function (dataItem) {\n    // this place is potentially dangerous, as if we set datItem for some dummy container, all children dataItems will be overriden\n    // the main reason for doing this is that we need a setDataItem code to be called for each sprite, otherwise property fields won't be\n    // applied. Also, getting dataItem from parent all the time is more expensive than saving value.\n    if (this._dataItem != dataItem) {\n      $iter.each(this.children.iterator(), function (child) {\n        child.dataItem = dataItem;\n      });\n\n      if (this._background) {\n        this._background.dataItem = dataItem;\n      }\n    }\n\n    _super.prototype.setDataItem.call(this, dataItem);\n  };\n  /**\r\n   * Measures the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Container.prototype.measureElement = function () {\n    if (this.disabled || this.isTemplate || this.layout == \"none\" || this.__disabled) {// void\n    } else {\n      this.validateLayout();\n    }\n  };\n\n  Object.defineProperty(Container.prototype, \"fontFamily\", {\n    /**\r\n     * @return Font family\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"fontFamily\");\n    },\n\n    /**\r\n     * Font family to be used for the text.\r\n     *\r\n     * Parts of the text may override this setting using in-line formatting.\r\n     *\r\n     * @param value Font family value\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"fontFamily\", value, true)) {\n        this.setSVGAttribute({\n          \"font-family\": value\n        });\n        this.invalidateLabels();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Container.prototype, \"fontSize\", {\n    /**\r\n     * @return Font size\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"fontSize\");\n    },\n\n    /**\r\n     * Font size to be used for the text. The size can either be numeric, in\r\n     * pixels, or other measurements.\r\n     *\r\n     * Parts of the text may override this setting using in-line formatting.\r\n     *\r\n     * @param value Font size value\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"fontSize\", value, true)) {\n        this.setSVGAttribute({\n          \"font-size\": value\n        });\n        this.invalidateLabels();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * When fontSize of fontFamily changes we need to hard-invalidate all Labels of this container to position them properly.\r\n   */\n\n  Container.prototype.invalidateLabels = function () {\n    this.children.each(function (child) {\n      // can't import Label because of Circular dependencies\n      if (child[\"hardInvalidate\"]) {\n        child[\"hardInvalidate\"](); // this fixes firefox and viewport issue\n\n        child.events.once(\"validated\", child.handleValidate, child, false);\n      } else if (child instanceof Container) {\n        child.invalidateLabels();\n      }\n    });\n  };\n\n  Object.defineProperty(Container.prototype, \"fontWeight\", {\n    /**\r\n     * @return Font weight\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"fontWeight\");\n    },\n\n    /**\r\n     * Font weight to use for text.\r\n     *\r\n     * Parts of the text may override this setting using in-line formatting.\r\n     *\r\n     * @param value Font weight\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"fontWeight\", value);\n      this.setSVGAttribute({\n        \"font-weight\": value\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Container.prototype, \"textDecoration\", {\n    /**\r\n     * @return Decoration\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"textDecoration\");\n    },\n\n    /**\r\n     * A text decoration to use for text.\r\n     *\r\n     * Parts of the text may override this setting using in-line formatting.\r\n     *\r\n     * @param value  Decoration\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"textDecoration\", value);\n      this.setSVGAttribute({\n        \"text-decoration\": value\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Disposes (destroys) the element and all its children.\r\n   */\n\n  Container.prototype.dispose = function () {\n    if (this._background) {\n      this._background.dispose();\n    }\n\n    this._shouldBeReady = [];\n    this.disposeChildren();\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Applies a [[SpriteState]] on this element.\r\n   *\r\n   * The first parameter can either be a name of the state or a [[SpriteState]]\r\n   * instance.\r\n   *\r\n   * When run, this method will apply SVG properties defined in a\r\n   * [[SpriteState]], but only those that are relevant to this particular\r\n   * element, that is are listed in its respective `properties` array.\r\n   *\r\n   * @see {@link SpriteState}\r\n   * @param value               A state - name key or instance\r\n   * @param transitionDuration  Duration of the transition between current and new state\r\n   * @param easing              An easing function\r\n   */\n\n\n  Container.prototype.setState = function (value, transitionDuration, easing) {\n    var stateName = value;\n\n    if (value instanceof SpriteState) {\n      stateName = value.name;\n    }\n\n    if (this.setStateOnChildren) {\n      $iter.each(this.children.iterator(), function (child) {\n        child.setState(stateName, transitionDuration, easing); // not good to set it in child setState\n\n        if (stateName != \"active\") {\n          child.isActive = false;\n        }\n      });\n    }\n\n    if (this._background) {\n      this._background.setState(stateName);\n    }\n\n    if (this.setStateOnSprites.length) {\n      $array.each(this.setStateOnSprites, function (item) {\n        item.setState(stateName, transitionDuration, easing);\n      });\n    }\n\n    return _super.prototype.setState.call(this, value, transitionDuration, easing);\n  }; // otherwise isActive won't work properly with background\n\n\n  Container.prototype.setActive = function (value) {\n    _super.prototype.setActive.call(this, value);\n\n    if (this._background) {\n      this._background.isActive = value;\n    }\n  };\n  /**\r\n   * Dispatches ready event. Dispatches when all children are ready.\r\n   */\n\n\n  Container.prototype.dispatchReady = function () {\n    var _this = this;\n\n    if (!this.isReady() && !this.isDisposed()) {\n      var allReady_1 = true;\n      $iter.eachContinue(this.children.iterator(), function (sprite) {\n        if (!sprite.__disabled && !sprite.disabled && !sprite.isReady()) {\n          allReady_1 = false;\n          return false;\n        } else {\n          return true;\n        }\n      });\n      $array.eachContinue(this._shouldBeReady, function (sprite) {\n        if (!sprite.__disabled && !sprite.disabled && !sprite.isReady()) {\n          allReady_1 = false;\n          return false;\n        } else {\n          return true;\n        }\n      });\n\n      if (allReady_1) {\n        _super.prototype.dispatchReady.call(this);\n      } else {\n        registry.events.once(\"exitframe\", function () {\n          _this.dispatchReady();\n\n          system.requestFrame();\n        }, undefined, false);\n      }\n    }\n  };\n  /**\r\n   * Called during the System.update method\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Container.prototype._systemUpdate = function (skippedSprites) {\n    this.children.each(function (child) {\n      if (child.invalid) {\n        if (!child._systemCheckIfValidate()) {\n          skippedSprites.push(child);\n        } else if (child.dataItem && child.dataItem.component && child.dataItem.component.dataInvalid) {\n          skippedSprites.push(child);\n        } else {\n          child.validate();\n        }\n      }\n    });\n\n    _super.prototype._systemUpdate.call(this, skippedSprites);\n  };\n  /**\r\n   * Called during the System.validatePositions method\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Container.prototype._systemValidatePositions = function () {\n    this.children.each(function (sprite) {\n      if (sprite.positionInvalid) {\n        sprite.validatePosition();\n      }\n    });\n\n    _super.prototype._systemValidatePositions.call(this);\n  };\n  /**\r\n   * Called during the System.validateLayouts method\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Container.prototype._systemValidateLayouts = function () {\n    if (this.layoutInvalid && !this.isDisposed()) {\n      this.validateLayout();\n    }\n  };\n\n  Object.defineProperty(Container.prototype, \"tapToActivate\", {\n    /**\r\n     * @return Enable touch protection?\r\n     */\n    get: function () {\n      return this._tapToActivate;\n    },\n\n    /**\r\n     * If set to `true` the chart's regular touch functionality will be suspended\r\n     * so that the whole page it is located in remains scrollable, even when\r\n     * swiping over the chart's body.\r\n     *\r\n     * User will need to tap the chart in order to activate its regular touch\r\n     * functionality.\r\n     *\r\n     * The chart will remain \"active\" as long as user keeps interacting with the\r\n     * chart. After `tapTimeout` milliseconds the chart will return to its\r\n     * \"protected\" mode.\r\n     *\r\n     * @default false\r\n     * @since 4.4.0\r\n     * @param  value  Enable touch protection?\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/touch/} For more information.\r\n     */\n    set: function (value) {\n      if (this._tapToActivate != value) {\n        this.setTapToActivate(value);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Container.prototype.setTapToActivate = function (value) {\n    var _this = this;\n\n    this._tapToActivate = value;\n    this.interactions.isTouchProtected = value; // setEventDisposer will also remove listeners if value == false\n\n    if (value) {\n      this.interactions.setEventDisposer(\"container-tapToActivate\", value, function () {\n        return new MultiDisposer([_this.events.on(\"hit\", _this.handleTapToActivate, _this, false), _this.events.on(\"down\", _this.initTapTimeout, _this, false), _this.events.on(\"track\", _this.initTapTimeout, _this, false), //this.events.on(\"drag\", this.initTapTimeout, this, false),\n        getInteraction().body.events.on(\"down\", function (ev) {\n          if (!getInteraction().isLocalElement(ev.pointer, _this.paper.svg, _this.uid)) {\n            _this.handleTapToActivateDeactivation();\n          }\n        }, _this, false)]);\n      });\n    }\n\n    getInteraction();\n  };\n  /**\r\n   * @todo Ignore on non-touch events\r\n   */\n\n\n  Container.prototype.handleTapToActivate = function () {\n    this.interactions.isTouchProtected = false;\n    this.initTapTimeout();\n  };\n\n  Container.prototype.handleTapToActivateDeactivation = function () {\n    this.interactions.isTouchProtected = true;\n  };\n\n  Container.prototype.initTapTimeout = function () {\n    var _this = this;\n\n    if (this._tapToActivateTimeout) {\n      this._tapToActivateTimeout.dispose();\n    }\n\n    if (this.tapToActivate && !this.interactions.isTouchProtected && this.tapTimeout) {\n      this._tapToActivateTimeout = this.setTimeout(function () {\n        _this.handleTapToActivateDeactivation();\n      }, this.tapTimeout);\n    }\n  };\n  /**\r\n   * Moves the whole chart to other HTML container.\r\n   *\r\n   * `htmlElement` can either be a reference to a DOM element, or an id of\r\n   * such element.\r\n   *\r\n   * @since 4.9.24\r\n   * @param  htmlElement  Target element\r\n   */\n\n\n  Container.prototype.moveHtmlContainer = function (htmlElement) {\n    var newContainer = $dom.getElement(htmlElement);\n\n    if (newContainer) {\n      this.htmlContainer = newContainer;\n      var svgDiv = this.svgContainer;\n      svgDiv.htmlElement = newContainer;\n      svgDiv.htmlElement.appendChild(svgDiv.SVGContainer);\n      svgDiv.initSensor();\n      svgDiv.measure();\n    } else if ($type.isString(htmlElement) && htmlElement != \"\") {\n      system.log(\"html container '\" + htmlElement + \"' not found\"); //throw new Error(\"html container not found\");\n    }\n  };\n  /**\r\n   * @ignore\r\n   * @return Has license?\r\n   */\n\n\n  Container.prototype.hasLicense = function () {\n    if (options.commercialLicense) {\n      return true;\n    }\n\n    for (var i = 0; i < options.licenses.length; i++) {\n      if (options.licenses[i].match(/^CH.{5,}/i)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  return Container;\n}(Sprite);\n\nexport { Container };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Container\"] = Container;","map":{"version":3,"sources":["../../../../src/.internal/core/Container.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Container module\r\n * @todo Needs description\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Sprite, ISpriteProperties, ISpriteAdapters, ISpriteEvents, AMEvent } from \"./Sprite\";\r\nimport { SpriteState } from \"./SpriteState\";\r\nimport { Animation } from \"./utils/Animation\";\r\nimport { List, IListEvents } from \"./utils/List\";\r\nimport { VerticalAlign } from \"./defs/VerticalAlign\";\r\nimport { IDisposer, MultiDisposer } from \"./utils/Disposer\";\r\nimport { Dictionary, DictionaryDisposer } from \"./utils/Dictionary\";\r\nimport { getInteraction } from \"./interaction/Interaction\";\r\nimport { Align } from \"./defs/Align\";\r\nimport { Group } from \"./rendering/Group\";\r\nimport { Rectangle } from \"./elements/Rectangle\";\r\nimport { IPoint } from \"./defs/IPoint\";\r\nimport { Percent } from \"./utils/Percent\";\r\nimport { registry } from \"./Registry\";\r\nimport { Preloader } from \"./elements/Preloader\";\r\nimport { DataItem } from \"./DataItem\";\r\nimport { Optional } from \"./utils/Type\";\r\nimport { InterfaceColorSet } from \"../core/utils/InterfaceColorSet\";\r\nimport { Paper } from \"./rendering/Paper\";\r\nimport * as $iter from \"./utils/Iterator\";\r\nimport * as $array from \"./utils/Array\";\r\nimport * as $math from \"./utils/Math\";\r\nimport * as $type from \"./utils/Type\";\r\nimport * as $dom from \"./utils/DOM\";\r\nimport { system } from \"./System\";\r\nimport { options } from \"./Options\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines available font weights.\r\n */\r\nexport type FontWeight = \"normal\" | \"bold\" | \"bolder\" | \"lighter\" | \"100\" | \"200\" | \"300\" | \"400\" | \"500\" | \"600\" | \"700\" | \"800\" | \"900\";\r\n\r\n/**\r\n * Defines available text decorations.\r\n */\r\nexport type TextDecoration = \"none\" | \"underline\" | \"overline\" | \"line-through\" | \"blink\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n// Defined in DataItem.ts\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines available [[Container]] layout types\r\n */\r\nexport type ContainerLayout = \"absolute\" | \"vertical\" | \"horizontal\" | \"grid\" | \"none\";\r\n\r\n/**\r\n * Defines properties for [[Container]]\r\n */\r\nexport interface IContainerProperties extends ISpriteProperties {\r\n\r\n\t/**\r\n\t * Container layout.\r\n\t *\r\n\t * Options: \"absolute\" (default), \"vertical\", \"horizontal\", or \"grid\".\r\n\t *\r\n\t * @default \"absolute\"\r\n\t */\r\n\tlayout?: ContainerLayout;\r\n\r\n\t/**\r\n\t * Default font weight.\r\n\t *\r\n\t * @default \"normal\"\r\n\t */\r\n\tfontWeight?: FontWeight;\r\n\r\n\t/**\r\n\t * Font size for the text.\r\n\t */\r\n\tfontSize?: number;\r\n\r\n\t/**\r\n\t * Font family for the text.\r\n\t */\r\n\tfontFamily?: string;\r\n\r\n\t/**\r\n\t * Default font decoration.\r\n\t *\r\n\t * @default \"none\"\r\n\t */\r\n\ttextDecoration?: TextDecoration;\r\n\r\n\t/**\r\n\t * Horizontal alignment of Container's items.\r\n\t */\r\n\tcontentAlign?: Align;\r\n\r\n\t/**\r\n\t * Vertical alignment of Container's items.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tcontentValign?: VerticalAlign;\r\n\r\n\t/**\r\n\t * If set to `true`, all columns of the container with layout type \"grid\"\r\n\t * will be equally sized.\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tfixedWidthGrid?: boolean;\r\n\r\n\t/**\r\n\t * Maximum number of columns (when using `\"grid\"` layout).\r\n\t */\r\n\tmaxColumns?: number;\r\n\r\n\t/**\r\n\t * If set to `true`, the children of the container will be drawn in reverse\r\n\t * order.\r\n\t *\r\n\t * @default false\r\n\t */\r\n\treverseOrder?: boolean;\r\n\r\n\t/**\r\n\t * Specifies if, when state is applied on this container, the same state\r\n\t * should be applied to container's children as well as `background`.\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tsetStateOnChildren?: boolean\r\n}\r\n\r\n/**\r\n * Defines events for the [[Container]]\r\n */\r\nexport interface IContainerEvents extends ISpriteEvents {\r\n\r\n\t/**\r\n\t * Invoked when a child Sprite is added to Container.\r\n\t */\r\n\tchildadded: {\r\n\t\tnewValue: Sprite;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when a child Sprite is removed from\r\n\t */\r\n\tchildremoved: {\r\n\t\toldValue: Sprite;\r\n\t};\r\n\r\n\t/**\r\n\t * invoked when layout of the container is validated\r\n\t */\r\n\tlayoutvalidated:{ }\r\n\r\n};\r\n\r\n/**\r\n * Defines adapters\r\n * Includes both the [[Adapter]] definitions and properties\r\n * @see {@link Adapter}\r\n */\r\nexport interface IContainerAdapters extends ISpriteAdapters, IContainerProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Container can contain multiple sprites and arrange them in various layouts.\r\n *\r\n * @see {@link IContainerEvents} for a list of available events\r\n * @see {@link IContainerAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class Container extends Sprite {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IContainerProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IContainerAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IContainerEvents;\r\n\r\n\t/**\r\n\t * Container children. (sorted by layout)\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected _childrenByLayout: Sprite[] = [];\r\n\r\n\t/**\r\n\t * Available width (px).\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected _availableWidth: $type.Optional<number>;\r\n\r\n\t/**\r\n\t * Available height (px).\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected _availableHeight: $type.Optional<number>;\r\n\r\n\t/**\r\n\t * Container's child elements. (sorded by their `zIndex`)\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected _children: $type.Optional<List<Sprite>>;\r\n\r\n\t/**\r\n\t * Container's disposers for its child elements.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected _childrenDisposers: Dictionary<string, IDisposer> = new Dictionary();\r\n\r\n\r\n\t/**\r\n\t * A [[Sprite]] instance to use as Container's background.\r\n\t *\r\n\t * @todo Make it protected\r\n\t */\r\n\tpublic _background: Sprite;\r\n\r\n\t/**\r\n\t * A reference to a [[Preloader]] element to show when Container is building\r\n\t * itself.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected _preloader: $type.Optional<Preloader>;\r\n\r\n\t/**\r\n\t * Indicates if this container contains any focused elements, including\r\n\t * itself.\r\n\t */\r\n\tpublic hasFocused: boolean = false;\r\n\r\n\t/**\r\n\t * A reference to a currently focused item.\r\n\t *\r\n\t * @since 4.9.29\r\n\t */\r\n\tpublic focusedElement: $type.Optional<Sprite>;\r\n\r\n\t/**\r\n\t * An array of references to elements the state should be set, when it is set\r\n\t * on this element.\r\n\t */\r\n\tpublic setStateOnSprites: Sprite[] = [];\r\n\r\n\t/*\r\n\t * @ignore\r\n\t */\r\n\tpublic layoutInvalid: boolean = false;\r\n\r\n\tprotected _absoluteWidth: number = 0;\r\n\r\n\tprotected _absoluteHeight: number = 0;\r\n\r\n\t/**\r\n\t * Width (in pixels) of the actual content in the Container.\r\n\t *\r\n\t * Please note that it might be bigger than width of the Container.\r\n\t *\r\n\t * @readonly\r\n\t */\r\n\tpublic contentWidth: number;\r\n\r\n\t/**\r\n\t * Height (in pixels) of the actual content in the Container.\r\n\t *\r\n\t * Please note that it might be bigger than height of the Container.\r\n\t *\r\n\t * @readonly\r\n\t */\r\n\tpublic contentHeight: number;\r\n\r\n\r\n\t/**\r\n\t * An array of child Sprites that should be ready before this object can\r\n\t * fire a \"ready\" event.\r\n\t */\r\n\tprotected _shouldBeReady: Sprite[] = [];\r\n\r\n\t/**\r\n\t * Enables touch tap protection.\r\n\t */\r\n\tprotected _tapToActivate: boolean = false;\r\n\r\n\t/**\r\n\t * Timeout reference for `tapToActivate` functionality.\r\n\t */\r\n\tprotected _tapToActivateTimeout: Optional<IDisposer>;\r\n\r\n\t/**\r\n\t * If `tapToActivate` is used, this setting will determine how long the chart\r\n\t * will stay in \"active\" mode.\r\n\t *\r\n\t * @default 3000\r\n\t * @since 4.4.0\r\n\t */\r\n\tpublic tapTimeout: number = 3000;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"Container\";\r\n\r\n\t\tthis._element = this.paper.addGroup(\"g\");\r\n\t\tthis.group.add(this.element);\r\n\r\n\t\tthis.setPropertyValue(\"pixelPerfect\", false);\r\n\t\tthis.setPropertyValue(\"layout\", \"absolute\");\r\n\t\tthis.setPropertyValue(\"fixedWidthGrid\", false);\r\n\r\n\t\tthis.setPropertyValue(\"verticalCenter\", \"none\");\r\n\t\tthis.setPropertyValue(\"horizontalCenter\", \"none\");\r\n\r\n\t\tthis._positionPrecision = 4;\r\n\r\n\t\tthis._disposers.push(new DictionaryDisposer(this._childrenDisposers));\r\n\r\n\t\tthis.children.events.on(\"inserted\", this.handleChildAdded, this);\r\n\t\tthis.children.events.on(\"removed\", this.handleChildRemoved, this);\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Handles adding of a new child into `children`. Adding new children might\r\n\t * affect the whole layout so it needs to be revalidated.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param event Event object\r\n\t * @todo Throw an exception on adding a disposed object. Of course it's better NOT TO add disposed objects, so that what we should focus on.\r\n\t */\r\n\tpublic handleChildAdded(event: IListEvents<Sprite>[\"inserted\"]): void {\r\n\t\tthis.processChild(event.newValue);\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic processChild(child: Sprite) {\r\n\t\t// try solves the problem when somedy adds child directly to children\r\n\t\ttry {\r\n\t\t\tthis._childrenDisposers.insertKey(child.uid, new MultiDisposer([\r\n\t\t\t\t// it's not enough to listen to POSITION_CHANGED only, as some extra redrawals will happen.\r\n\t\t\t\tchild.events.on(\"transformed\", this.handleChildTransform, this),\r\n\t\t\t\tchild.events.on(\"zIndexChanged\", this.sortAndAdd, this)\r\n\t\t\t]));\r\n\t\t}\r\n\t\tcatch (err) {\r\n\t\t\t// void\r\n\t\t}\r\n\r\n\t\tif (this.element) {\r\n\t\t\tlet group = <Group>this.element;\r\n\t\t\tgroup.add(child.group);\r\n\t\t}\r\n\r\n\t\tchild.parent = this;\r\n\t\tchild.paper = this.paper;\r\n\r\n\t\tthis.dispatchImmediately(\"childadded\", { type: \"childadded\", newValue: child });\r\n\r\n\t\tthis.invalidate();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected sortAndAdd() {\r\n\t\tthis.sortChildren();\r\n\t\tthis.addChildren();\r\n\t}\r\n\r\n\t/**\r\n\t * Handles child removal. Changing size of the child may change the\r\n\t * whole layout of the Container, hence layout needs to be invalidated.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param event Event object\r\n\t */\r\n\tpublic handleChildRemoved(event: IListEvents<Sprite>[\"removed\"]): void {\r\n\t\tlet child: Sprite = event.oldValue;\r\n\r\n\t\t// TODO figure out why the key sometimes doesn't exist\r\n\t\tthis._childrenDisposers.removeKey(child.uid);\r\n\r\n\t\tif (this.element) {\r\n\t\t\tlet group = <Group>this.element;\r\n\t\t\tgroup.removeElement(child.group);\r\n\t\t}\r\n\r\n\t\tif (child.isMeasured) {\r\n\t\t\tthis.invalidateLayout();\r\n\t\t}\r\n\r\n\t\tthis.dispatchImmediately(\"childremoved\", { type: \"childremoved\", oldValue: child });\r\n\t}\r\n\r\n\t/**\r\n\t * Handles child transformation. Changing size of the child may change the\r\n\t * whole layout of the Container, hence layout needs to be invalidated.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param event Event object\r\n\t */\r\n\tpublic handleChildTransform(event: AMEvent<Sprite, ISpriteEvents>[\"transformed\"] | AMEvent<Sprite, ISpriteEvents>[\"sizechanged\"]): void {\r\n\t\tlet child: Sprite = event.target;\r\n\t\tif (child.isMeasured) {// && this.layout != \"none\" && this.layout != \"absolute\") {\r\n\t\t\tthis.invalidateLayout();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Invalidates Container's layout, causing it to be re-evaluated again.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidateLayout(): void {\r\n\t\tif (this.layoutInvalid || this.disabled || this.isTemplate || this.layout == \"none\" || this.__disabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.layoutInvalid = true;\r\n\t\tregistry.addToInvalidLayouts(this);\r\n\t\tsystem.requestFrame();\r\n\t}\r\n\r\n\t/**\r\n\t * Invalidates element.\r\n\t *\r\n\t * Object will be redrawn during the next update cycle.\r\n\t *\r\n\t * Please note that in most cases elements will auto-invalidate when needed. If\r\n\t * everything works, DO NOT use this method. Use it only if some changes do\r\n\t * not take otherwise.\r\n\t */\r\n\tpublic invalidate(): void {\r\n\t\tsuper.invalidate();\r\n\t\tthis.invalidateLayout();\r\n\t}\r\n\r\n\t/**\r\n\t * Invalidates the whole element, including layout AND all its child\r\n\t * elements.\r\n\t *\r\n\t * As this will essentially force all elements to redraw, use only if\r\n\t * absolutely necessary.\r\n\t */\r\n\tpublic deepInvalidate(): void {\r\n\t\tsuper.invalidate();\r\n\t\t//this.sortChildren();\r\n\r\n\t\t$array.each(this._childrenByLayout, (child) => {\r\n\t\t\tif (child instanceof Container) {\r\n\t\t\t\tchild.deepInvalidate();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tchild.invalidate();\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.invalidateLayout();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a list of the child [[Sprite]] elements contained in this\r\n\t * Container.\r\n\t *\r\n\t * @return List of child elements (Sprites)\r\n\t */\r\n\tpublic get children(): List<Sprite> {\r\n\t\t// @todo Review if we can add all children to disposers\r\n\t\tif (!this._children) {\r\n\t\t\tthis._children = new List<Sprite>();\r\n\t\t\t//this._disposers.push(new ListDisposer(this._children));\r\n\t\t}\r\n\t\treturn this._children;\r\n\t}\r\n\r\n\t/**\r\n\t * Minimum width (px) for the Container. A container will not\r\n\t * auto-shrink beyond this value, even if child elements are smaller.\r\n\t *\r\n\t * @param value  Width (px)\r\n\t */\r\n\tpublic set minWidth(value: Optional<number>) {\r\n\t\tif (this.setPropertyValue(\"minWidth\", value)) {\r\n\t\t\tthis.invalidateLayout();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Width (px)\r\n\t */\r\n\tpublic get minWidth(): Optional<number> {\r\n\t\treturn this.getPropertyValue(\"minWidth\");\r\n\t}\r\n\r\n\t/**\r\n\t * Minimum height (px) for the Container. A container will not\r\n\t * auto-shrink beyond this value, even if child elements are smaller.\r\n\t *\r\n\t * @param value  Height (px)\r\n\t */\r\n\tpublic set minHeight(value: Optional<number>) {\r\n\t\tif (this.setPropertyValue(\"minHeight\", value)) {\r\n\t\t\tthis.invalidateLayout();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Height (px)\r\n\t */\r\n\tpublic get minHeight(): Optional<number> {\r\n\t\treturn this.getPropertyValue(\"minHeight\");\r\n\t}\r\n\r\n\t/**\r\n\t * Overrides the original `removeElement` so that Container's actual element\r\n\t * is not removed. We do not need to remove element of a Container.\r\n\t *\r\n\t * We do this because remove element each time will fail the `getBBox`.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected removeElement(): void {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sorts Container's children: the ones with variable width and height are\r\n\t * put at the end of the list (depending on layout type), so that fixed-width\r\n\t * ones can be drawn first.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic sortChildren(): void {\r\n\r\n\t\tthis._childrenByLayout = [];\r\n\r\n\t\tif (this.layout == \"none\" || this.layout == \"absolute\" || !this.layout) {\r\n\t\t\t//$iter.each(this.children.iterator(), (child) => {\r\n\t\t\t//\tthis._childrenByLayout.push(child);\r\n\t\t\t//});\r\n\t\t\tthis._childrenByLayout = this.children.values;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Assemble fixed-size and relative lists\r\n\t\t\tlet fixed: Sprite[] = [];\r\n\t\t\tlet relative: Sprite[] = [];\r\n\r\n\t\t\t$iter.each(this.children.iterator(), (child) => {\r\n\t\t\t\tif (this.layout == \"horizontal\" || this.layout == \"grid\") {\r\n\t\t\t\t\tif (!$type.isNumber(child.percentWidth)) {\r\n\t\t\t\t\t\tfixed.push(child);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\trelative.push(child);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.layout == \"vertical\") {\r\n\t\t\t\t\tif (!$type.isNumber(child.percentHeight)) {\r\n\t\t\t\t\t\tfixed.push(child);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\trelative.push(child);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfixed.push(child);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// Concat everything into list\r\n\t\t\tthis._childrenByLayout = fixed.concat(relative);\r\n\t\t}\r\n\r\n\t\tthis.calculateRelativeSize();\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates relative sizes for all Container's children.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Make it protected?\r\n\t */\r\n\tpublic calculateRelativeSize(): void {\r\n\t\tlet totalRelativeWidth: number = 0;\r\n\t\tlet totalRelativeHeight: number = 0;\r\n\r\n\t\t$array.each(this._childrenByLayout, (child) => {\r\n\t\t\t// if child is not measured, we do not care about it at all.\r\n\t\t\tif (child.isMeasured) {\r\n\t\t\t\tif ($type.isNumber(child.percentWidth)) {\r\n\t\t\t\t\ttotalRelativeWidth += child.percentWidth;\r\n\t\t\t\t}\r\n\t\t\t\tif ($type.isNumber(child.percentHeight)) {\r\n\t\t\t\t\ttotalRelativeHeight += child.percentHeight;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t$array.each(this._childrenByLayout, (child) => {\r\n\t\t\tif (child.isMeasured) {\r\n\t\t\t\tif (this.layout == \"horizontal\") {\r\n\t\t\t\t\tif ($type.isNumber(child.percentWidth)) {\r\n\t\t\t\t\t\tchild.relativeWidth = child.percentWidth / totalRelativeWidth;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ($type.isNumber(child.percentHeight)) {\r\n\t\t\t\t\t\tchild.relativeHeight = child.percentHeight / 100;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (this.layout == \"vertical\") {\r\n\t\t\t\t\tif ($type.isNumber(child.percentHeight)) {\r\n\t\t\t\t\t\tchild.relativeHeight = child.percentHeight / totalRelativeHeight;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ($type.isNumber(child.percentWidth)) {\r\n\t\t\t\t\t\tchild.relativeWidth = child.percentWidth / 100;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.layout == \"grid\") {\r\n\t\t\t\t\tif ($type.isNumber(child.percentHeight)) {\r\n\t\t\t\t\t\tchild.relativeHeight = child.percentHeight / 100;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ($type.isNumber(child.percentWidth)) {\r\n\t\t\t\t\t\tchild.relativeWidth = child.percentWidth / 100;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.layout == \"absolute\" || !child.isMeasured) {\r\n\t\t\t\tif ($type.isNumber(child.percentWidth)) {\r\n\t\t\t\t\tchild.relativeWidth = child.percentWidth / 100;\r\n\t\t\t\t}\r\n\t\t\t\tif ($type.isNumber(child.percentHeight)) {\r\n\t\t\t\t\tchild.relativeHeight = child.percentHeight / 100;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Adds all children to Container's SVG element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected addChildren(): void {\r\n\t\t/*\r\n\t\t  Need this check because a child might be assigned to parent even before element is created, for example a theme\r\n\t\t  access scrollbar.thumb\r\n\t\t*/\r\n\t\tif (this.element) {\r\n\t\t\tlet zindexed = $array.copy(this.children.values); // not children by layout!\r\n\r\n\t\t\tlet sortArray = zindexed.map(function(data, idx) {\r\n\t\t\t\treturn { idx: idx, data: data }\r\n\t\t\t});\r\n\r\n\t\t\tsortArray.sort(function(a: any, b: any) {\r\n\t\t\t\tconst ai = (a.data.zIndex || 0);\r\n\t\t\t\tconst bi = (b.data.zIndex || 0);\r\n\t\t\t\tif (ai < bi) { return -1; }\r\n\t\t\t\tif (ai > bi) { return 1; }\r\n\t\t\t\treturn a.idx - b.idx\r\n\t\t\t});\r\n\r\n\t\t\tzindexed = sortArray.map(function(val) {\r\n\t\t\t\treturn val.data;\r\n\t\t\t});\r\n\r\n\t\t\tlet group = <Group>this.element;\r\n\r\n\t\t\t// check, maybe the order is good already\r\n\t\t\tlet isCorrect = true;\r\n\r\n\t\t\tif (group.node && group.node.childNodes) {\r\n\t\t\t\tfor (let i = 0, len = group.node.childNodes.length; i < len; i++) {\r\n\t\t\t\t\tif (group.node.childNodes[i] != zindexed[i].group.node) {\r\n\t\t\t\t\t\tisCorrect = false;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!isCorrect) {\r\n\t\t\t\t$array.each(zindexed, (child) => {\r\n\t\t\t\t\tif (child.group) {\r\n\t\t\t\t\t\tgroup.add(child.group);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\r\n\t\t\t\tif (this._background) {\r\n\t\t\t\t\tthis.group.addToBack(this._background.group);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.invalidateLayout();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new element of specific type and assigns as a child to the\r\n\t * Container.\r\n\t *\r\n\t * @param Class type for the new element\r\n\t * @return New element\r\n\t */\r\n\tpublic createChild<T extends Sprite>(classType: { new(): T; }): T {\r\n\t\tlet sprite = new classType();\r\n\t\tsprite.parent = this;\r\n\t\treturn sprite;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes all Container's children without actually destroying them.\r\n\t *\r\n\t * To destroy children use `disposeChildren()` instead.\r\n\t */\r\n\tpublic removeChildren(): void {\r\n\t\t// remove all children\r\n\t\t// TODO use iteration instead\r\n\t\twhile (this.children.length > 0) {\r\n\t\t\tlet child = <Sprite>this.children.getIndex(0);\r\n\t\t\tchild.parent = undefined;\r\n\t\t\tthis.children.removeValue(child);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Removes and destroys all Container's children.\r\n\t *\r\n\t * To remove children from Container without destroying them, use\r\n\t * `removeChildren()`.\r\n\t */\r\n\tpublic disposeChildren(): void {\r\n\t\t// TODO use iteration instead\r\n\t\twhile (this.children.length > 0) {\r\n\t\t\tlet child = <Sprite>this.children.getIndex(0);\r\n\t\t\tchild.dispose();\r\n\t\t\tthis.children.removeValue(child);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * An element to use as container background.\r\n\t *\r\n\t * @param background  Background element\r\n\t */\r\n\tpublic set background(background: this[\"_background\"]) {\r\n\t\tif (this._background && this.background != background) {\r\n\t\t\tthis.removeDispose(this._background);\r\n\t\t}\r\n\r\n\t\tif (background) {\r\n\t\t\tthis._background = background;\r\n\t\t\tthis._disposers.push(background);\r\n\t\t\tthis.processBackground();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Handles the situation where parent element is resized.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic handleGlobalScale(): void {\r\n\t\tsuper.handleGlobalScale();\r\n\t\tthis.children.each((child) => {\r\n\t\t\tchild.handleGlobalScale();\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * Creates and returns a [[Rectangle]] to use as a background for Container.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Background Rectangle element\r\n\t */\r\n\tpublic createBackground(): this[\"_background\"] {\r\n\t\treturn <any>new Rectangle();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Background element\r\n\t */\r\n\tpublic get background(): this[\"_background\"] {\r\n\t\tif (!this._background) {\r\n\t\t\tthis._background = this.createBackground();\r\n\t\t\tthis.processBackground();\r\n\t\t}\r\n\r\n\t\treturn this._background;\r\n\t}\r\n\r\n\t/**\r\n\t * Decorates background element with required properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic processBackground(): void {\r\n\t\tlet background = this._background;\r\n\t\tif (background) {\r\n\t\t\tbackground.isMeasured = false;\r\n\t\t\tthis._background.fill = new InterfaceColorSet().getFor(\"background\");\r\n\t\t\tbackground.parent = this;\r\n\t\t\tbackground.isMeasured = false;\r\n\t\t\tthis.children.removeValue(background);\r\n\t\t\tthis._disposers.push(background);\r\n\t\t\tthis.group.addToBack(this._background.group);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Measures the size of container and informs its children of how much size\r\n\t * they can occupy, by setting their relative `maxWidth` and `maxHeight`\r\n\t * properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateLayout(): void {\r\n\r\n\t\tregistry.removeFromInvalidLayouts(this);\r\n\r\n\t\tthis.layoutInvalid = false;\r\n\r\n\t\t// prevents from drawing if topparent is 0x0\r\n\t\t/*\r\n\t\tlet topParent = this.topParent;\r\n\t\tif (topParent) {\r\n\t\t\tif (!topParent.maxWidth || !topParent.maxHeight) {\r\n\t\t\t\tthis._disposers.push(topParent.events.once(\"maxsizechanged\", this.invalidateLayout, this));\r\n\t\t\t}\r\n\t\t}*/\r\n\r\n\t\tthis._availableWidth = this.innerWidth;\r\n\t\tthis._availableHeight = this.innerHeight;\r\n\r\n\t\tlet measuredWidth = 0;\r\n\t\tlet measuredHeight = 0;\r\n\r\n\t\tlet allValid = true;\r\n\r\n\t\tif (this.children) {\r\n\r\n\t\t\tthis.sortChildren();\r\n\r\n\t\t\t// we itterate through list of children, sorted by layout priority. sprites which width non-relative width/height will go first, so we will reduce available width before proceeding to sprites with relative width/height\r\n\t\t\t$array.each(this._childrenByLayout, (child) => {\r\n\t\t\t\tlet maxWidth: number;\r\n\t\t\t\tlet maxHeight: number;\r\n\r\n\t\t\t\tif ($type.isNumber(child.relativeWidth)) {\r\n\t\t\t\t\tmaxWidth = $math.round(this._availableWidth * child.relativeWidth, 2);\r\n\t\t\t\t\tif (this.layout == \"horizontal\") {// || this.layout == \"absolute\") {\r\n\t\t\t\t\t\tmaxWidth -= child.pixelMarginRight + child.pixelMarginLeft;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (this.layout == \"horizontal\") {\r\n\t\t\t\t\t\tif (child.invalid) {\r\n\t\t\t\t\t\t\tchild.validate();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ($type.isNumber(child.relativeHeight)) {\r\n\t\t\t\t\tmaxHeight = $math.round(this._availableHeight * child.relativeHeight, 2);\r\n\t\t\t\t\tif (this.layout == \"vertical\") {//  || this.layout == \"absolute\") {\r\n\t\t\t\t\t\tmaxHeight -= child.pixelMarginTop + child.pixelMarginBottom;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (this.layout == \"vertical\") {\r\n\t\t\t\t\t\tif (child.invalid) {\r\n\t\t\t\t\t\t\tchild.validate();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if child is valid\r\n\t\t\t\tif (child.invalid == false) {\r\n\r\n\t\t\t\t\tif ($type.isNumber(child.relativeWidth)) {\r\n\t\t\t\t\t\tchild.maxWidth = maxWidth;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ($type.isNumber(child.relativeHeight)) {\r\n\t\t\t\t\t\tchild.maxHeight = maxHeight;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (child.isMeasured) {\r\n\t\t\t\t\t\t// reduce available width if this is horizontal layout\r\n\t\t\t\t\t\tif (this.layout == \"horizontal\") {\r\n\t\t\t\t\t\t\tif (!$type.isNumber(child.percentWidth)) {\r\n\t\t\t\t\t\t\t\tif (child.measuredWidth > 0) {\r\n\t\t\t\t\t\t\t\t\tthis._availableWidth -= child.measuredWidth + child.pixelMarginLeft + child.pixelMarginRight;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// reduce available height if this is vertical layout\r\n\t\t\t\t\t\tif (this.layout == \"vertical\") {\r\n\t\t\t\t\t\t\tif (!$type.isNumber(child.percentHeight)) {\r\n\t\t\t\t\t\t\t\tif (child.measuredHeight > 0) {\r\n\t\t\t\t\t\t\t\t\tthis._availableHeight -= child.measuredHeight + child.pixelMarginTop + child.pixelMarginBottom;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet childMeasuredWidth = child.measuredWidth;\r\n\t\t\t\t\t\tlet childMeasuredHeight = child.measuredHeight;\r\n\r\n\t\t\t\t\t\tif (child.align != \"none\") {\r\n\t\t\t\t\t\t\tchildMeasuredWidth += child.pixelMarginLeft + child.pixelMarginRight;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (child.valign != \"none\") {\r\n\t\t\t\t\t\t\tchildMeasuredHeight += child.pixelMarginTop + child.pixelMarginBottom;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmeasuredWidth = Math.max(measuredWidth, childMeasuredWidth);\r\n\t\t\t\t\t\tmeasuredHeight = Math.max(measuredHeight, childMeasuredHeight);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// if child is not valid\r\n\t\t\t\telse {\r\n\t\t\t\t\t// tell child what maximum width/ height it can occupy\r\n\t\t\t\t\tif (child.isMeasured) {\r\n\t\t\t\t\t\tif ($type.isNumber(child.relativeWidth)) {\r\n\t\t\t\t\t\t\tif (child.maxWidth != maxWidth) { // need to check this because of allValid\r\n\t\t\t\t\t\t\t\tchild.maxWidth = maxWidth;\r\n\t\t\t\t\t\t\t\tallValid = false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ($type.isNumber(child.relativeHeight)) {\r\n\t\t\t\t\t\t\tif (child.maxHeight != maxHeight) { // need to check this because of allValid\r\n\t\t\t\t\t\t\t\tchild.maxHeight = maxHeight;\r\n\r\n\t\t\t\t\t\t\t\tallValid = false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis._absoluteWidth = measuredWidth;\r\n\t\tthis._absoluteHeight = measuredHeight;\r\n\r\n\t\t// arrange after measuring, only if all children are valid already\r\n\t\tif (allValid) {\r\n\t\t\tthis.arrange();\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Arranges children according to layout specs and available space / child\r\n\t * sizes.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic arrange(): void {\r\n\t\tlet children = this.children;\r\n\t\t/*\r\n\t\t   in this method we not only arrange children but also find out the size of the container\r\n\t\t   it might seem it would be easier to get container size using sprite's measure method,\r\n\t\t   however it would return only actual size of the bbox. However as each child meight have\r\n\t\t   margins set, we need to check each child - we do it here.\r\n\r\n\t\t   This method doesn't do anything with DOM, so it's not expensive\r\n\t\t*/\r\n\t\tlet measuredWidth: number = 0;\r\n\t\tlet measuredHeight: number = 0;\r\n\r\n\t\t//let innerWidth: number = this.innerWidth; //$math.max(this.innerWidth, this._measuredWidth - paddingLeft - paddingRight);\r\n\t\t//let innerHeight: number = this.innerHeight; //$math.max(this.innerHeight, this._measuredHeight - paddingTop - paddingBottom);\r\n\t\t// above is wrong, as if a w/h is not specified, it is 0 and alignment doesn't work at all.\r\n\t\tlet innerWidth: number = $math.max(this.innerWidth, this._absoluteWidth);\r\n\t\tlet innerHeight: number = $math.max(this.innerHeight, this._absoluteHeight);\r\n\r\n\t\tlet left: $type.Optional<number>;// = 0;\r\n\t\tlet right: $type.Optional<number>;// = innerWidth;\r\n\t\tlet top: $type.Optional<number>;// = 0;\r\n\t\tlet bottom: $type.Optional<number>;// = innerHeight;\r\n\r\n\t\tlet paddingLeft: number = this.pixelPaddingLeft;\r\n\t\tlet paddingRight: number = this.pixelPaddingRight;\r\n\t\tlet paddingTop: number = this.pixelPaddingTop;\r\n\t\tlet paddingBottom: number = this.pixelPaddingBottom;\r\n\r\n\t\tlet nextX: number = 0;\r\n\t\tlet nextY: number = 0;\r\n\t\tlet row: number = 0;\r\n\t\tlet column: number = 0;\r\n\r\n\t\tlet columnWidth: number[] = [];\r\n\t\tlet rowHeight: number[] = [];\r\n\r\n\t\tlet maxCellWidth: $type.Optional<number>;\r\n\t\tlet minCellWidth: $type.Optional<number>;\r\n\t\tlet columnCount: $type.Optional<number>;\r\n\r\n\t\tlet maxWidth = this.maxWidth;\r\n\t\tlet maxHeight = this.maxHeight;\r\n\t\tlet minWidth = this.minWidth;\r\n\t\tlet minHeight = this.minHeight;\r\n\r\n\t\tlet childrenCopy = $array.copy(children.values);\r\n\t\tif (this.reverseOrder) {\r\n\t\t\tchildrenCopy.reverse();\r\n\t\t}\r\n\r\n\t\t// GRID PRECALCULATIONS\r\n\t\tif (this.layout == \"grid\") {\r\n\r\n\t\t\tminCellWidth = maxWidth;\r\n\t\t\tmaxCellWidth = 1;\r\n\r\n\t\t\tfor (let i = 0, len = childrenCopy.length; i < len; i++) {\r\n\t\t\t\tlet child = childrenCopy[i];\r\n\t\t\t\tif (child.isMeasured && !child.disabled && !child.__disabled) {\r\n\t\t\t\t\tlet childMeasuredWidth = child.measuredWidth;\r\n\t\t\t\t\tif (childMeasuredWidth < minCellWidth) {\r\n\t\t\t\t\t\tminCellWidth = childMeasuredWidth;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (childMeasuredWidth > maxCellWidth) {\r\n\t\t\t\t\t\tmaxCellWidth = childMeasuredWidth;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tminCellWidth = $math.fitToRange(minCellWidth, 1, maxWidth);\r\n\t\t\tmaxCellWidth = $math.fitToRange(maxCellWidth, 1, maxWidth);\r\n\r\n\r\n\t\t\tif (this.fixedWidthGrid) {\r\n\t\t\t\tcolumnCount = maxWidth / maxCellWidth;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tcolumnCount = maxWidth / minCellWidth; // predicted number of columns, yes it is usually much more than real number, but we fix that later\r\n\t\t\t}\r\n\r\n\t\t\tcolumnCount = $math.max(1, Math.floor(columnCount));\r\n\t\t\tcolumnCount = $math.min(this.maxColumns, columnCount);\r\n\t\t\tcolumnWidth = this.getColumnWidth(childrenCopy, columnCount, maxCellWidth);\r\n\t\t}\r\n\r\n\t\tlet contentLeft: $type.Optional<number>;\r\n\t\tlet contentRight: $type.Optional<number>;\r\n\t\tlet contentTop: $type.Optional<number>;\r\n\t\tlet contentBottom: $type.Optional<number>;\r\n\r\n\t\t// we itterate through array of children\r\n\t\t// TODO use iterator instead\r\n\r\n\r\n\r\n\t\tfor (let i = 0, len = childrenCopy.length; i < len; i++) {\r\n\t\t\tlet child = childrenCopy[i];\r\n\r\n\t\t\tif (child.isMeasured && !child.disabled && !child.__disabled) {\r\n\r\n\t\t\t\tlet x: $type.Optional<number> = undefined;//child.pixelX; // must reset\r\n\t\t\t\tlet y: $type.Optional<number> = undefined;//child.pixelY; // must reset\r\n\r\n\t\t\t\tlet childMarginLeft: number = child.pixelMarginLeft;\r\n\t\t\t\tlet childMarginRight: number = child.pixelMarginRight;\r\n\t\t\t\tlet childMarginTop: number = child.pixelMarginTop;\r\n\t\t\t\tlet childMarginBottom: number = child.pixelMarginBottom;\r\n\r\n\t\t\t\tlet childWidth: number = child.measuredWidth;\r\n\t\t\t\tlet childHeight: number = child.measuredHeight;\r\n\r\n\t\t\t\tlet childLeft: $type.Optional<number>;\r\n\t\t\t\tlet childRight: $type.Optional<number>;\r\n\t\t\t\tlet childTop: $type.Optional<number>;\r\n\t\t\t\tlet childBottom: $type.Optional<number>;\r\n\r\n\t\t\t\tswitch (this.layout) {\r\n\t\t\t\t\tcase \"none\":\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t// absolute layout\r\n\t\t\t\t\tcase \"absolute\":\r\n\t\t\t\t\t\t// horizontal alignment\r\n\t\t\t\t\t\tswitch (child.align) {\r\n\t\t\t\t\t\t\tcase \"left\":\r\n\t\t\t\t\t\t\t\tx = childMarginLeft - child.maxLeft;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase \"center\":\r\n\t\t\t\t\t\t\t\tx = (innerWidth - childWidth) / 2 - child.maxLeft;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase \"right\":\r\n\t\t\t\t\t\t\t\tx = innerWidth - childMarginRight - child.maxRight;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\tif (!(child.x instanceof Percent)) {\r\n\t\t\t\t\t\t\t\t\tx = child.pixelX;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// vertical alignment\r\n\t\t\t\t\t\tswitch (child.valign) {\r\n\t\t\t\t\t\t\tcase \"top\":\r\n\t\t\t\t\t\t\t\ty = childMarginTop - child.maxTop;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase \"middle\":\r\n\t\t\t\t\t\t\t\ty = (innerHeight - childHeight) / 2 - child.maxTop;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase \"bottom\":\r\n\t\t\t\t\t\t\t\ty = innerHeight - childMarginBottom - child.maxBottom;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\tif (!(child.y instanceof Percent)) {\r\n\t\t\t\t\t\t\t\t\ty = child.pixelY;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t// vertical layout\r\n\t\t\t\t\tcase \"vertical\":\r\n\t\t\t\t\t\t//if ($type.isNumber(child.relativeHeight)) {\r\n\t\t\t\t\t\t//\tchildHeight = child.maxHeight;\r\n\t\t\t\t\t\t//}\r\n\r\n\t\t\t\t\t\tswitch (child.align) {\r\n\t\t\t\t\t\t\tcase \"left\":\r\n\t\t\t\t\t\t\t\tx = childMarginLeft - child.maxLeft;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase \"center\":\r\n\t\t\t\t\t\t\t\tx = (innerWidth - childWidth) / 2 - child.maxLeft;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase \"right\":\r\n\t\t\t\t\t\t\t\tx = innerWidth - childMarginRight - child.maxRight;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\tx = child.pixelX;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ty = nextY + childMarginTop - child.maxTop;\r\n\t\t\t\t\t\tnextY = y + child.maxBottom + childMarginBottom;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t// horizontal layout\r\n\t\t\t\t\tcase \"horizontal\":\r\n\r\n\t\t\t\t\t\t//if ($type.isNumber(child.relativeHeight)) {\r\n\t\t\t\t\t\t//\tchildHeight = child.maxHeight;\r\n\t\t\t\t\t\t//}\r\n\r\n\t\t\t\t\t\tswitch (child.valign) {\r\n\t\t\t\t\t\t\tcase \"top\":\r\n\t\t\t\t\t\t\t\ty = childMarginTop - child.maxTop;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase \"middle\":\r\n\t\t\t\t\t\t\t\ty = (innerHeight - childHeight) / 2 - child.maxTop;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase \"bottom\":\r\n\t\t\t\t\t\t\t\ty = innerHeight - childMarginBottom - child.maxBottom;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\ty = child.pixelY;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tx = nextX + childMarginLeft - child.maxLeft;\r\n\t\t\t\t\t\tnextX = x + child.maxRight + childMarginRight;\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase \"grid\":\r\n\t\t\t\t\t\tx = nextX + childMarginLeft - child.maxLeft;\r\n\t\t\t\t\t\tswitch (child.valign) {\r\n\t\t\t\t\t\t\tcase \"top\":\r\n\t\t\t\t\t\t\t\ty = nextY + childMarginTop - child.maxTop;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase \"middle\":\r\n\t\t\t\t\t\t\t\ty = nextY + (innerHeight - childHeight) / 2 - child.maxTop;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase \"bottom\":\r\n\t\t\t\t\t\t\t\ty = nextY + innerHeight - childMarginBottom - child.maxBottom;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\ty = nextY - child.maxTop;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnextX += columnWidth[column];\r\n\r\n\t\t\t\t\t\trowHeight[row] = $math.max(rowHeight[row], childHeight);\r\n\t\t\t\t\t\tcolumn++;\r\n\r\n\t\t\t\t\t\tlet nextColumnWidth = columnWidth[column];\r\n\r\n\t\t\t\t\t\tif (!$type.isNumber(nextColumnWidth)) {\r\n\t\t\t\t\t\t\tnextColumnWidth = maxCellWidth;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (nextX > $math.min(this.innerWidth, maxWidth) - nextColumnWidth + 1 && column < columnCount) {\r\n\t\t\t\t\t\t\tcolumnCount = column;\r\n\r\n\t\t\t\t\t\t\tnextX = 0;\r\n\t\t\t\t\t\t\tnextY = 0;\r\n\r\n\t\t\t\t\t\t\trow = 0;\r\n\t\t\t\t\t\t\tcolumn = 0;\r\n\r\n\t\t\t\t\t\t\tcolumnWidth = this.getColumnWidth(childrenCopy, columnCount, maxCellWidth);\r\n\t\t\t\t\t\t\trowHeight = [];\r\n\r\n\t\t\t\t\t\t\ti = -1;\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (column >= columnCount) {\r\n\t\t\t\t\t\t\tcolumn = 0;\r\n\t\t\t\t\t\t\tnextY += rowHeight[row];\r\n\t\t\t\t\t\t\trow++;\r\n\t\t\t\t\t\t\tnextX = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.layout !== \"none\") {\r\n\t\t\t\t\tchild.moveTo({ x: x, y: y }); // must use moveTo, otherwise x/y set in percent won't work\r\n\r\n\t\t\t\t\tchildLeft = x + child.maxLeft - childMarginLeft;\r\n\t\t\t\t\tchildRight = x + child.maxRight + childMarginRight;\r\n\t\t\t\t\tchildTop = y + child.maxTop - childMarginTop;\r\n\t\t\t\t\tchildBottom = y + child.maxBottom + childMarginBottom;\r\n\r\n\t\t\t\t\tif (childRight > right || !$type.isNumber(right)) {\r\n\t\t\t\t\t\tright = childRight;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (childLeft < left || !$type.isNumber(left)) {\r\n\t\t\t\t\t\tleft = childLeft;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (childTop < top || !$type.isNumber(top)) {\r\n\t\t\t\t\t\ttop = childTop;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (childBottom > bottom || !$type.isNumber(bottom)) {\r\n\t\t\t\t\t\tbottom = childBottom;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (childRight > contentRight || !$type.isNumber(contentRight)) {\r\n\t\t\t\t\t\tcontentRight = childRight;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (childLeft < contentLeft || !$type.isNumber(contentLeft)) {\r\n\t\t\t\t\t\tcontentLeft = childLeft;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (childTop < contentTop || !$type.isNumber(contentTop)) {\r\n\t\t\t\t\t\tcontentTop = childTop;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (childBottom > contentBottom || !$type.isNumber(contentBottom)) {\r\n\t\t\t\t\t\tcontentBottom = contentBottom;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tchild.validatePosition();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.layout == \"none\") {\r\n\t\t\tlet noneBBox = this.bbox;\r\n\t\t\tleft = noneBBox.x;\r\n\t\t\tright = noneBBox.x + noneBBox.width;\r\n\t\t\ttop = noneBBox.y;\r\n\t\t\tbottom = noneBBox.y + noneBBox.height;\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(left)) {\r\n\t\t\tleft = 0;\r\n\t\t\tcontentLeft = 0;\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(right)) {\r\n\t\t\tright = this._availableWidth;\r\n\t\t\tcontentRight = right;\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(top)) {\r\n\t\t\ttop = 0;\r\n\t\t\tcontentTop = 0;\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(bottom)) {\r\n\t\t\tbottom = this._availableHeight;\r\n\t\t\tcontentBottom = bottom;\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(contentTop)) {\r\n\t\t\tcontentTop = 0;\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(contentBottom)) {\r\n\t\t\tcontentBottom = contentTop;\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(contentLeft)) {\r\n\t\t\tcontentLeft = 0;\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(contentRight)) {\r\n\t\t\tcontentRight = contentLeft;\r\n\t\t}\r\n\r\n\t\tmeasuredWidth = right - left;\r\n\t\tmeasuredHeight = bottom - top;\r\n\r\n\t\tif ($type.isNumber(this.relativeWidth)) {\r\n\t\t\tmeasuredWidth = maxWidth - paddingLeft - paddingRight;\r\n\t\t\tleft = 0;\r\n\t\t\tright = measuredWidth;\r\n\t\t}\r\n\r\n\t\tif ($type.isNumber(this.relativeHeight)) {\r\n\t\t\tmeasuredHeight = maxHeight - paddingTop - paddingBottom;\r\n\t\t\ttop = 0;\r\n\t\t\tbottom = measuredHeight;\r\n\t\t}\r\n\r\n\t\tif ($type.isNumber(this._pixelWidth)) {\r\n\t\t\tleft = 0;\r\n\t\t\tmeasuredWidth = this._pixelWidth - paddingLeft - paddingRight;\r\n\t\t}\r\n\r\n\t\tif ($type.isNumber(minWidth) && measuredWidth < minWidth) {\r\n\t\t\tleft = 0;\r\n\t\t\tmeasuredWidth = this.minWidth - paddingLeft - paddingRight;\r\n\t\t}\r\n\r\n\t\tif ($type.isNumber(this._pixelHeight)) {\r\n\t\t\ttop = 0;\r\n\t\t\tmeasuredHeight = this._pixelHeight - paddingTop - paddingBottom;\r\n\t\t}\r\n\r\n\t\tif ($type.isNumber(minHeight) && measuredHeight < minHeight) {\r\n\t\t\ttop = 0;\r\n\t\t\tmeasuredHeight = minHeight - paddingTop - paddingBottom;\r\n\t\t}\r\n\r\n\t\tlet measuredContentWidth = contentRight - contentLeft;\r\n\t\tlet measuredContentHeight = contentBottom - contentTop;\r\n\r\n\t\t/// handle content alignment\r\n\t\tif (this.layout != \"none\" && (this.contentAlign || this.contentValign) && children.length > 0) {\r\n\t\t\tlet dx: $type.Optional<number>;\r\n\t\t\tlet dy: $type.Optional<number>;\r\n\r\n\t\t\tlet mwa = measuredWidth;\r\n\t\t\tlet mha = measuredHeight;\r\n\t\t\tif (mwa < measuredContentWidth) {\r\n\t\t\t\tmwa = measuredContentWidth;\r\n\t\t\t}\r\n\r\n\t\t\tif (mha < measuredContentHeight) {\r\n\t\t\t\tmha = measuredContentHeight;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.contentAlign == \"center\") {\r\n\t\t\t\tdx = (mwa - measuredContentWidth) / 2;\r\n\t\t\t}\r\n\t\t\tif (this.contentAlign == \"right\") {\r\n\t\t\t\tdx = mwa - measuredContentWidth;\r\n\t\t\t}\r\n\t\t\tif (this.contentValign == \"middle\") {\r\n\t\t\t\tdy = (mha - measuredContentHeight) / 2;\r\n\t\t\t}\r\n\t\t\tif (this.contentValign == \"bottom\") {\r\n\t\t\t\tdy = mha - measuredContentHeight;\r\n\t\t\t}\r\n\r\n\t\t\tif ($type.isNumber(dx)) {\r\n\t\t\t\t$iter.each(children.iterator(), (child) => {\r\n\t\t\t\t\tlet childLeft: number = child.maxLeft;\r\n\r\n\t\t\t\t\tlet ddx: number = dx;\r\n\r\n\t\t\t\t\tif (this.layout == \"horizontal\") {\r\n\t\t\t\t\t\tchild.x = child.pixelX + ddx;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// individual grid elements can not be aligned vertically, that's why it's different from horizontal\r\n\t\t\t\t\tif (this.layout == \"grid\") {\r\n\t\t\t\t\t\tchild.x = child.pixelX + ddx;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.layout == \"vertical\") {\r\n\t\t\t\t\t\tddx += child.pixelMarginLeft;\r\n\t\t\t\t\t\tif (child.align == \"none\") {\r\n\t\t\t\t\t\t\tchild.x = ddx - childLeft;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (this.layout == \"absolute\") {\r\n\t\t\t\t\t\tddx += child.pixelMarginLeft;\r\n\t\t\t\t\t\tif (child.align == \"none\") {\r\n\t\t\t\t\t\t\tchild.x = ddx - childLeft;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif ($type.isNumber(dy)) {\r\n\t\t\t\t$iter.each(children.iterator(), (child) => {\r\n\t\t\t\t\tlet childTop: number = child.maxTop;\r\n\r\n\t\t\t\t\tlet ddy: number = dy;\r\n\r\n\t\t\t\t\tif (this.layout == \"horizontal\") {\r\n\t\t\t\t\t\tddy += child.pixelMarginTop;\r\n\t\t\t\t\t\tif (child.valign == \"none\") {\r\n\t\t\t\t\t\t\tchild.y = ddy - childTop;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// individual grid elements can not be aligned vertically, that's why it's different from horizontal\r\n\t\t\t\t\tif (this.layout == \"grid\") {\r\n\t\t\t\t\t\tddy += child.pixelMarginTop;\r\n\t\t\t\t\t\tchild.y = ddy - childTop;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.layout == \"vertical\") {\r\n\t\t\t\t\t\tchild.y = child.pixelY + ddy;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (this.layout == \"absolute\") {\r\n\t\t\t\t\t\tddy += child.pixelMarginTop;\r\n\r\n\t\t\t\t\t\tif (child.valign == \"none\") {\r\n\t\t\t\t\t\t\tchild.y = ddy - childTop;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet oldBBox = this.bbox;\r\n\r\n\r\n\t\t// this will mess up maxw/maxh set by container layout, we need a separate min/maxwidth for users\r\n\t\t// this prevents invalidating layout in such cases as scrolling category axis, when labels go outside bounds and results transformed event\r\n\t\t// todo: need to check if this doesn't cause other problems.\r\n\t\t//if (this.maxWidth > 0) {\r\n\t\t//measuredWidth = $math.min(measuredWidth, this.maxWidth);\r\n\t\t//measuredWidth = $math.max(measuredWidth, this.minWidth);\r\n\t\t//}\r\n\r\n\t\t//if (this.maxHeight > 0) {\r\n\t\t//measuredHeight = $math.min(measuredHeight, this.maxHeight);\r\n\t\t//measuredHeight = $math.max(measuredHeight, this.minHeight);\r\n\t\t//}\r\n\r\n\t\tmeasuredWidth = $math.max(measuredWidth, minWidth);\r\n\t\tmeasuredHeight = $math.max(measuredHeight, minHeight);\r\n\r\n\t\tthis.contentWidth = measuredWidth;\r\n\t\tthis.contentHeight = measuredHeight;\r\n\t\t// new\r\n\t\tmeasuredWidth = $math.min(measuredWidth, maxWidth);\r\n\t\tmeasuredHeight = $math.min(measuredHeight, maxHeight);\r\n\r\n\t\tthis._bbox = { x: left, y: top, width: measuredWidth, height: measuredHeight };\r\n\r\n\t\tlet prevLeft = this.maxLeft;\r\n\t\tlet prevTop = this.maxTop;\r\n\t\tlet prevBotttom = this.maxBottom;\r\n\t\tlet prevRight = this.maxRight;\r\n\r\n\t\tthis.measure();\r\n\r\n\t\tif (prevLeft != this.maxLeft || prevRight != this.maxRight || prevTop != this.maxTop || prevBotttom != this.maxBottom) {\r\n\t\t\tif (this.events.isEnabled(\"transformed\")) {\r\n\t\t\t\tlet event: AMEvent<this, IContainerEvents>[\"transformed\"] = {\r\n\t\t\t\t\ttype: \"transformed\",\r\n\t\t\t\t\ttarget: this\r\n\t\t\t\t};\r\n\t\t\t\tif (oldBBox) {\r\n\t\t\t\t\tevent.dummyData = oldBBox.width + \" \" + measuredWidth + \"  \" + oldBBox.height + \" \" + measuredHeight;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.events.dispatchImmediately(\"transformed\", event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.dispatchImmediately(\"layoutvalidated\");\r\n\t}\r\n\r\n\t/**\r\n\t * Positions element according its center settings.\r\n\t *\r\n\t * @todo Description (review)\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateCenter() {\r\n\t\tsuper.updateCenter();\r\n\t\tthis.updateBackground();\r\n\t}\r\n\r\n\t/**\r\n\t * Update the background to fit into specific dimensions.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Make it protected?\r\n\t */\r\n\tpublic updateBackground(): void {\r\n\t\tlet background: Sprite = this._background; // accessing protected, as getter creates instance if it doesn't exist\r\n\r\n\t\tif (background) {\r\n\t\t\tbackground.x = this.maxLeft;\r\n\t\t\tbackground.y = this.maxTop;\r\n\t\t\tbackground.width = this.maxRight - this.maxLeft;\r\n\t\t\tbackground.height = this.maxBottom - this.maxTop;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns widths of all columns in a horizontal Container layout.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param columnCount   Number of columns\r\n\t * @param maxCellWidth  Maximum width of one grid cell\r\n\t * @return An array of column widths\r\n\t */\r\n\tpublic getColumnWidth(children: Sprite[], columnCount: number, maxCellWidth: number): number[] {\r\n\t\tlet columnWidth: number[] = [];\r\n\t\tlet column: number = 0;\r\n\r\n\t\t$array.each(children, (child) => {\r\n\t\t\tif (child.isMeasured && !child.disabled && !child.__disabled) {\r\n\t\t\t\tif (this.fixedWidthGrid) {\r\n\t\t\t\t\tcolumnWidth[column] = maxCellWidth;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tcolumnWidth[column] = $math.max(columnWidth[column], child.measuredWidth + child.pixelMarginRight + child.pixelMarginLeft);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcolumn++;\r\n\r\n\t\t\t\tif (column == columnCount) {\r\n\t\t\t\t\tcolumn = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn columnWidth;\r\n\t}\r\n\r\n\t/**\r\n\t * Container layout.\r\n\t *\r\n\t * Options: \"absolute\" (default), \"vertical\", \"horizontal\", \"grid\", \"none\". \"none\" is quite the same as \"absolute\" - the objects will\r\n\t * be positioned at their x, y coordinates, the difference is that with \"absolute\" you can still use align/valign for children and with \"none\" you can not.\r\n\t * Use \"none\" as much as you can as it's most cpu-saving layout.\r\n\t *\r\n\t * @default \"absolute\"\r\n\t * @param value Layout\r\n\t */\r\n\tpublic set layout(value: ContainerLayout) {\r\n\t\tif (this.setPropertyValue(\"layout\", value)) {\r\n\t\t\tthis.invalidateLayout();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Layout\r\n\t */\r\n\tpublic get layout(): ContainerLayout {\r\n\t\treturn this.getPropertyValue(\"layout\");\r\n\t}\r\n\r\n\t/**\r\n\t * Vertical alignment of the elements for the vertical Container.\r\n\t *\r\n\t * This is used when Container is larger than the height of all its children.\r\n\t *\r\n\t * @param value vertical alignment\r\n\t */\r\n\tpublic set contentValign(value: VerticalAlign) {\r\n\t\tthis.setPropertyValue(\"contentValign\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Vertical alignment\r\n\t */\r\n\tpublic get contentValign(): VerticalAlign {\r\n\t\treturn this.getPropertyValue(\"contentValign\");\r\n\t}\r\n\r\n\t/**\r\n\t * Horizontal alignment of the elements for the horizontal Container.\r\n\t *\r\n\t * This is used when Container is larger than the height of all its children.\r\n\t *\r\n\t * @param value  Horizontal alignment\r\n\t */\r\n\tpublic set contentAlign(value: Align) {\r\n\t\tthis.setPropertyValue(\"contentAlign\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Horizontal alignment\r\n\t */\r\n\tpublic get contentAlign(): Align {\r\n\t\treturn this.getPropertyValue(\"contentAlign\");\r\n\t}\r\n\r\n\t/**\r\n\t * Controls if the grid of the Container should use fixed width. Fixed width\r\n\t * grid will divide available space to all its columns/rows equally, without\r\n\t * adapting to actual child sizes or size requirements.\r\n\t *\r\n\t * @default false\r\n\t * @param value  Should use fixed width grid?\r\n\t */\r\n\tpublic set fixedWidthGrid(value: boolean) {\r\n\t\tthis.setPropertyValue(\"fixedWidthGrid\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Should use fixed width grid?\r\n\t */\r\n\tpublic get fixedWidthGrid(): boolean {\r\n\t\treturn this.getPropertyValue(\"fixedWidthGrid\");\r\n\t}\r\n\r\n\t/**\r\n\t * Maximum number of columns (when using `\"grid\"` layout).\r\n\t *\r\n\t * @param value  Should use fixed width grid?\r\n\t */\r\n\tpublic set maxColumns(value: Optional<number>) {\r\n\t\tthis.setPropertyValue(\"maxColumns\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Should use fixed width grid?\r\n\t */\r\n\tpublic get maxColumns(): Optional<number> {\r\n\t\treturn this.getPropertyValue(\"maxColumns\");\r\n\t}\r\n\r\n\t/**\r\n\t * If set to `true`, the children of the container will be drawn in reverse\r\n\t * order.\r\n\t *\r\n\t * @default false\r\n\t * @param value  Reverse children?\r\n\t */\r\n\tpublic set reverseOrder(value: Optional<boolean>) {\r\n\t\tthis.setPropertyValue(\"reverseOrder\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Reverse children?\r\n\t */\r\n\tpublic get reverseOrder(): Optional<boolean> {\r\n\t\treturn this.getPropertyValue(\"reverseOrder\");\r\n\t}\r\n\r\n\t/**\r\n\t * Specifies if, when state is applied on this container, the same state\r\n\t * should be applied to container's children as well as `background`.\r\n\t *\r\n\t * @default false\r\n\t * @param value  Set state on children\r\n\t */\r\n\tpublic set setStateOnChildren(value: boolean) {\r\n\t\tthis.setPropertyValue(\"setStateOnChildren\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Set state on children\r\n\t */\r\n\tpublic get setStateOnChildren(): boolean {\r\n\t\treturn this.getPropertyValue(\"setStateOnChildren\");\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if point is within bounds of a container.\r\n\t *\r\n\t * @param point  A coordinate to check\r\n\t * @return `true` if it fits within container\r\n\t */\r\n\tpublic fitsToBounds(point: IPoint): boolean {\r\n\t\tlet x = point.x;\r\n\t\tlet y = point.y;\r\n\t\tlet deviation = 0.5; // sometimes coordinates are rounded to numbers like .999 so we add deviation here\r\n\t\tif (x >= -deviation && x <= this.pixelWidth + deviation && y >= -deviation && y <= this.pixelHeight + deviation) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all properties from different Container, including background\r\n\t * clone.\r\n\t *\r\n\t * @param source  Source Container to copy from\r\n\t */\r\n\tpublic copyFrom(source: this) {\r\n\t\tsuper.copyFrom(source);\r\n\t\tthis.layout = source.layout;\r\n\t\tthis.setStateOnChildren = source.setStateOnChildren;\r\n\r\n\t\tif (source._background) {\r\n\t\t\tthis.background = source._background.clone();\r\n\t\t\tthis.background.copyFrom(source._background); // won't work without this\r\n\t\t}\r\n\r\n\t\t$iter.each(source.children.iterator(), (child) => {\r\n\t\t\tif (child.shouldClone) {\r\n\t\t\t\tlet clonedChild: Sprite = child.clone();\r\n\t\t\t\tclonedChild.parent = this;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * A [[Preloader]] instance to be used when Container is busy.\r\n\t *\r\n\t * @param preloader  Preloader instance\r\n\t */\r\n\tpublic set preloader(preloader: $type.Optional<Preloader>) {\r\n\t\tif (this._preloader) {\r\n\t\t\tthis.removeDispose(this._preloader);\r\n\t\t}\r\n\t\tthis._preloader = preloader;\r\n\t\tif (preloader) {\r\n\t\t\tpreloader.parent = this.tooltipContainer;\r\n\t\t\tthis._disposers.push(preloader);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Preloader instance\r\n\t */\r\n\tpublic get preloader(): $type.Optional<Preloader> {\r\n\t\tconst preloader = this._preloader;\r\n\r\n\t\tif (preloader) {\r\n\t\t\treturn preloader;\r\n\t\t}\r\n\t\telse if (this.parent) {\r\n\t\t\treturn this.parent.preloader;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets [[Paper]] instance to use to draw elements.\r\n\t * @ignore\r\n\t * @param paper Paper\r\n\t * @return true if paper was changed, false, if it's the same\r\n\t */\r\n\tpublic setPaper(paper: Paper): boolean {\r\n\t\tlet changed = super.setPaper(paper);\r\n\r\n\t\tif (changed) {\r\n\t\t\tif (this._background) {\r\n\t\t\t\tthis._background.paper = paper;\r\n\t\t\t\tthis._background.topParent = this.topParent;\r\n\t\t\t}\r\n\t\t\tthis.children.each((child) => {\r\n\t\t\t\tchild.setPaper(paper);\r\n\t\t\t\tchild.topParent = this.topParent;\r\n\t\t\t})\r\n\t\t}\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes Container from the system-wide list of invalid Containers.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected removeFromInvalids() {\r\n\t\tsuper.removeFromInvalids();\r\n\t\tregistry.removeFromInvalidLayouts(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a [[DataItem]] to be used as data for the Container.\r\n\t *\r\n\t * @todo Description\r\n\t * @param dataItem DataItem\r\n\t */\r\n\tprotected setDataItem(dataItem: DataItem) {\r\n\t\t// this place is potentially dangerous, as if we set datItem for some dummy container, all children dataItems will be overriden\r\n\t\t// the main reason for doing this is that we need a setDataItem code to be called for each sprite, otherwise property fields won't be\r\n\t\t// applied. Also, getting dataItem from parent all the time is more expensive than saving value.\r\n\t\tif (this._dataItem != dataItem) {\r\n\t\t\t$iter.each(this.children.iterator(), (child) => {\r\n\t\t\t\tchild.dataItem = dataItem;\r\n\t\t\t});\r\n\r\n\t\t\tif (this._background) {\r\n\t\t\t\tthis._background.dataItem = dataItem;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsuper.setDataItem(dataItem);\r\n\t}\r\n\r\n\t/**\r\n\t * Measures the element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic measureElement(): void {\r\n\t\tif (this.disabled || this.isTemplate || this.layout == \"none\" || this.__disabled) {\r\n\t\t\t// void\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.validateLayout();\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Font family to be used for the text.\r\n\t *\r\n\t * Parts of the text may override this setting using in-line formatting.\r\n\t *\r\n\t * @param value Font family value\r\n\t */\r\n\tpublic set fontFamily(value: string) {\r\n\t\tif (this.setPropertyValue(\"fontFamily\", value, true)) {\r\n\t\t\tthis.setSVGAttribute({ \"font-family\": value });\r\n\t\t\tthis.invalidateLabels();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Font family\r\n\t */\r\n\tpublic get fontFamily(): string {\r\n\t\treturn this.getPropertyValue(\"fontFamily\");\r\n\t}\r\n\r\n\t/**\r\n\t * Font size to be used for the text. The size can either be numeric, in\r\n\t * pixels, or other measurements.\r\n\t *\r\n\t * Parts of the text may override this setting using in-line formatting.\r\n\t *\r\n\t * @param value Font size value\r\n\t */\r\n\tpublic set fontSize(value: any) {\r\n\t\tif (this.setPropertyValue(\"fontSize\", value, true)) {\r\n\t\t\tthis.setSVGAttribute({ \"font-size\": value });\r\n\t\t\tthis.invalidateLabels();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Font size\r\n\t */\r\n\tpublic get fontSize(): any {\r\n\t\treturn this.getPropertyValue(\"fontSize\");\r\n\t}\r\n\r\n\t/**\r\n\t * When fontSize of fontFamily changes we need to hard-invalidate all Labels of this container to position them properly.\r\n\t */\r\n\tpublic invalidateLabels() {\r\n\t\tthis.children.each((child) => {\r\n\t\t\t// can't import Label because of Circular dependencies\r\n\t\t\tif ((<any>child)[\"hardInvalidate\"]) {\r\n\t\t\t\t(<any>child)[\"hardInvalidate\"]();\r\n\t\t\t\t// this fixes firefox and viewport issue\r\n\t\t\t\tchild.events.once(\"validated\", (<any>child).handleValidate, child, false);\r\n\t\t\t}\r\n\t\t\telse if (child instanceof Container) {\r\n\t\t\t\tchild.invalidateLabels();\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * Font weight to use for text.\r\n\t *\r\n\t * Parts of the text may override this setting using in-line formatting.\r\n\t *\r\n\t * @param value Font weight\r\n\t */\r\n\tpublic set fontWeight(value: FontWeight) {\r\n\t\tthis.setPropertyValue(\"fontWeight\", value);\r\n\t\tthis.setSVGAttribute({ \"font-weight\": value });\r\n\t}\r\n\r\n\t/**\r\n\t * @return Font weight\r\n\t */\r\n\tpublic get fontWeight(): FontWeight {\r\n\t\treturn this.getPropertyValue(\"fontWeight\");\r\n\t}\r\n\r\n\t/**\r\n\t * A text decoration to use for text.\r\n\t *\r\n\t * Parts of the text may override this setting using in-line formatting.\r\n\t *\r\n\t * @param value  Decoration\r\n\t */\r\n\tpublic set textDecoration(value: TextDecoration) {\r\n\t\tthis.setPropertyValue(\"textDecoration\", value);\r\n\t\tthis.setSVGAttribute({ \"text-decoration\": value });\r\n\t}\r\n\r\n\t/**\r\n\t * @return Decoration\r\n\t */\r\n\tpublic get textDecoration(): TextDecoration {\r\n\t\treturn this.getPropertyValue(\"textDecoration\");\r\n\t}\r\n\r\n\t/**\r\n\t * Disposes (destroys) the element and all its children.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tif (this._background) {\r\n\t\t\tthis._background.dispose();\r\n\t\t}\r\n\t\tthis._shouldBeReady = [];\r\n\t\tthis.disposeChildren();\r\n\t\tsuper.dispose();\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a [[SpriteState]] on this element.\r\n\t *\r\n\t * The first parameter can either be a name of the state or a [[SpriteState]]\r\n\t * instance.\r\n\t *\r\n\t * When run, this method will apply SVG properties defined in a\r\n\t * [[SpriteState]], but only those that are relevant to this particular\r\n\t * element, that is are listed in its respective `properties` array.\r\n\t *\r\n\t * @see {@link SpriteState}\r\n\t * @param value               A state - name key or instance\r\n\t * @param transitionDuration  Duration of the transition between current and new state\r\n\t * @param easing              An easing function\r\n\t */\r\n\tpublic setState(value: string | SpriteState<this[\"_properties\"], this[\"_adapter\"]>, transitionDuration?: number, easing?: (value: number) => number): $type.Optional<Animation> {\r\n\r\n\t\tlet stateName = value;\r\n\t\tif (value instanceof SpriteState) {\r\n\t\t\tstateName = value.name;\r\n\t\t}\r\n\r\n\t\tif (this.setStateOnChildren) {\r\n\t\t\t$iter.each(this.children.iterator(), (child) => {\r\n\t\t\t\tchild.setState(stateName, transitionDuration, easing);\r\n\r\n\t\t\t\t// not good to set it in child setState\r\n\t\t\t\tif (stateName != \"active\") {\r\n\t\t\t\t\tchild.isActive = false;\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\tif (this._background) {\r\n\t\t\tthis._background.setState(stateName);\r\n\t\t}\r\n\r\n\t\tif (this.setStateOnSprites.length) {\r\n\t\t\t$array.each(this.setStateOnSprites, (item) => {\r\n\t\t\t\titem.setState(stateName, transitionDuration, easing);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn super.setState(value, transitionDuration, easing);\r\n\t}\r\n\r\n\t// otherwise isActive won't work properly with background\r\n\tprotected setActive(value: boolean) {\r\n\t\tsuper.setActive(value);\r\n\t\tif (this._background) {\r\n\t\t\tthis._background.isActive = value;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Dispatches ready event. Dispatches when all children are ready.\r\n\t */\r\n\tpublic dispatchReady() {\r\n\t\tif (!this.isReady() && !this.isDisposed()) {\r\n\t\t\tlet allReady = true;\r\n\r\n\t\t\t$iter.eachContinue(this.children.iterator(), (sprite) => {\r\n\t\t\t\tif (!sprite.__disabled && !sprite.disabled && !sprite.isReady()) {\r\n\t\t\t\t\tallReady = false;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t$array.eachContinue(this._shouldBeReady, (sprite) => {\r\n\t\t\t\tif (!sprite.__disabled && !sprite.disabled && !sprite.isReady()) {\r\n\t\t\t\t\tallReady = false;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tif (allReady) {\r\n\t\t\t\tsuper.dispatchReady();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tregistry.events.once(\"exitframe\", () => {\r\n\t\t\t\t\tthis.dispatchReady();\r\n\t\t\t\t\tsystem.requestFrame();\r\n\t\t\t\t}, undefined, false);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Called during the System.update method\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic _systemUpdate(skippedSprites: Array<Sprite>): void {\r\n\t\tthis.children.each((child) => {\r\n\t\t\tif (child.invalid) {\r\n\t\t\t\tif (!child._systemCheckIfValidate()) {\r\n\t\t\t\t\tskippedSprites.push(child);\r\n\t\t\t\t}\r\n\t\t\t\telse if (child.dataItem && child.dataItem.component && child.dataItem.component.dataInvalid) {\r\n\t\t\t\t\tskippedSprites.push(child);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tchild.validate();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tsuper._systemUpdate(skippedSprites);\r\n\t}\r\n\r\n\t/**\r\n\t * Called during the System.validatePositions method\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic _systemValidatePositions() {\r\n\t\tthis.children.each((sprite) => {\r\n\t\t\tif (sprite.positionInvalid) {\r\n\t\t\t\tsprite.validatePosition();\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tsuper._systemValidatePositions();\r\n\t}\r\n\r\n\t/**\r\n\t * Called during the System.validateLayouts method\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic _systemValidateLayouts() {\r\n\t\tif (this.layoutInvalid && !this.isDisposed()) {\r\n\t\t\tthis.validateLayout();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * If set to `true` the chart's regular touch functionality will be suspended\r\n\t * so that the whole page it is located in remains scrollable, even when\r\n\t * swiping over the chart's body.\r\n\t *\r\n\t * User will need to tap the chart in order to activate its regular touch\r\n\t * functionality.\r\n\t *\r\n\t * The chart will remain \"active\" as long as user keeps interacting with the\r\n\t * chart. After `tapTimeout` milliseconds the chart will return to its\r\n\t * \"protected\" mode.\r\n\t *\r\n\t * @default false\r\n\t * @since 4.4.0\r\n\t * @param  value  Enable touch protection?\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/touch/} For more information.\r\n\t */\r\n\tpublic set tapToActivate(value: boolean) {\r\n\t\tif (this._tapToActivate != value) {\r\n\t\t\tthis.setTapToActivate(value);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Enable touch protection?\r\n\t */\r\n\tpublic get tapToActivate(): boolean {\r\n\t\treturn this._tapToActivate;\r\n\t}\r\n\r\n\tprotected setTapToActivate(value: boolean): void {\r\n\t\tthis._tapToActivate = value;\r\n\t\tthis.interactions.isTouchProtected = value;\r\n\t\t// setEventDisposer will also remove listeners if value == false\r\n\t\tif (value) {\r\n\t\t\tthis.interactions.setEventDisposer(\"container-tapToActivate\", value, () => new MultiDisposer([\r\n\t\t\t\tthis.events.on(\"hit\", this.handleTapToActivate, this, false),\r\n\t\t\t\tthis.events.on(\"down\", this.initTapTimeout, this, false),\r\n\t\t\t\tthis.events.on(\"track\", this.initTapTimeout, this, false),\r\n\t\t\t\t//this.events.on(\"drag\", this.initTapTimeout, this, false),\r\n\t\t\t\tgetInteraction().body.events.on(\"down\", (ev) => {\r\n\t\t\t\t\tif (!getInteraction().isLocalElement(ev.pointer, this.paper.svg, this.uid)) {\r\n\t\t\t\t\t\tthis.handleTapToActivateDeactivation();\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this, false)\r\n\t\t\t]));\r\n\t\t}\r\n\r\n\t\tgetInteraction()\r\n\t}\r\n\r\n\t/**\r\n\t * @todo Ignore on non-touch events\r\n\t */\r\n\tprotected handleTapToActivate(): void {\r\n\t\tthis.interactions.isTouchProtected = false;\r\n\t\tthis.initTapTimeout();\r\n\t}\r\n\r\n\tprotected handleTapToActivateDeactivation(): void {\r\n\t\tthis.interactions.isTouchProtected = true;\r\n\t}\r\n\r\n\tprotected initTapTimeout(): void {\r\n\t\tif (this._tapToActivateTimeout) {\r\n\t\t\tthis._tapToActivateTimeout.dispose();\r\n\t\t}\r\n\t\tif (this.tapToActivate && !this.interactions.isTouchProtected && this.tapTimeout) {\r\n\t\t\tthis._tapToActivateTimeout = this.setTimeout(() => {\r\n\t\t\t\tthis.handleTapToActivateDeactivation()\r\n\t\t\t}, this.tapTimeout);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Moves the whole chart to other HTML container.\r\n\t *\r\n\t * `htmlElement` can either be a reference to a DOM element, or an id of\r\n\t * such element.\r\n\t *\r\n\t * @since 4.9.24\r\n\t * @param  htmlElement  Target element\r\n\t */\r\n\tpublic moveHtmlContainer(htmlElement: string | HTMLElement): void {\r\n\t\tlet newContainer = $dom.getElement(htmlElement);\r\n\t\tif (newContainer) {\r\n\t\t\tthis.htmlContainer = newContainer;\r\n\t\t\tconst svgDiv = this.svgContainer;\r\n\t\t\tsvgDiv.htmlElement = newContainer;\r\n\t\t\tsvgDiv.htmlElement.appendChild(svgDiv.SVGContainer);\r\n\t\t\tsvgDiv.initSensor();\r\n\t\t\tsvgDiv.measure();\r\n\t\t}\r\n\t\telse if($type.isString(htmlElement) && htmlElement != \"\") {\r\n\t\t\tsystem.log(\"html container '\" + htmlElement + \"' not found\");\r\n\t\t\t//throw new Error(\"html container not found\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t * @return Has license?\r\n\t */\r\n\tpublic hasLicense(): boolean {\r\n\t\tif (options.commercialLicense) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tfor (let i = 0; i < options.licenses.length; i++) {\r\n\t\t\tif (options.licenses[i].match(/^CH.{5,}/i)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Container\"] = Container;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}