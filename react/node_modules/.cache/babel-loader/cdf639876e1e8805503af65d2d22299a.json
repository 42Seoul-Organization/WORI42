{"ast":null,"code":"/**\r\n * Polyline module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Sprite } from \"../Sprite\";\nimport { color } from \"../utils/Color\";\nimport { registry } from \"../Registry\";\nimport * as $path from \"../rendering/Path\";\nimport * as $math from \"../utils/Math\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Draws a polyline.\r\n *\r\n * @see {@link IPolylineEvents} for a list of available events\r\n * @see {@link IPolylineAdapters} for a list of available Adapters\r\n */\n\nvar Polyline =\n/** @class */\nfunction (_super) {\n  __extends(Polyline, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Polyline() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * [_distance description]\r\n     *\r\n     * @todo Description\r\n     */\n\n\n    _this._distance = 0;\n    _this.className = \"Polyline\";\n    _this.element = _this.paper.add(\"path\");\n    _this.shapeRendering = \"auto\";\n    _this.fill = color();\n    _this.strokeOpacity = 1;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Creats and adds an SVG path for the arc.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Polyline.prototype.makePath = function () {\n    this._distance = 0;\n    var segments = this.segments;\n\n    if (segments && segments.length > 0) {\n      var path = \"\";\n\n      for (var i = 0, len = segments.length; i < len; i++) {\n        var points = segments[i];\n\n        if (points.length > 0) {\n          path += $path.moveTo(points[0]);\n\n          for (var p = 1; p < points.length; p++) {\n            var point = points[p];\n            path += $path.lineTo(point);\n            this._distance += $math.getDistance(points[p - 1], point);\n          }\n        }\n      }\n\n      this.path = path;\n    }\n\n    this._realSegments = segments;\n  };\n\n  Object.defineProperty(Polyline.prototype, \"segments\", {\n    /**\r\n     * @return Segments\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"segments\");\n    },\n\n    /**\r\n     * A list of segment coordinates for the multi-part line.\r\n     *\r\n     * @todo Example\r\n     * @param segments  Segments\r\n     */\n    set: function set(segments) {\n      this.setPropertyValue(\"segments\", segments);\n      this.makePath();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polyline.prototype, \"distance\", {\n    /**\r\n     * [distance description]\r\n     *\r\n     * @todo Description\r\n     * @return [description]\r\n     */\n    get: function get() {\n      return this._distance;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts relative position along the line (0-1) into pixel coordinates.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Coordinates\r\n   */\n\n  Polyline.prototype.positionToPoint = function (position) {\n    var deltaAngle = 0;\n\n    if (position < 0) {\n      position = Math.abs(position);\n      deltaAngle = 180;\n    }\n\n    var segments = this._realSegments;\n\n    if (segments) {\n      var totalDistance = this.distance;\n      var currentDistance = 0;\n      var distanceAB = void 0;\n      var positionA = 0;\n      var positionB = 0;\n      var pointA = void 0;\n      var pointB = void 0;\n\n      for (var s = 0; s < segments.length; s++) {\n        var points = segments[s];\n\n        if (points.length > 1) {\n          for (var p = 1; p < points.length; p++) {\n            pointA = points[p - 1];\n            pointB = points[p];\n            positionA = currentDistance / totalDistance;\n            distanceAB = $math.getDistance(pointA, pointB);\n            currentDistance += distanceAB;\n            positionB = currentDistance / totalDistance;\n\n            if (positionA <= position && positionB > position) {\n              s = segments.length;\n              break;\n            }\n          }\n        } else if (points.length == 1) {\n          pointA = points[0];\n          pointB = points[0];\n          positionA = 0;\n          positionB = 1;\n        }\n      }\n\n      if (pointA && pointB) {\n        var positionAB = (position - positionA) / (positionB - positionA);\n        var midPoint = $math.getMidPoint(pointA, pointB, positionAB);\n        return {\n          x: midPoint.x,\n          y: midPoint.y,\n          angle: deltaAngle + $math.getAngle(pointA, pointB)\n        };\n      }\n    }\n\n    return {\n      x: 0,\n      y: 0,\n      angle: 0\n    };\n  };\n\n  Object.defineProperty(Polyline.prototype, \"realSegments\", {\n    /**\r\n     * @ignore\r\n     */\n    get: function get() {\n      return this._realSegments;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Polyline;\n}(Sprite);\n\nexport { Polyline };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Polyline\"] = Polyline;","map":{"version":3,"sources":["../../../../../src/.internal/core/elements/Polyline.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Polyline module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Sprite, ISpriteProperties, ISpriteAdapters, ISpriteEvents } from \"../Sprite\";\r\nimport { IPoint, IOrientationPoint } from \"../defs/IPoint\";\r\nimport { color } from \"../utils/Color\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $path from \"../rendering/Path\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[Polyline]].\r\n */\r\nexport interface IPolylineProperties extends ISpriteProperties {\r\n\r\n\t/**\r\n\t * A list of segment coordinates for the multi-part line.\r\n\t */\r\n\tsegments?: Array<Array<IPoint>>;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[Polyline]].\r\n */\r\nexport interface IPolylineEvents extends ISpriteEvents { }\r\n\r\n/**\r\n * Defines adapters for [[Polyline]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IPolylineAdapters extends ISpriteAdapters, IPolylineProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Draws a polyline.\r\n *\r\n * @see {@link IPolylineEvents} for a list of available events\r\n * @see {@link IPolylineAdapters} for a list of available Adapters\r\n */\r\nexport class Polyline extends Sprite {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IPolylineProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IPolylineAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IPolylineEvents;\r\n\r\n\t/**\r\n\t * [_distance description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _distance: number = 0;\r\n\r\n\t/**\r\n\t * [_realSegments]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _realSegments: $type.Optional<Array<Array<IPoint>>>;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"Polyline\";\r\n\t\tthis.element = this.paper.add(\"path\");\r\n\t\tthis.shapeRendering = \"auto\";\r\n\t\tthis.fill = color();\r\n\t\tthis.strokeOpacity = 1;\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Creats and adds an SVG path for the arc.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic makePath(): void {\r\n\t\tthis._distance = 0;\r\n\t\tlet segments = this.segments;\r\n\r\n\t\tif (segments && segments.length > 0) {\r\n\t\t\tlet path: string = \"\";\r\n\r\n\t\t\tfor (let i = 0, len = segments.length; i < len; i++) {\r\n\t\t\t\tlet points: IPoint[] = segments[i];\r\n\t\t\t\tif (points.length > 0) {\r\n\t\t\t\t\tpath += $path.moveTo(points[0]);\r\n\r\n\t\t\t\t\tfor (let p = 1; p < points.length; p++) {\r\n\t\t\t\t\t\tlet point: IPoint = points[p];\r\n\t\t\t\t\t\tpath += $path.lineTo(point);\r\n\t\t\t\t\t\tthis._distance += $math.getDistance(points[p - 1], point);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.path = path;\r\n\t\t}\r\n\r\n\t\tthis._realSegments = segments;\r\n\t}\r\n\r\n\t/**\r\n\t * A list of segment coordinates for the multi-part line.\r\n\t *\r\n\t * @todo Example\r\n\t * @param segments  Segments\r\n\t */\r\n\tpublic set segments(segments: $type.Optional<Array<Array<IPoint>>>) {\r\n\t\tthis.setPropertyValue(\"segments\", segments);\r\n\t\tthis.makePath();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Segments\r\n\t */\r\n\tpublic get segments(): $type.Optional<Array<Array<IPoint>>> {\r\n\t\treturn this.getPropertyValue(\"segments\");\r\n\t}\r\n\r\n\t/**\r\n\t * [distance description]\r\n\t *\r\n\t * @todo Description\r\n\t * @return [description]\r\n\t */\r\n\tpublic get distance(): number {\r\n\t\treturn this._distance;\r\n\t}\r\n\r\n\t/**\r\n\t * Converts relative position along the line (0-1) into pixel coordinates.\r\n\t *\r\n\t * @param position  Position (0-1)\r\n\t * @return Coordinates\r\n\t */\r\n\tpublic positionToPoint(position: number): IOrientationPoint {\r\n\r\n\t\tlet deltaAngle: number = 0;\r\n\r\n\t\tif (position < 0) {\r\n\t\t\tposition = Math.abs(position);\r\n\t\t\tdeltaAngle = 180;\r\n\t\t}\r\n\r\n\t\tlet segments: $type.Optional<Array<Array<IPoint>>> = this._realSegments;\r\n\t\tif (segments) {\r\n\t\t\tlet totalDistance: number = this.distance;\r\n\t\t\tlet currentDistance: number = 0;\r\n\r\n\t\t\tlet distanceAB: number;\r\n\t\t\tlet positionA: number = 0;\r\n\t\t\tlet positionB: number = 0;\r\n\t\t\tlet pointA: IPoint;\r\n\t\t\tlet pointB: IPoint;\r\n\r\n\t\t\tfor (let s = 0; s < segments.length; s++) {\r\n\t\t\t\tlet points: IPoint[] = segments[s];\r\n\t\t\t\tif (points.length > 1) {\r\n\t\t\t\t\tfor (let p = 1; p < points.length; p++) {\r\n\t\t\t\t\t\tpointA = points[p - 1];\r\n\t\t\t\t\t\tpointB = points[p];\r\n\r\n\t\t\t\t\t\tpositionA = currentDistance / totalDistance;\r\n\t\t\t\t\t\tdistanceAB = $math.getDistance(pointA, pointB);\r\n\t\t\t\t\t\tcurrentDistance += distanceAB;\r\n\t\t\t\t\t\tpositionB = currentDistance / totalDistance;\r\n\r\n\t\t\t\t\t\tif (positionA <= position && positionB > position) {\r\n\t\t\t\t\t\t\ts = segments.length;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (points.length == 1) {\r\n\t\t\t\t\tpointA = points[0];\r\n\t\t\t\t\tpointB = points[0];\r\n\t\t\t\t\tpositionA = 0;\r\n\t\t\t\t\tpositionB = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (pointA && pointB) {\r\n\t\t\t\tlet positionAB: number = (position - positionA) / (positionB - positionA);\r\n\t\t\t\tlet midPoint: IPoint = $math.getMidPoint(pointA, pointB, positionAB);\r\n\t\t\t\treturn { x: midPoint.x, y: midPoint.y, angle: deltaAngle + $math.getAngle(pointA, pointB) };\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn { x: 0, y: 0, angle: 0 };\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic get realSegments():IPoint[][]{\r\n\t\treturn this._realSegments;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Polyline\"] = Polyline;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}