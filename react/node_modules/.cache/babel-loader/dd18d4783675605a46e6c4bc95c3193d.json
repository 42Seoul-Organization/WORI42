{"ast":null,"code":"/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { registry } from \"../Registry\";\nimport * as $path from \"./Path\";\nimport * as $array from \"../utils/Array\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $math from \"../utils/Math\";\n/**\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\n\nvar Tension =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param tensionX [description]\r\n   * @param tensionY [description]\r\n   */\n  function Tension(tensionX, tensionY) {\n    this._tensionX = tensionX;\n    this._tensionY = tensionY;\n  }\n  /**\r\n   * [smooth description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param points  [description]\r\n   * @return [description]\r\n   */\n\n\n  Tension.prototype.smooth = function (points) {\n    for (var i = points.length - 1; i > 0; i--) {\n      var p0 = points[i];\n      var p1 = points[i - 1];\n\n      if (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n        points.splice(i - 1, 1);\n      }\n    }\n\n    var tensionX = this._tensionX;\n    var tensionY = this._tensionY;\n\n    if (points.length < 3 || tensionX >= 1 && tensionY >= 1) {\n      return $path.polyline(points);\n    }\n\n    var first = points[0];\n    var last = points[points.length - 1];\n    var closed = false;\n\n    if ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n      closed = true;\n    } // Can't moveTo here, as it wont be possible to have fill then.\n\n\n    var path = \"\";\n\n    for (var i = 0, len = points.length - 1; i < len; i++) {\n      var p0 = points[i - 1];\n      var p1 = points[i];\n      var p2 = points[i + 1];\n      var p3 = points[i + 2];\n\n      if (i === 0) {\n        if (closed) {\n          p0 = points[points.length - 2];\n        } else {\n          p0 = points[i];\n        }\n      } else if (i == points.length - 2) {\n        if (closed) {\n          p3 = points[1];\n        } else {\n          p3 = points[i + 1];\n        }\n      }\n\n      var controlPointA = $math.getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY);\n      var controlPointB = $math.getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY);\n      path += $path.cubicCurveTo(p2, controlPointA, controlPointB);\n    }\n\n    return path;\n  };\n\n  return Tension;\n}();\n\nexport { Tension };\n/**\r\n * Returns a waved line SVG path between two points.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point1            Starting point\r\n * @param point2            Ending point\r\n * @param waveLength        Wave length\r\n * @param waveHeight        Wave height\r\n * @param adjustWaveLength  Adjust wave length based on the actual line length\r\n * @return SVG path\r\n */\n\nexport function wavedLine(point1, point2, waveLength, waveHeight, tension, adjustWaveLength) {\n  var x1 = point1.x;\n  var y1 = point1.y;\n  var x2 = point2.x;\n  var y2 = point2.y;\n  var distance = $math.getDistance(point1, point2);\n\n  if (adjustWaveLength) {\n    waveLength = distance / Math.round(distance / waveLength);\n  }\n\n  var d = registry.getCache($utils.stringify([\"wavedLine\", point1.x, point2.x, point1.y, point2.y, waveLength, waveHeight]));\n\n  if (!d) {\n    if (distance > 0) {\n      var angle = Math.atan2(y2 - y1, x2 - x1);\n      var cos = Math.cos(angle);\n      var sin = Math.sin(angle);\n      var waveLengthX = waveLength * cos;\n      var waveLengthY = waveLength * sin;\n\n      if (waveLength <= 1 || waveHeight <= 1) {\n        d = $path.lineTo(point2);\n      } else {\n        var halfWaveCount = Math.round(2 * distance / waveLength);\n        var points = [];\n        var sign = 1;\n\n        if (x2 < x1) {\n          sign *= -1;\n        }\n\n        if (y2 < y1) {\n          sign *= -1;\n        }\n\n        for (var i = 0; i <= halfWaveCount; i++) {\n          sign *= -1;\n          var x = x1 + i * waveLengthX / 2 + sign * waveHeight / 2 * sin;\n          var y = y1 + i * waveLengthY / 2 - sign * waveHeight / 2 * cos;\n          points.push({\n            x: x,\n            y: y\n          });\n        }\n\n        d = new Tension(tension, tension).smooth(points);\n      }\n    } else {\n      d = \"\";\n    }\n\n    registry.setCache($utils.stringify([\"wavedLine\", point1.x, point2.x, point1.y, point2.y, waveLength, waveHeight]), d);\n  }\n\n  return d;\n}\n/**\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\n\nvar Basis =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param info  [description]\r\n   */\n  function Basis(info) {\n    this._closed = info.closed;\n  }\n  /**\r\n   * [smooth description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param points  [description]\r\n   * @return [description]\r\n   */\n\n\n  Basis.prototype.smooth = function (points) {\n    var _this = this;\n\n    var x0 = NaN;\n    var x1 = NaN;\n    var x2 = NaN;\n    var x3 = NaN;\n    var x4 = NaN;\n    var y0 = NaN;\n    var y1 = NaN;\n    var y2 = NaN;\n    var y3 = NaN;\n    var y4 = NaN;\n    var point = 0;\n    var output = \"\";\n\n    var pushCurve = function (x, y) {\n      output += $path.cubicCurveTo({\n        x: (x0 + 4 * x1 + x) / 6,\n        y: (y0 + 4 * y1 + y) / 6\n      }, {\n        x: (2 * x0 + x1) / 3,\n        y: (2 * y0 + y1) / 3\n      }, {\n        x: (x0 + 2 * x1) / 3,\n        y: (y0 + 2 * y1) / 3\n      });\n    };\n\n    var pushPoint = function (_a) {\n      var x = _a.x,\n          y = _a.y;\n\n      switch (point) {\n        case 0:\n          point = 1;\n\n          if (_this._closed) {\n            x2 = x;\n            y2 = y;\n          } else {\n            output += $path.lineTo({\n              x: x,\n              y: y\n            });\n          }\n\n          break;\n\n        case 1:\n          point = 2;\n\n          if (_this._closed) {\n            x3 = x;\n            y3 = y;\n          }\n\n          break;\n\n        case 2:\n          point = 3;\n\n          if (_this._closed) {\n            x4 = x;\n            y4 = y;\n            output += $path.moveTo({\n              x: (x0 + 4 * x1 + x) / 6,\n              y: (y0 + 4 * y1 + y) / 6\n            });\n            break;\n          } else {\n            output += $path.lineTo({\n              x: (5 * x0 + x1) / 6,\n              y: (5 * y0 + y1) / 6\n            }); // fall-through\n          }\n\n        default:\n          pushCurve(x, y);\n          break;\n      }\n\n      x0 = x1;\n      x1 = x;\n      y0 = y1;\n      y1 = y;\n    };\n\n    $array.each(points, pushPoint);\n\n    if (this._closed) {\n      switch (point) {\n        case 1:\n          output += $path.moveTo({\n            x: x2,\n            y: y2\n          });\n          output += $path.closePath();\n          break;\n\n        case 2:\n          output += $path.moveTo({\n            x: (x2 + 2 * x3) / 3,\n            y: (y2 + 2 * y3) / 3\n          });\n          output += $path.lineTo({\n            x: (x3 + 2 * x2) / 3,\n            y: (y3 + 2 * y2) / 3\n          });\n          output += $path.closePath();\n          break;\n\n        case 3:\n          pushPoint({\n            x: x2,\n            y: y2\n          });\n          pushPoint({\n            x: x3,\n            y: y3\n          });\n          pushPoint({\n            x: x4,\n            y: y4\n          });\n          break;\n      }\n    } else {\n      switch (point) {\n        case 3:\n          pushCurve(x1, y1);\n        // fall-through\n\n        case 2:\n          output += $path.lineTo({\n            x: x1,\n            y: y1\n          });\n          break;\n      }\n\n      output += $path.closePath();\n    }\n\n    return output;\n  };\n\n  return Basis;\n}();\n\nexport { Basis };","map":{"version":3,"sources":["../../../../../src/.internal/core/rendering/Smoothing.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\nimport { registry } from \"../Registry\";\nimport * as $path from \"./Path\";\nimport * as $array from \"../utils/Array\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $math from \"../utils/Math\";\nimport { IPoint } from \"../defs/IPoint\";\n\n\n/**\n * ============================================================================\n * PATH FUNCTIONS\n * ============================================================================\n * @hidden\n */\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport interface ISmoothing {\n\tsmooth(points: Array<IPoint>): string;\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport class Tension implements ISmoothing {\n\n\t/**\n\t * [_tensionX description]\n\t *\n\t * @todo Description\n\t */\n\tprivate _tensionX: number;\n\n\t/**\n\t * [_tensionY description]\n\t *\n\t * @todo Description\n\t */\n\tprivate _tensionY: number;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @param tensionX [description]\n\t * @param tensionY [description]\n\t */\n\tconstructor(tensionX: number, tensionY: number) {\n\t\tthis._tensionX = tensionX;\n\t\tthis._tensionY = tensionY;\n\t}\n\n\t/**\n\t * [smooth description]\n\t *\n\t * @ignore Exclude from docs\n\t * @todo Description\n\t * @param points  [description]\n\t * @return [description]\n\t */\n\tpublic smooth(points: Array<IPoint>): string {\n\n\t\tfor (let i = points.length - 1; i > 0; i--) {\n\t\t\tlet p0 = points[i];\n\t\t\tlet p1 = points[i - 1];\n\n\t\t\tif (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n\t\t\t\tpoints.splice(i - 1, 1);\n\t\t\t}\n\t\t}\n\n\n\t\tlet tensionX = this._tensionX;\n\t\tlet tensionY = this._tensionY;\n\n\t\tif (points.length < 3 || (tensionX >= 1 && tensionY >= 1)) {\n\t\t\treturn $path.polyline(points);\n\t\t}\n\n\t\tlet first: IPoint = points[0];\n\t\tlet last: IPoint = points[points.length - 1];\n\n\t\tlet closed: boolean = false;\n\n\t\tif ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n\t\t\tclosed = true;\n\t\t}\n\n\t\t// Can't moveTo here, as it wont be possible to have fill then.\n\t\tlet path: string = \"\";\n\n\t\tfor (let i = 0, len = points.length - 1; i < len; i++) {\n\t\t\tlet p0: IPoint = points[i - 1];\n\n\t\t\tlet p1: IPoint = points[i];\n\n\t\t\tlet p2: IPoint = points[i + 1];\n\n\t\t\tlet p3: IPoint = points[i + 2];\n\n\t\t\tif (i === 0) {\n\t\t\t\tif (closed) {\n\t\t\t\t\tp0 = points[points.length - 2];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tp0 = points[i];\n\t\t\t\t}\n\t\t\t} else if (i == points.length - 2) {\n\t\t\t\tif (closed) {\n\t\t\t\t\tp3 = points[1];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tp3 = points[i + 1];\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tlet controlPointA: IPoint = $math.getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY);\n\t\t\tlet controlPointB: IPoint = $math.getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY);\n\n\t\t\tpath += $path.cubicCurveTo(p2, controlPointA, controlPointB);\n\t\t}\n\n\t\treturn path;\n\t}\n}\n\n\n/**\n * Returns a waved line SVG path between two points.\n *\n * @ignore Exclude from docs\n * @param point1            Starting point\n * @param point2            Ending point\n * @param waveLength        Wave length\n * @param waveHeight        Wave height\n * @param adjustWaveLength  Adjust wave length based on the actual line length\n * @return SVG path\n */\nexport function wavedLine(point1: IPoint, point2: IPoint, waveLength: number, waveHeight: number, tension: number, adjustWaveLength?: boolean): string {\n\n\tlet x1: number = point1.x;\n\tlet y1: number = point1.y;\n\n\tlet x2: number = point2.x;\n\tlet y2: number = point2.y;\n\n\tlet distance: number = $math.getDistance(point1, point2);\n\n\tif (adjustWaveLength) {\n\t\twaveLength = distance / Math.round(distance / waveLength);\n\t}\n\n\tlet d: string = registry.getCache($utils.stringify([\"wavedLine\", point1.x, point2.x, point1.y, point2.y, waveLength, waveHeight]));\n\tif (!d) {\n\t\tif (distance > 0) {\n\t\t\tlet angle: number = Math.atan2(y2 - y1, x2 - x1);\n\n\t\t\tlet cos: number = Math.cos(angle);\n\t\t\tlet sin: number = Math.sin(angle);\n\n\t\t\tlet waveLengthX: number = waveLength * cos;\n\t\t\tlet waveLengthY: number = waveLength * sin;\n\n\t\t\tif (waveLength <= 1 || waveHeight <= 1) {\n\t\t\t\td = $path.lineTo(point2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet halfWaveCount: number = Math.round(2 * distance / waveLength);\n\n\t\t\t\tlet points: IPoint[] = [];\n\t\t\t\tlet sign: number = 1;\n\n\t\t\t\tif (x2 < x1) {\n\t\t\t\t\tsign *= -1;\n\t\t\t\t}\n\n\t\t\t\tif (y2 < y1) {\n\t\t\t\t\tsign *= -1;\n\t\t\t\t}\n\n\t\t\t\tfor (let i: number = 0; i <= halfWaveCount; i++) {\n\t\t\t\t\tsign *= -1;\n\t\t\t\t\tlet x: number = x1 + i * waveLengthX / 2 + sign * waveHeight / 2 * sin;\n\t\t\t\t\tlet y: number = y1 + i * waveLengthY / 2 - sign * waveHeight / 2 * cos;\n\t\t\t\t\tpoints.push({ x: x, y: y });\n\t\t\t\t}\n\n\t\t\t\td = new Tension(tension, tension).smooth(points);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\td = \"\";\n\t\t}\n\n\t\tregistry.setCache($utils.stringify([\"wavedLine\", point1.x, point2.x, point1.y, point2.y, waveLength, waveHeight]), d);\n\t}\n\n\treturn d;\n}\n\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport class Basis implements ISmoothing {\n\n\t/**\n\t * [_closed description]\n\t *\n\t * @ignore Exclude from docs\n\t * @todo Description\n\t */\n\tprivate _closed: boolean;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @param info  [description]\n\t */\n\tconstructor(info: { closed: boolean }) {\n\t\tthis._closed = info.closed;\n\t}\n\n\t/**\n\t * [smooth description]\n\t *\n\t * @ignore Exclude from docs\n\t * @todo Description\n\t * @param points  [description]\n\t * @return [description]\n\t */\n\tpublic smooth(points: Array<IPoint>): string {\n\t\tlet x0: number = NaN;\n\t\tlet x1: number = NaN;\n\t\tlet x2: number = NaN;\n\t\tlet x3: number = NaN;\n\t\tlet x4: number = NaN;\n\t\tlet y0: number = NaN;\n\t\tlet y1: number = NaN;\n\t\tlet y2: number = NaN;\n\t\tlet y3: number = NaN;\n\t\tlet y4: number = NaN;\n\t\tlet point: number = 0;\n\n\t\tlet output = \"\";\n\n\t\tconst pushCurve = (x: number, y: number): void => {\n\t\t\toutput += $path.cubicCurveTo(\n\t\t\t\t{\n\t\t\t\t\tx: (x0 + 4 * x1 + x) / 6\n\t\t\t\t\t, y: (y0 + 4 * y1 + y) / 6\n\t\t\t\t},\n\n\t\t\t\t{\n\t\t\t\t\tx: (2 * x0 + x1) / 3\n\t\t\t\t\t, y: (2 * y0 + y1) / 3\n\t\t\t\t},\n\n\t\t\t\t{\n\t\t\t\t\tx: (x0 + 2 * x1) / 3\n\t\t\t\t\t, y: (y0 + 2 * y1) / 3\n\t\t\t\t}\n\t\t\t);\n\t\t};\n\n\t\tconst pushPoint = ({ x, y }: IPoint): void => {\n\t\t\tswitch (point) {\n\t\t\t\tcase 0:\n\t\t\t\t\tpoint = 1;\n\n\t\t\t\t\tif (this._closed) {\n\t\t\t\t\t\tx2 = x;\n\t\t\t\t\t\ty2 = y;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput += $path.lineTo({ x, y });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tpoint = 2;\n\n\t\t\t\t\tif (this._closed) {\n\t\t\t\t\t\tx3 = x;\n\t\t\t\t\t\ty3 = y;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tpoint = 3;\n\n\t\t\t\t\tif (this._closed) {\n\t\t\t\t\t\tx4 = x;\n\t\t\t\t\t\ty4 = y;\n\t\t\t\t\t\toutput += $path.moveTo({ x: (x0 + 4 * x1 + x) / 6, y: (y0 + 4 * y1 + y) / 6 });\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput += $path.lineTo({ x: (5 * x0 + x1) / 6, y: (5 * y0 + y1) / 6 });\n\t\t\t\t\t\t// fall-through\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tpushCurve(x, y);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tx0 = x1;\n\t\t\tx1 = x;\n\t\t\ty0 = y1;\n\t\t\ty1 = y;\n\t\t};\n\n\t\t$array.each(points, pushPoint);\n\n\t\tif (this._closed) {\n\t\t\tswitch (point) {\n\t\t\t\tcase 1:\n\t\t\t\t\toutput += $path.moveTo({ x: x2, y: y2 });\n\t\t\t\t\toutput += $path.closePath();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\toutput += $path.moveTo({ x: (x2 + 2 * x3) / 3, y: (y2 + 2 * y3) / 3 });\n\t\t\t\t\toutput += $path.lineTo({ x: (x3 + 2 * x2) / 3, y: (y3 + 2 * y2) / 3 });\n\t\t\t\t\toutput += $path.closePath();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tpushPoint({ x: x2, y: y2 });\n\t\t\t\t\tpushPoint({ x: x3, y: y3 });\n\t\t\t\t\tpushPoint({ x: x4, y: y4 });\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tswitch (point) {\n\t\t\t\tcase 3:\n\t\t\t\t\tpushCurve(x1, y1);\n\t\t\t\t// fall-through\n\t\t\t\tcase 2:\n\t\t\t\t\toutput += $path.lineTo({ x: x1, y: y1 });\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toutput += $path.closePath();\n\t\t}\n\n\t\treturn output;\n\t}\n\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}