{"ast":null,"code":"/**\r\n * ChordNode module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { FlowDiagramNode } from \"./FlowDiagramNode\";\nimport { AxisLabelCircular } from \"../axes/AxisLabelCircular\";\nimport { registry } from \"../../core/Registry\";\nimport { Slice } from \"../../core/elements/Slice\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport { Bullet } from \"../elements/Bullet\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Creates a node in a Chord Diagram.\r\n *\r\n * A Chord node is a block with a value, which represents its size on the\r\n * diagram.\r\n *\r\n * Nodes are connected via [[ChordLink]] elements.\r\n *\r\n * @see {@link IChordNodeEvents} for a list of available events\r\n * @see {@link IChordNodeAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar ChordNode =\n/** @class */\nfunction (_super) {\n  __extends(ChordNode, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function ChordNode() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"ChordNode\";\n\n    var label = _this.createChild(AxisLabelCircular);\n\n    label.location = 0.5;\n    label.radius = 5;\n    label.text = \"{name}\";\n    label.zIndex = 1;\n    label.shouldClone = false;\n    _this.label = label;\n    _this.layout = \"none\";\n\n    _this.events.on(\"positionchanged\", _this.updateRotation, _this, false);\n\n    _this.isMeasured = false;\n    _this.slice = _this.createChild(Slice);\n    _this.slice.isMeasured = false;\n    var hiddenState = _this.hiddenState;\n    hiddenState.properties.fill = new InterfaceColorSet().getFor(\"disabledBackground\");\n    hiddenState.properties.opacity = 0.5;\n    hiddenState.properties.visible = true;\n    _this.setStateOnChildren = false;\n    _this.slice.hiddenState.properties.visible = true;\n\n    _this.adapter.add(\"tooltipX\", function (tooltipX, target) {\n      return target.slice.ix * (target.slice.radius - (target.slice.radius - target.slice.pixelInnerRadius) / 2);\n    });\n\n    _this.adapter.add(\"tooltipY\", function (tooltipY, target) {\n      return target.slice.iy * (target.slice.radius - (target.slice.radius - target.slice.pixelInnerRadius) / 2);\n    });\n\n    return _this;\n  }\n  /**\r\n   * Invalidates all links, attached to this node.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  ChordNode.prototype.invalidateLinks = function () {\n    var _this = this;\n\n    _super.prototype.invalidateLinks.call(this);\n\n    var label = this.label;\n    var slice = this.slice;\n    var chart = this.chart;\n\n    if (chart && slice) {\n      var sum = this.total;\n      var arc_1 = slice.arc;\n      var sliceStartAngle_1 = slice.startAngle;\n      this.children.each(function (child) {\n        if (child instanceof Bullet) {\n          var locationX = child.locationX;\n\n          if (!$type.isNumber(locationX)) {\n            locationX = 0.5;\n          }\n\n          var locationY = child.locationY;\n\n          if (!$type.isNumber(locationY)) {\n            locationY = 1;\n          }\n\n          var childAngle = sliceStartAngle_1 + arc_1 * locationX;\n          var childRadius = locationY * slice.radius;\n          child.x = childRadius * $math.cos(childAngle);\n          child.y = childRadius * $math.sin(childAngle);\n        }\n      });\n      var labelAngle = sliceStartAngle_1 + arc_1 * label.location;\n      var startAngle = sliceStartAngle_1 + (1 - sum / this.adjustedTotal) * arc_1 * 0.5; // if value of a node is > then sum of the links, add to center link\n\n      if ($type.isNaN(startAngle)) {\n        startAngle = sliceStartAngle_1;\n      }\n\n      label.fixPosition(labelAngle, slice.radius);\n      this.nextAngle = startAngle;\n\n      if (this._outgoingSorted) {\n        $iter.each(this._outgoingSorted, function (dataItem) {\n          var link = dataItem.link;\n          link.parent = _this.chart.linksContainer;\n          var value = dataItem.getWorkingValue(\"value\");\n\n          if ($type.isNumber(value)) {\n            if (chart.nonRibbon) {\n              var percentWidth = link.percentWidth;\n\n              if (!$type.isNumber(percentWidth)) {\n                percentWidth = 5;\n              }\n\n              percentWidth = percentWidth / 100;\n              link.startAngle = sliceStartAngle_1 + arc_1 / 2 - arc_1 / 2 * percentWidth;\n              link.arc = arc_1 * percentWidth;\n            } else {\n              link.arc = value * chart.valueAngle;\n              link.startAngle = _this.nextAngle;\n              _this.nextAngle += link.arc;\n            }\n\n            if (!dataItem.toNode) {\n              link.endAngle = link.startAngle;\n            }\n\n            link.radius = slice.pixelInnerRadius;\n          } //link.validate();\n\n        });\n      }\n\n      if (this._incomingSorted) {\n        $iter.each(this._incomingSorted, function (dataItem) {\n          var link = dataItem.link;\n          link.radius = slice.pixelInnerRadius;\n\n          if (chart.nonRibbon) {\n            var percentWidth = link.percentWidth;\n\n            if (!$type.isNumber(percentWidth)) {\n              percentWidth = 5;\n            }\n\n            percentWidth = percentWidth / 100;\n            link.endAngle = sliceStartAngle_1 + arc_1 / 2 - arc_1 / 2 * percentWidth;\n            link.arc = arc_1 * percentWidth;\n          } else {\n            link.endAngle = _this.nextAngle;\n            var value = dataItem.getWorkingValue(\"value\");\n\n            if ($type.isNumber(value)) {\n              link.arc = value * chart.valueAngle; // yes, this is needed\n\n              _this.nextAngle += link.arc;\n            }\n          }\n\n          if (!dataItem.fromNode) {\n            link.startAngle = link.endAngle;\n          } //link.validate();\n\n        });\n      }\n    }\n  };\n  /**\r\n   * @ignore\r\n   * updates slice start angle so that when we drag a node it would face the center\r\n   */\n\n\n  ChordNode.prototype.updateRotation = function () {\n    var slice = this.slice;\n    var mAngle = this.trueStartAngle + slice.arc / 2;\n    var radius = slice.radius;\n    var tx = radius * $math.cos(mAngle);\n    var ty = radius * $math.sin(mAngle);\n    var angle = $math.getAngle({\n      x: tx + this.pixelX,\n      y: ty + this.pixelY\n    });\n    slice.startAngle = this.trueStartAngle + (angle - mAngle);\n    this.dx = -this.pixelX;\n    this.dy = -this.pixelY;\n  };\n  /**\r\n   * Copies properties and labels from another [[ChordNode]].\r\n   *\r\n   * @param source  Source node\r\n   */\n\n\n  ChordNode.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.label.copyFrom(source.label);\n    this.slice.copyFrom(source.slice);\n  };\n\n  return ChordNode;\n}(FlowDiagramNode);\n\nexport { ChordNode };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"ChordNode\"] = ChordNode;","map":{"version":3,"sources":["../../../../../src/.internal/charts/elements/ChordNode.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * ChordNode module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { FlowDiagramNode, IFlowDiagramNodeAdapters, IFlowDiagramNodeEvents, IFlowDiagramNodeProperties } from \"./FlowDiagramNode\";\r\nimport { ChordDiagram, ChordDiagramDataItem } from \"../types/ChordDiagram\";\r\nimport { List } from \"../../core/utils/List\";\r\nimport { AxisLabelCircular } from \"../axes/AxisLabelCircular\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { Slice } from \"../../core/elements/Slice\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport { Bullet } from \"../elements/Bullet\";\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[ChordNode]].\r\n */\r\nexport interface IChordNodeProperties extends IFlowDiagramNodeProperties { }\r\n\r\n/**\r\n * Defines events for [[ChordNode]].\r\n */\r\nexport interface IChordNodeEvents extends IFlowDiagramNodeEvents { }\r\n\r\n/**\r\n * Defines adapters for [[ChordNode]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IChordNodeAdapters extends IFlowDiagramNodeAdapters, IChordNodeProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Creates a node in a Chord Diagram.\r\n *\r\n * A Chord node is a block with a value, which represents its size on the\r\n * diagram.\r\n *\r\n * Nodes are connected via [[ChordLink]] elements.\r\n *\r\n * @see {@link IChordNodeEvents} for a list of available events\r\n * @see {@link IChordNodeAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class ChordNode extends FlowDiagramNode {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IChordNodeProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IChordNodeAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IChordNodeEvents;\r\n\r\n\t/**\r\n\t * A list of data items of the items coming in from another node, one level\r\n\t * up.\r\n\t *\r\n\t * These are what ingoing links are build out of.\r\n\t */\r\n\tprotected _incomingDataItems: List<ChordDiagramDataItem>;\r\n\r\n\t/**\r\n\t * A list of data items of the items going out of the node.\r\n\t *\r\n\t * These are what outgoing links are build out of.\r\n\t */\r\n\tprotected _outgoingDataItems: List<ChordDiagramDataItem>;\r\n\r\n\t/**\r\n\t * Sorted list of incoming items.\r\n\t */\r\n\tprotected _incomingSorted: $iter.Iterator<ChordDiagramDataItem>;\r\n\r\n\t/**\r\n\t * Sorted list of outgoing items.\r\n\t */\r\n\tprotected _outgoingSorted: $iter.Iterator<ChordDiagramDataItem>;\r\n\r\n\t/**\r\n\t * A chart instance this node is added to.\r\n\t */\r\n\tpublic chart: ChordDiagram;\r\n\r\n\r\n\t/**\r\n\t * Defines the type of the [[ChordDiagramDataItem]] used in the class.\r\n\t */\r\n\tpublic _dataItem: ChordDiagramDataItem;\r\n\r\n\r\n\t/**\r\n\t * Slice sprite of a node\r\n\t */\r\n\tpublic slice: Slice;\r\n\r\n\t/**\r\n\t * A label element which shows node's name.\r\n\t */\r\n\tpublic label: AxisLabelCircular;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic nextAngle: number;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic trueStartAngle: number;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"ChordNode\";\r\n\r\n\t\tlet label = this.createChild(AxisLabelCircular);\r\n\t\tlabel.location = 0.5;\r\n\t\tlabel.radius = 5;\r\n\t\tlabel.text = \"{name}\";\r\n\t\tlabel.zIndex = 1;\r\n\t\tlabel.shouldClone = false;\r\n\t\tthis.label = label;\r\n\r\n\t\tthis.layout = \"none\";\r\n\r\n\t\tthis.events.on(\"positionchanged\", this.updateRotation, this, false);\r\n\r\n\t\tthis.isMeasured = false;\r\n\t\tthis.slice = this.createChild(Slice);\r\n\t\tthis.slice.isMeasured = false;\r\n\r\n\t\tlet hiddenState = this.hiddenState;\r\n\t\thiddenState.properties.fill = new InterfaceColorSet().getFor(\"disabledBackground\");\r\n\t\thiddenState.properties.opacity = 0.5;\r\n\t\thiddenState.properties.visible = true;\r\n\r\n\t\tthis.setStateOnChildren = false;\r\n\r\n\t\tthis.slice.hiddenState.properties.visible = true;\r\n\r\n\t\tthis.adapter.add(\"tooltipX\", (tooltipX, target)=>{\r\n\t\t    return target.slice.ix * (target.slice.radius - (target.slice.radius - target.slice.pixelInnerRadius) / 2);\r\n\t\t})\r\n\r\n\t\tthis.adapter.add(\"tooltipY\", (tooltipY, target)=>{\r\n\t\t    return target.slice.iy * (target.slice.radius - (target.slice.radius - target.slice.pixelInnerRadius) / 2);\r\n\t\t})\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Invalidates all links, attached to this node.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidateLinks(): void {\r\n\t\tsuper.invalidateLinks();\r\n\r\n\t\tlet label = this.label;\r\n\t\tlet slice = this.slice;\r\n\t\tlet chart = this.chart;\r\n\t\tif (chart && slice) {\r\n\r\n\t\t\tlet sum = this.total;\r\n\t\t\tlet arc = slice.arc;\r\n\t\t\tlet sliceStartAngle = slice.startAngle;\r\n\r\n\t\t\tthis.children.each((child) => {\r\n\t\t\t\tif (child instanceof Bullet) {\r\n\t\t\t\t\tlet locationX = child.locationX;\r\n\t\t\t\t\tif (!$type.isNumber(locationX)) {\r\n\t\t\t\t\t\tlocationX = 0.5;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet locationY = child.locationY;\r\n\t\t\t\t\tif (!$type.isNumber(locationY)) {\r\n\t\t\t\t\t\tlocationY = 1;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet childAngle = sliceStartAngle + arc * locationX;\r\n\t\t\t\t\tlet childRadius = locationY * slice.radius;\r\n\r\n\t\t\t\t\tchild.x = childRadius * $math.cos(childAngle);\r\n\t\t\t\t\tchild.y = childRadius * $math.sin(childAngle);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\r\n\t\t\tlet labelAngle = sliceStartAngle + arc * label.location;\r\n\t\t\tlet startAngle = sliceStartAngle + (1 - sum / this.adjustedTotal) * arc * 0.5; // if value of a node is > then sum of the links, add to center link\r\n\r\n\t\t\tif ($type.isNaN(startAngle)) {\r\n\t\t\t\tstartAngle = sliceStartAngle;\r\n\t\t\t}\r\n\r\n\t\t\tlabel.fixPosition(labelAngle, slice.radius);\r\n\r\n\t\t\tthis.nextAngle = startAngle;\r\n\r\n\t\t\tif (this._outgoingSorted) {\r\n\r\n\t\t\t\t$iter.each(this._outgoingSorted, (dataItem) => {\r\n\t\t\t\t\tlet link = dataItem.link;\r\n\t\t\t\t\tlink.parent = this.chart.linksContainer;\r\n\t\t\t\t\tlet value = dataItem.getWorkingValue(\"value\");\r\n\r\n\t\t\t\t\tif ($type.isNumber(value)) {\r\n\r\n\t\t\t\t\t\tif (chart.nonRibbon) {\r\n\t\t\t\t\t\t\tlet percentWidth = link.percentWidth;\r\n\t\t\t\t\t\t\tif (!$type.isNumber(percentWidth)) {\r\n\t\t\t\t\t\t\t\tpercentWidth = 5;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tpercentWidth = percentWidth / 100;\r\n\r\n\t\t\t\t\t\t\tlink.startAngle = sliceStartAngle + arc / 2 - arc / 2 * percentWidth;\r\n\t\t\t\t\t\t\tlink.arc = arc * percentWidth;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tlink.arc = value * chart.valueAngle;\r\n\t\t\t\t\t\t\tlink.startAngle = this.nextAngle;\r\n\t\t\t\t\t\t\tthis.nextAngle += link.arc;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!dataItem.toNode) {\r\n\t\t\t\t\t\t\tlink.endAngle = link.startAngle;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlink.radius = slice.pixelInnerRadius;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//link.validate();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (this._incomingSorted) {\r\n\t\t\t\t$iter.each(this._incomingSorted, (dataItem) => {\r\n\t\t\t\t\tlet link = dataItem.link;\r\n\r\n\t\t\t\t\tlink.radius = slice.pixelInnerRadius;\r\n\r\n\t\t\t\t\tif (chart.nonRibbon) {\r\n\t\t\t\t\t\tlet percentWidth = link.percentWidth;\r\n\t\t\t\t\t\tif (!$type.isNumber(percentWidth)) {\r\n\t\t\t\t\t\t\tpercentWidth = 5;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tpercentWidth = percentWidth / 100;\r\n\r\n\t\t\t\t\t\tlink.endAngle = sliceStartAngle + arc / 2 - arc / 2 * percentWidth;\r\n\t\t\t\t\t\tlink.arc = arc * percentWidth;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tlink.endAngle = this.nextAngle;\r\n\t\t\t\t\t\tlet value = dataItem.getWorkingValue(\"value\");\r\n\t\t\t\t\t\tif ($type.isNumber(value)) {\r\n\t\t\t\t\t\t\tlink.arc = value * chart.valueAngle; // yes, this is needed\r\n\t\t\t\t\t\t\tthis.nextAngle += link.arc;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!dataItem.fromNode) {\r\n\t\t\t\t\t\tlink.startAngle = link.endAngle;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//link.validate();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t * updates slice start angle so that when we drag a node it would face the center\r\n\t */\r\n\tprotected updateRotation() {\r\n\t\tlet slice = this.slice;\r\n\t\tlet mAngle = this.trueStartAngle + slice.arc / 2;\r\n\t\tlet radius = slice.radius;\r\n\r\n\t\tlet tx = radius * $math.cos(mAngle);\r\n\t\tlet ty = radius * $math.sin(mAngle);\r\n\r\n\t\tlet angle = $math.getAngle({ x: tx + this.pixelX, y: ty + this.pixelY });\r\n\r\n\t\tslice.startAngle = this.trueStartAngle + (angle - mAngle);\r\n\r\n\t\tthis.dx = - this.pixelX;\r\n\t\tthis.dy = - this.pixelY;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Copies properties and labels from another [[ChordNode]].\r\n\t *\r\n\t * @param source  Source node\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tsuper.copyFrom(source);\r\n\t\tthis.label.copyFrom(source.label);\r\n\t\tthis.slice.copyFrom(source.slice);\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"ChordNode\"] = ChordNode;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}