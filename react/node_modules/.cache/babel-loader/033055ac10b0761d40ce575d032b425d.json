{"ast":null,"code":"/**\r\n * Text class deals with all text placed on chart.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../Container\";\nimport { registry } from \"../Registry\";\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\nimport { MultiDisposer } from \"../utils/Disposer\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport * as $math from \"../utils/Math\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\nimport * as $dom from \"../utils/DOM\";\nimport { defaultRules, ResponsiveBreakpoints } from \"../utils/Responsive\";\n;\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Text is used to display highly configurable, data-enabled textual elements.\r\n *\r\n * ## Data Binding\r\n *\r\n * A Text element can dynamically parse and populate its contents with values\r\n * from a [[DataItem]].\r\n *\r\n * To activate such binding, set element's `dataItem` property.\r\n *\r\n * When activated, text contents will be parsed for special tags, e.g.:\r\n *\r\n * ```TypeScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n * ```JavaScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n *\r\n * The above will automatically replace \"{title}\" in the string with the\r\n * actual data value from `myDataItem`.\r\n *\r\n * Note, that most often dataItem is set by the Component.\r\n *\r\n *\r\n * @see {@link ILabelEvents} for a list of available events\r\n * @see {@link ILabelAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/} for info on string formatting and data binding\r\n * @todo Vertical align\r\n * @important\r\n */\n\nvar Label =\n/** @class */\nfunction (_super) {\n  __extends(Label, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Label() {\n    var _this = // Execute super's constructor\n    _super.call(this) || this;\n    /**\r\n     * Indicates if the whole text does not fit into max dimenstions set for it.\r\n     */\n\n\n    _this.isOversized = false; // Set this class name\n\n    _this.className = \"Label\";\n    _this.fill = new InterfaceColorSet().getFor(\"text\"); // not good to set this, as then these will appear on each label and values set on container won't be applied.\n    //this.textDecoration = \"none\";\n    //this.fontWeight = \"normal\";\n    // Set defaults\n\n    _this.wrap = false;\n    _this.truncate = false;\n    _this.fullWords = true;\n    _this.ellipsis = \"â€¦\";\n    _this.textAlign = \"start\";\n    _this.textValign = \"top\";\n    _this.layout = \"absolute\";\n    _this.baseLineRatio = -0.27; //this.pixelPerfect = true;\n\n    _this._positionPrecision = 1; // Add events to watch for maxWidth/maxHeight changes so that we can\n    // invalidate this\n\n    _this.events.on(\"maxsizechanged\", function () {\n      if (_this.inited) {\n        _this.handleMaxSize();\n      }\n    }, _this, false); // this solves strange bug when text just added to svg is 0x0\n\n\n    _this.events.once(\"validated\", _this.handleValidate, _this, false); // Aply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * A placeholder method that is called **after** element finishes drawing\r\n   * itself.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.afterDraw = function () {\n    // since we removed validatePosition from sprite, we still need it here to handle rotated text\n    _super.prototype.afterDraw.call(this);\n\n    this.validatePosition();\n  };\n  /**\r\n   * Sets [[Paper]] instance to use to draw elements.\r\n   * @ignore\r\n   * @param paper Paper\r\n   * @return true if paper was changed, false, if it's the same\r\n   */\n\n\n  Label.prototype.setPaper = function (paper) {\n    var changed = _super.prototype.setPaper.call(this, paper);\n\n    if (changed) {\n      this.hardInvalidate();\n    }\n\n    return changed;\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Label.prototype.handleValidate = function () {\n    if ((this.currentText || this.text) && (this.bbox.width == 0 || this.bbox.height == 0)) {\n      registry.events.once(\"exitframe\", this.hardInvalidate, this);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Label.prototype.handleMaxSize = function () {\n    if (this.bbox.width > this.availableWidth || this.bbox.width < this.availableWidth && (this.isOversized || this.truncate) || this.bbox.height > this.availableHeight || this.bbox.height < this.availableHeight && this.isOversized) {\n      this.invalidate();\n    } else {\n      this.alignSVGText();\n    }\n  };\n  /**\r\n   * [arrange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  Label.prototype.arrange = function () {};\n  /**\r\n   * Updates current text according to data item and supported features.\r\n   * Returns `true` if current text has changed.\r\n   *\r\n   * @return Text changed?\r\n   */\n\n\n  Label.prototype.updateCurrentText = function () {\n    // Determine output format\n    var output, text;\n\n    if ($utils.isNotEmpty(this.html) && this.paper.supportsForeignObject()) {\n      // We favor HTML text if it's set and browser supports `foreignObject`\n      output = \"html\";\n      text = this.html;\n    } else {\n      output = \"svg\";\n      text = this.text;\n    } // Need to toString source?\n\n\n    if ($type.isObject(text)) {\n      text = text.toString();\n    } // Need to format text all the time\n\n\n    if ($type.hasValue(text) && text !== \"\") {\n      text = this.populateString(text, this.dataItem);\n    }\n\n    if (output == \"html\") {\n      if (this._adapterO) {\n        text = this._adapterO.apply(\"htmlOutput\", text);\n      }\n    } else {\n      if (this._adapterO) {\n        text = this._adapterO.apply(\"textOutput\", text);\n      }\n    } // Update the text\n\n\n    var changed = text != this.currentText || output != this._currentFormat;\n    this.currentText = text;\n    this._currentFormat = output;\n    return changed;\n  };\n  /**\r\n   * Hard invalidate means the text will be redrawn even if it hasn't changed.\r\n   * This is used when we change `fontSize`, `fontFamily`, or for some other\r\n   * reasons.\r\n   */\n\n\n  Label.prototype.hardInvalidate = function () {\n    this._prevStatus = \"\";\n    this.invalidate();\n  };\n  /**\r\n   * Gets line bbox, uses caching to save cpu\r\n   * @ignore\r\n   */\n\n\n  Label.prototype.getLineBBox = function (lineInfo) {\n    //let cacheKey = lineInfo.text + lineInfo.style;\n    //let lineBBox = this.getCache(cacheKey);\n    //if (!lineBBox) {\n    //lineBBox = lineInfo.element.getBBox();\n    //if (lineBBox.width != 0 && lineBBox.height != 0) {\n    //\tthis.setCache(cacheKey, lineBBox, 5000);\n    //}\n    //}\n    var element = lineInfo && lineInfo.element;\n    var node = element && element.node; // Check for the parent Node to avoid FF from throwing errors\n\n    if (node && node.parentNode) {\n      lineInfo.bbox = element.getBBox();\n    }\n  };\n  /**\r\n   * Draws the textual label.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.draw = function () {\n    // Draw super\n    _super.prototype.draw.call(this);\n\n    var oldW = this.bbox.width;\n    var oldH = this.bbox.height;\n    var topParent = this.topParent;\n\n    if (topParent) {\n      if (!topParent.maxWidth || !topParent.maxHeight) {\n        topParent.events.once(\"maxsizechanged\", this.hardInvalidate, this, false);\n        return;\n      }\n    } // Calculate max width and height\n\n\n    var maxWidth = $math.max(this.availableWidth - this.pixelPaddingLeft - this.pixelPaddingRight, 0);\n    var maxHeight = $math.max(this.availableHeight - this.pixelPaddingTop - this.pixelPaddingBottom, 0); // save\n\n    var status = maxHeight + \",\" + maxWidth + this.wrap + this.truncate + this.fullWords + this.rtl + this.ellipsis; // Update text\n\n    if (!this.updateCurrentText() && this.inited && this._prevStatus == status) {\n      return;\n    }\n\n    this._measuredWidth = 0;\n    this._measuredHeight = 0; // Reset\n\n    this.isOversized = false; // Determine output format\n\n    var output = this._currentFormat;\n    var text = this.currentText; // Empty string\n\n    if (!$type.hasValue(text) || text == \"\") {\n      this.element.attr({\n        display: \"none\"\n      });\n      return;\n    } // Chop up text into lines\n    // We're still processing SVG and HTML in the same way for now\n\n\n    var lines = text.split(\"\\n\"); // Do we need to go through the trouble of measuring lines\n    //let measure: boolean = true;// (lines.length > 1) || this.wrap;\n\n    this._prevStatus = status;\n    this.textAlign = this.textAlign; // need this to measure\n\n    var display = this.group.getAttr(\"display\");\n\n    if (display == \"none\") {\n      this.group.removeAttr(\"display\");\n    }\n\n    if (this.textPathElement) {\n      this.textPathElement.removeChildren();\n    } // SVG or HTML?\n\n\n    if (output === \"svg\") {\n      /**\r\n       * SVG\r\n       */\n      this.element.removeAttr(\"display\"); // Clear the element\n\n      var group = this.element;\n      this.resetBBox(); // Init state variables\n\n      var currentHeight = 0;\n      var currentFormat = \"\"; // Process each line\n\n      for (var i = 0; i < lines.length; i++) {\n        // Get line\n        var line = lines[i]; // Check if line is empty\n\n        if (line == \"\") {\n          // It is, let's just update currentHeight and go to the next one\n          // If it's the first line, we'll have to use arbirary line height,\n          // since there's nothing to measure. For subsequent lines we can take\n          // previous line's height\n          var tempElement = this.getSVGLineElement(\"\", 0);\n          tempElement.add(this.getSvgElement(\".\", getTextFormatter().translateStyleShortcuts(currentFormat)));\n          group.add(tempElement);\n          var offset = Math.ceil(tempElement.getBBox().height);\n\n          if (offset > 0) {\n            currentHeight += offset;\n          }\n\n          group.removeElement(tempElement); // Clear cache if necessary\n\n          var lineInfo_1 = this.getLineInfo(i);\n\n          if (lineInfo_1) {\n            lineInfo_1.text = \"\";\n            lineInfo_1.element.textContent = \"\";\n          }\n\n          continue;\n        } // Chunk up the line and process each chunk\n\n\n        var chunks = getTextFormatter().chunk(line, null, this.ignoreFormatting);\n        var currentLineHeight = 0;\n        var firstChunk = true;\n        var skipTextChunks = false; // Create line element or grab it from cache\n\n        var lineInfo = this.getLineInfo(i);\n\n        if (lineInfo) {\n          // Empty line\n          lineInfo.text = \"\";\n          lineInfo.element.textContent = \"\";\n        } else {\n          // Init new line info\n          lineInfo = {\n            \"text\": \"\",\n            \"element\": this.getSVGLineElement(\"\", 0),\n            \"complex\": false\n          }; // Create the line element\n          //lineInfo.element = this.getSVGLineElement(\"\", 0);\n          //lineElement = this.getSVGLineElement(\"\", 0);\n\n          group.add(lineInfo.element);\n        }\n\n        lineInfo.element.removeAttr(\"display\");\n        lineInfo.element.removeChildren(); // memory leak without this\n\n        if (this.textPathElement) {\n          lineInfo.element.add(this.textPathElement);\n        }\n        /*// @todo not needed anymore\r\n        if (this.rtl) {\r\n            chunks.reverse();\r\n        }*/\n        // Process each chunk\n\n\n        for (var x = 0; x < chunks.length; x++) {\n          // If there's more than one chunk, means the line is \"complex\"\n          if (x) {\n            lineInfo.complex = true;\n          } // Get chunk\n\n\n          var chunk = chunks[x]; // Is this chunk format or text?\n\n          if (chunk.type === \"format\") {\n            // Log current format, so that we can apply it to multiple lines if\n            // necessary\n            currentFormat = chunk.text;\n          } else {\n            // It's text block\n            // Need to skip?\n            // We do this when truncating. We can't just simply go ahead and\n            // abandon chunk processing as they might have formatting\n            // instructions in them that are relevant for subsequent lines\n            if (skipTextChunks) {\n              continue;\n            } // Add chunk to the current element\n            //lineInfo.element.content += $utils.trim(getTextFormatter().format(currentFormat + chunk.text, output));\n\n\n            lineInfo.text = chunk.text;\n            lineInfo.style = getTextFormatter().translateStyleShortcuts(currentFormat);\n            var tspan = this.getSvgElement(lineInfo.text, lineInfo.style);\n\n            if (this.textPathElement) {\n              this.textPathElement.add(tspan);\n            } else {\n              lineInfo.element.add(tspan);\n            }\n\n            this.getLineBBox(lineInfo);\n            lineInfo.bbox.width = Math.ceil(lineInfo.bbox.width); // Updated current line height\n\n            if (currentLineHeight < lineInfo.bbox.height) {\n              currentLineHeight = lineInfo.bbox.height;\n            } // Wrapping?\n\n\n            if ((this.wrap || this.truncate) && lineInfo.bbox.width > maxWidth) {\n              // Set oversized\n              this.isOversized = true; // Take temporary measurements\n\n              var lineText = lineInfo.element.textContent;\n              var avgCharWidth = lineInfo.bbox.width / lineText.length; // * .9;\n              // Calculate average number of symbols / width\n\n              var excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length); // Are we truncating or auto-wrapping text?\n\n              if (this.truncate) {\n                /**\r\n                 * Processing line truncation\r\n                 * With the addition of each text chunk we measure if current\r\n                 * line does not exceed maxWidth. If it does, we will stop\r\n                 * addition of further chunks as well as try to truncate\r\n                 * current or any number of previous chunks with an added\r\n                 * ellipsis\r\n                 */\n                // Indicator whether we need to add ellipsis to the current\n                // element, even if it fits. This is needed to indicate\n                // whether we have already removed some subsequent chunks in\n                // which case we need to add ellipsis.\n                var addEllipsis = false; // Process each child in the temporary line, until the whole\n                // line fits, preferably with an ellipsis\n                // TODO use iterator instead\n\n                var node_1 = lineInfo.element.node;\n\n                if (node_1 && node_1.childNodes) {\n                  for (var e = lineInfo.element.node.childNodes.length - 1; e >= 0; e--) {\n                    // Get current element\n                    var node_2 = lineInfo.element.node.childNodes[e]; // Add ellipsis only if previous chunk was removed in full\n                    // and this chunk already fits\n                    //if (addEllipsis && (bbox.width <= maxWidth)) {\n\n                    if (addEllipsis && lineInfo.bbox.width <= maxWidth) {\n                      // Add ellipsis\n                      node_2.textContent += \" \" + this.ellipsis; // Measure again (we need to make sure ellipsis fits)\n\n                      lineInfo.bbox = lineInfo.element.getBBox();\n                      lineInfo.bbox.width = Math.floor(lineInfo.bbox.width); // If it fits, we're done here\n                      // If it doesn't we continue rolling\n\n                      if (lineInfo.bbox.width <= maxWidth) {\n                        break;\n                      }\n                    }\n\n                    addEllipsis = false; // Get element text\n\n                    var elementText = node_2.textContent; // Calculate average number of symbols / width\n\n                    lineText = lineInfo.element.textContent;\n                    excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length); // Do this until we fit\n\n                    while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {\n                      // Calculate max available chars\n                      var maxChars = $math.max(lineText.length - excessChars - this.ellipsis.length, 1); // Is there anything left?\n\n                      if (maxChars <= 1) {\n                        // Nope, let's jump to the previous item\n                        // Set excess characters to zero so that this loop does\n                        // not repeat when it over\n                        excessChars = 0; // Add ellipsis to previous item\n                        // Subsequent iterations will check if the ellipsis fits\n\n                        if (e > 0) {\n                          // Indicating to add ellipsis to previous item\n                          addEllipsis = true; // Removing this node\n\n                          lineInfo.element.node.removeChild(node_2);\n                        }\n                      } // Truncate the text\n\n\n                      elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, this.fullWords, this.rtl);\n\n                      if (elementText.length > maxChars && this.fullWords) {\n                        // Still too long?\n                        // Let's try truncating breaking words anyway\n                        elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, false, this.rtl);\n                      } // Set truncated text\n\n\n                      node_2.textContent = elementText; // Measure again\n\n                      lineInfo.bbox = lineInfo.element.getBBox();\n                      lineInfo.bbox.width = Math.floor(lineInfo.bbox.width); // Increase excess characters count, just in case it still\n                      // doesn't fit and we have to go at it again\n\n                      excessChars = Math.ceil(excessChars * 1.1);\n                    } // Do not process further chunks\n\n\n                    skipTextChunks = true;\n                  }\n                }\n              } else {\n                /**\r\n                 * Processign auto-wrap\r\n                 * In this case we're going to be adding text chunks until\r\n                 * they don't fit into current line. Once that happens we will\r\n                 * inject the rest of the chunks to the next line\r\n                 */\n                // Get last node added and measure it\n                var node_3 = lineInfo.element.node;\n\n                if (node_3) {\n                  var lastNode = lineInfo.element.node.lastChild; // Init split lines\n\n                  var splitLines = void 0;\n\n                  while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {\n                    // Calculate max available chars\n                    var maxChars = $math.max(chunk.text.length - excessChars, 1); // Don't split the words mid-word if it's not the first chunk\n                    // in the line\n\n                    if (firstChunk) {\n                      // Split mid-word if necessary\n                      splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl);\n                    } else {\n                      // Don't split mid-word\n                      splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl); // Check if the first word is too long\n\n                      if (splitLines[0].length > maxChars || maxChars === 1) {\n                        // Yes - move the whole chunk to the next line\n                        // Remove the element we just added\n                        lineInfo.element.node.removeChild(lastNode); // Break out of the while on next cycle\n\n                        excessChars = 0;\n                      }\n                    } // Use the first line to update last item\n\n\n                    if (excessChars > 0) {\n                      lastNode.textContent = getTextFormatter().cleanUp($utils.trim(splitLines.shift()));\n                    } // Measure again, just in case\n\n\n                    lineInfo.bbox = lineInfo.element.getBBox();\n                    lineInfo.bbox.width = Math.floor(lineInfo.bbox.width); // Increase excess characters count, just in case it still\n                    // doesn't fit and we have to go at it again\n\n                    excessChars = Math.ceil(excessChars * 1.1);\n                  } // Construct the rest of the line\n\n\n                  if (splitLines.length > 0) {\n                    var restOfLine = \"\"; // Add leftovers from splitting the current chunk\n\n                    if ($type.hasValue(splitLines)) {\n                      if (this.rtl) {\n                        restOfLine += splitLines.join(\"\") + currentFormat;\n                      } else {\n                        restOfLine += currentFormat + splitLines.join(\"\").replace(/([\\[\\]]{1})/g, \"$1$1\");\n                      }\n                    } // Add the rest of the chunks\n\n\n                    for (var c = x + 1; c < chunks.length; c++) {\n                      if (chunks[c].type == \"value\") {\n                        // We're escaping single square brackets that were\n                        // cleaned up by chunk() back to double square brackets\n                        // so that they are not being treated as format on\n                        // next pass.\n                        restOfLine += chunks[c].text.replace(/([\\[\\]]{1})/g, \"$1$1\");\n                      } else {\n                        restOfLine += chunks[c].text;\n                      }\n                    } // Inject the rest of the lines as chunks for subsequent\n\n\n                    lines.splice(i + 1, 0, restOfLine);\n                  } // Skip processing the rest of the chunks\n\n\n                  skipTextChunks = true;\n                }\n              }\n            } // Let's update the text's bbox with the line's one\n\n\n            if (this.bbox.width < lineInfo.bbox.width) {\n              this.bbox.width = lineInfo.bbox.width;\n            } // commented to avoid bug (seen on sankey link) where text is incorrectly aligned\n            //if (this.bbox.x > lineInfo.bbox.x) {\n            //this.bbox.x = lineInfo.bbox.x;\n            //}\n\n\n            this.bbox.height = currentHeight + currentLineHeight; // Position current line\n\n            if (!this.textPathElement) {\n              lineInfo.element.attr({\n                \"x\": \"0\",\n                \"y\": currentHeight + currentLineHeight,\n                \"dy\": $math.round(this.baseLineRatio * currentLineHeight, 3).toString()\n              });\n            } else {\n              lineInfo.element.attr({\n                \"dy\": -this.paddingBottom.toString()\n              });\n            }\n\n            firstChunk = false;\n          }\n        } // Trim the last item\n\n\n        var node = lineInfo.element.node;\n\n        if (node) {\n          var lastNode = node.lastChild;\n\n          if (lastNode) {\n            lastNode.textContent = this.rtl ? $utils.ltrim(lastNode.textContent) : $utils.rtrim(lastNode.textContent);\n          }\n        } // Increment collective height\n\n\n        currentHeight += currentLineHeight; // Save line cache\n\n        this.addLineInfo(lineInfo, i);\n      } // Check if maybe we need to hide the whole label if it doesn't fit\n\n\n      this.maybeHideOversized();\n      this.measureFailed = false;\n\n      if (this.bbox.width == 0 || this.bbox.height == 0) {\n        this.measureFailed = true;\n      } // Updated measured dims\n\n\n      this._measuredWidth = $math.round($math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight));\n      this._measuredHeight = $math.round($math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom)); // Align the lines\n\n      this.alignSVGText();\n      this.bbox.width = this._measuredWidth;\n      this.bbox.height = this._measuredHeight;\n\n      if (oldH != this._measuredHeight || oldW != this._measuredWidth) {\n        this.dispatch(\"transformed\");\n      }\n\n      this.hideUnused(lines.length);\n    } else {\n      /**\r\n       * HTML\r\n       */\n      this.element.removeAttr(\"display\");\n      this.resetBBox(); // Clear the element\n\n      var group = this.element;\n      group.removeChildren(); // Create a ForeignObject to use as HTML container\n\n      var fo = this.paper.foreignObject();\n      group.add(fo); // Set widths on foreignObject so that autosizing measurements work\n      // This will bet reset to actual content width/height\n\n      if (this.maxWidth) {\n        fo.attr({\n          width: this.maxWidth\n        });\n      }\n\n      if (this.maxHeight) {\n        fo.attr({\n          height: this.maxHeight\n        });\n      } // Create line element\n      //let lineElement: HTMLElement = this.getHTMLLineElement(getTextFormatter().format(this.html, output));\n\n\n      var lineElement = this.getHTMLLineElement(text);\n      fo.node.appendChild(lineElement); // Temporarily set to inline-block so we can measure real width and height\n\n      lineElement.style.display = \"inline-block\";\n      var clientWidth = lineElement.clientWidth;\n      var clientHeight = lineElement.clientHeight;\n      lineElement.style.display = \"block\";\n      this._bbox = {\n        x: 0,\n        y: 0,\n        width: clientWidth,\n        height: clientHeight\n      }; // Set exact dimensions of foreignObject so it is sized exactly as\n      // the content within\n\n      fo.attr({\n        width: clientWidth,\n        height: clientHeight\n      }); // Check if maybe we need to hide the whole label if it doesn't fit\n\n      this.maybeHideOversized(); // Set measurements and update bbox\n\n      this._measuredWidth = $math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);\n      this._measuredHeight = $math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);\n      this.bbox.width = this._measuredWidth;\n      this.bbox.height = this._measuredHeight; // Don't let labels bleed out of the alotted area\n\n      if (this.truncate) {\n        lineElement.style.overflow = \"hidden\";\n      }\n\n      if (clientWidth > maxWidth || clientHeight > maxHeight) {\n        this.isOversized = true;\n      }\n    } // Set applicable styles\n\n\n    this.setStyles();\n    this.updateCenter();\n    this.updateBackground();\n\n    if (display == \"none\") {\n      this.group.attr({\n        display: \"none\"\n      });\n    }\n\n    if (this.pathElement) {\n      this.paper.appendDef(this.pathElement);\n    }\n  };\n  /**\r\n   * Hides element if it does not fit into available space\r\n   */\n\n\n  Label.prototype.maybeHideOversized = function () {\n    if (this.hideOversized) {\n      if (this.availableWidth < this.bbox.width || this.availableHeight < this.bbox.height) {\n        this.element.attr({\n          display: \"none\"\n        });\n        this.isOversized = true;\n      } else {\n        this.element.removeAttr(\"display\");\n        this.isOversized = false;\n      }\n    }\n  };\n  /**\r\n   * Aligns the lines horizontally ant vertically, based on properties.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.alignSVGText = function () {\n    // Get Group\n    var group = this.element;\n    var children = group.node.children || group.node.childNodes; // Is there anything to align?\n\n    if (!children || children && children.length == 0) {\n      return;\n    }\n\n    var width = this._measuredWidth;\n    var height = this._measuredHeight; // TODO maybe these aren't needed ?\n\n    $utils.used(this.pixelPaddingLeft);\n    $utils.used(this.pixelPaddingRight);\n    $utils.used(this.pixelPaddingTop);\n    $utils.used(this.pixelPaddingBottom); // Process each line\n    //$iter.each(group.children.backwards().iterator(), (element) => {\n\n    for (var i = children.length - 1; i >= 0; i--) {\n      // Align horizontally\n      // Since we are using `text-anchor` for horizontal alignment, all we need\n      // to do here is move the `x` position\n      var node = children[i];\n      node.setAttribute(\"text-anchor\", this.textAlign);\n\n      if (this.textPathElement) {\n        node.removeAttribute(\"x\");\n        node.removeAttribute(\"y\");\n      } else {\n        switch (this.textAlign) {\n          case \"middle\":\n            node.setAttribute(\"x\", (width / 2).toString() + \"px\");\n            break;\n\n          case \"end\":\n            if (this.rtl) {} else {\n              node.setAttribute(\"x\", width.toString());\n            }\n\n            break;\n\n          default:\n            if (this.rtl) {\n              node.setAttribute(\"x\", width.toString());\n            } else {\n              node.removeAttribute(\"text-anchor\");\n            }\n\n            break;\n        }\n\n        var y = $type.toNumber(node.getAttribute(\"y\"));\n\n        switch (this.textValign) {\n          case \"middle\":\n            node.setAttribute(\"y\", ((y || 0) + (height - this.bbox.height) / 2).toString());\n            break;\n\n          case \"bottom\":\n            node.setAttribute(\"y\", ((y || 0) + height - this.bbox.height).toString());\n            break;\n\n          default:\n            node.setAttribute(\"y\", (y || 0).toString());\n            break;\n        }\n      }\n    }\n  };\n  /**\r\n   * Produces an SVG line element with formatted text.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text    Text to wrap into line\r\n   * @param y       Current line vertical position\r\n   * @return A DOM element\r\n   * @todo Implement HTML support\r\n   */\n\n\n  Label.prototype.getSVGLineElement = function (text, y) {\n    // Create a <text> node and set text\n    var element = this.paper.addGroup(\"text\");\n    element.textContent = text; // Set parameters\n\n    element.attr({\n      \"x\": \"0\" //\"alignment-baseline\": \"hanging\",\n      //\"baseline-shift\": \"-20%\",\n      //\"text-anchor\": \"center\"\n\n    }); // Set `y` position\n\n    if ($type.hasValue(y)) {\n      element.attr({\n        \"y\": y.toString()\n      });\n    } // Don't let labels blled out of the alotted area\n\n\n    if (this.truncate || this.wrap) {\n      element.attr({\n        \"overflow\": \"hidden\"\n      });\n    } // Add RTL?\n\n\n    if (this.rtl) {\n      element.attr({\n        \"direction\": \"rtl\"\n      });\n    }\n\n    return element;\n  };\n  /**\r\n   * Resets cached BBox.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.resetBBox = function () {\n    this._bbox = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  };\n  /**\r\n   * Creates and returns an HTML line element (`<div>`).\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Text to add\r\n   * @return `<div>` element reference\r\n   */\n\n\n  Label.prototype.getHTMLLineElement = function (text) {\n    // Create the <div> element\n    var div = document.createElement(\"div\");\n    div.innerHTML = text; // Set text alignment\n\n    switch (this.textAlign) {\n      case \"middle\":\n        div.style.textAlign = \"center\";\n        break;\n\n      case \"end\":\n        div.style.textAlign = \"right\";\n        break;\n    } // Disable or enable wrapping\n\n\n    if (this.wrap) {\n      div.style.wordWrap = \"break-word\";\n    } else {\n      div.style.whiteSpace = \"nowrap\";\n    } // Don't let labels bleed out of the alotted area\n    // Moved to `draw()` because setting \"hidden\" kills all measuring\n\n    /*if (this.truncate) {\r\n        div.style.overflow = \"hidden\";\r\n    }*/\n    // Set RTL-related styles\n\n\n    if (this.rtl) {\n      div.style.direction = \"rtl\"; //div.style.unicodeBidi = \"bidi-override\";\n    } // Translate some of the SVG styles into CSS\n\n\n    if ($type.hasValue(this.fill)) {\n      div.style.color = this.fill.toString();\n    }\n\n    return div;\n  };\n  /**\r\n   * Applies specific styles to text to make it not selectable, unless it is\r\n   * explicitly set as `selectable`.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Set styles via AMElement\r\n   */\n\n\n  Label.prototype.setStyles = function () {\n    var group = this.element;\n\n    if (!this.selectable || this.draggable || this.resizable || this.swipeable) {\n      group.addStyle({\n        \"webkitUserSelect\": \"none\",\n        \"msUserSelect\": \"none\"\n      });\n    } else if (this.selectable) {\n      group.removeStyle(\"webkitUserSelect\");\n      group.removeStyle(\"msUserSelect\");\n    }\n  };\n  /**\r\n   * Hides unused lines\r\n   */\n\n\n  Label.prototype.hideUnused = function (index) {\n    this.initLineCache();\n    var lines = this.getCache(\"lineInfo\");\n\n    if (lines.length >= index) {\n      for (var i = index; i < lines.length; i++) {\n        var line = lines[i];\n\n        if (line && line.element) {\n          line.element.attr({\n            \"display\": \"none\"\n          });\n        }\n      }\n    }\n  };\n\n  Object.defineProperty(Label.prototype, \"text\", {\n    /**\r\n     * @return SVG text\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"text\");\n    },\n\n    /**\r\n     * An SVG text.\r\n     *\r\n     * Please note that setting `html` will override this setting if browser\r\n     * supports `foreignObject` in SGV, such as most modern browsers excluding\r\n     * IEs.\r\n     *\r\n     * @param value  SVG Text\r\n     */\n    set: function set(value) {\n      //this.setPropertyValue(\"html\", undefined);\n      this.setPropertyValue(\"text\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"path\", {\n    /**\r\n     * @return Path\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"path\");\n    },\n\n    /**\r\n     * An SVG path string to position text along. If set, the text will follow\r\n     * the curvature of the path.\r\n     *\r\n     * Location along the path can be set using `locationOnPath`.\r\n     *\r\n     * IMPORTANT: Only SVG text can be put on path. If you are using HTML text\r\n     * this setting will be ignored.\r\n     *\r\n     * @since 4.1.2\r\n     * @param  value  Path\r\n     */\n    set: function set(value) {\n      if (this.setPropertyValue(\"path\", value, true)) {\n        if (this.pathElement) {\n          this.pathElement.dispose();\n        }\n\n        if (this.textPathElement) {\n          this.textPathElement.dispose();\n        }\n\n        this.pathElement = this.paper.add(\"path\");\n        this.pathElement.attr({\n          \"d\": value\n        });\n        this.pathElement.attr({\n          \"id\": \"text-path-\" + this.uid\n        });\n\n        this._disposers.push(this.pathElement);\n\n        this.textPathElement = this.paper.addGroup(\"textPath\");\n        this.textPathElement.attrNS($dom.XLINK, \"xlink:href\", \"#text-path-\" + this.uid); // TODO remove after https://bugzilla.mozilla.org/show_bug.cgi?id=455986 is fixed\n\n        this.textPathElement.attr({\n          \"path\": value\n        });\n\n        this._disposers.push(this.textPathElement);\n\n        this.hardInvalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"locationOnPath\", {\n    /**\r\n     * @return Relatvie location on path\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"locationOnPath\");\n    },\n\n    /**\r\n     * Relative label location on `path`. Value range is from 0 (beginning)\r\n     * to 1 (end).\r\n     *\r\n     * Works only if you set `path` setting to an SVG path.\r\n     *\r\n     * @since 4.1.2\r\n     * @default 0\r\n     * @param  value  Relatvie location on path\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"locationOnPath\", value);\n\n      if (this.textPathElement) {\n        this.textPathElement.attr({\n          \"startOffset\": value * 100 + \"%\"\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"baseLineRatio\", {\n    /**\r\n     * @return Base line ratio\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"baseLineRatio\");\n    },\n\n    /**\r\n     * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n     * the label.\r\n     *\r\n     * @since 4.4.2\r\n     * @default -0.27\r\n     * @param  value  Base line ratio\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"baseLineRatio\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"wrap\", {\n    /**\r\n     * @return Auto-wrap enabled or not\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"wrap\");\n    },\n\n    /**\r\n     * Enables or disables autowrapping of text.\r\n     *\r\n     * @param value  Auto-wrapping enabled\r\n     */\n    set: function set(value) {\n      this.resetBBox();\n      this.setPropertyValue(\"wrap\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"truncate\", {\n    /**\r\n     * @return Truncate text?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"truncate\");\n    },\n\n    /**\r\n     * Indicates if text lines need to be truncated if they do not fit, using\r\n     * configurable `ellipsis` string.\r\n     *\r\n     * `truncate` overrides `wrap` if both are set to `true`.\r\n     *\r\n     * NOTE: For HTML text, this setting **won't** trigger a parser and actual\r\n     * line truncation with ellipsis. It will just hide everything that goes\r\n     * outside the label.\r\n     *\r\n     * @param value  trincate text?\r\n     */\n    set: function set(value) {\n      this.resetBBox();\n      this.setPropertyValue(\"truncate\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"fullWords\", {\n    /**\r\n     * @return Truncate on full words?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"fullWords\");\n    },\n\n    /**\r\n     * If `truncate` is enabled, should Label try to break only on full words\r\n     * (`true`), or whenever needed, including middle of the word. (`false`)\r\n     *\r\n     * @default true\r\n     * @param value  Truncate on full words?\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"fullWords\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"ellipsis\", {\n    /**\r\n     * @return Ellipsis string\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"ellipsis\");\n    },\n\n    /**\r\n     * Ellipsis character to use if `truncate` is enabled.\r\n     *\r\n     * @param value Ellipsis string\r\n     * @default \"...\"\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"ellipsis\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"selectable\", {\n    /**\r\n     * @return Text selectable?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"selectable\");\n    },\n\n    /**\r\n     * Forces the text to be selectable. This setting will be ignored if the\r\n     * object has some kind of interaction attached to it, such as it is\r\n     * `draggable`, `swipeable`, `resizable`.\r\n     *\r\n     * @param value  Text selectable?\r\n     * @default false\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"selectable\", value, true);\n      this.setStyles();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"textAlign\", {\n    /**\r\n     * @return Alignment\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"textAlign\");\n    },\n\n    /**\r\n     * Horizontal text alignment.\r\n     *\r\n     * Available choices:\r\n     * * \"start\"\r\n     * * \"middle\"\r\n     * * \"end\"\r\n     *\r\n     * @param value  Alignment\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"textAlign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"textValign\", {\n    /**\r\n     * @ignore Exclude from docs (not used)\r\n     * @return Alignment\r\n     * @deprecated\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"textValign\");\n    },\n\n    /**\r\n     * Vertical text alignment.\r\n     *\r\n     * @ignore Exclude from docs (not used)\r\n     * @param value  Alignment\r\n     * @deprecated\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"textValign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"html\", {\n    /**\r\n     * @return HTML content\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"html\");\n    },\n\n    /**\r\n     * Raw HTML to be used as text.\r\n     *\r\n     * NOTE: HTML text is subject to browser support. It relies on browsers\r\n     * supporting SVG `foreignObject` nodes. Some browsers (read IEs) do not\r\n     * support it. On those browsers, the text will fall back to basic SVG text,\r\n     * striping out all HTML markup and styling that goes with it.\r\n     *\r\n     * For more information about `foreignObject` and its browser compatibility\r\n     * refer to [this page](https://developer.mozilla.org/en/docs/Web/SVG/Element/foreignObject#Browser_compatibility).\r\n     *\r\n     * @param value HTML text\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"html\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"hideOversized\", {\n    /**\r\n     * @return Hide if text does not fit?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"hideOversized\");\n    },\n\n    /**\r\n     * Indicates whether the whole text should be hidden if it does not fit into\r\n     * its allotted space.\r\n     *\r\n     * @param value  Hide if text does not fit?\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"hideOversized\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"ignoreFormatting\", {\n    /**\r\n     * @return Ignore formatting?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"ignoreFormatting\");\n    },\n\n    /**\r\n     * If set to `true` square-bracket formatting blocks will be treated as\r\n     * regular text.\r\n     *\r\n     * @default false\r\n     * @param value  Ignore formatting?\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"ignoreFormatting\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Override `mesaureElement` so it does not get measure again, because\r\n   * internal `_bbox` is being updated by measuring routines in Text itself.\r\n   */\n\n  Label.prototype.measureElement = function () {};\n  /**\r\n   * Returns information about a line element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param index  Line index\r\n   * @return Line info object\r\n   */\n\n\n  Label.prototype.getLineInfo = function (index) {\n    this.initLineCache();\n    var lines = this.getCache(\"lineInfo\");\n    return lines.length > index ? lines[index] : undefined;\n  };\n  /**\r\n   * Adds a line to line info cache.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param line     Line info object\r\n   * @param index    Insert at specified index\r\n   */\n\n\n  Label.prototype.addLineInfo = function (line, index) {\n    this.initLineCache();\n    this.getCache(\"lineInfo\")[index] = line;\n  };\n  /**\r\n   * Checks if line cache is initialized and initializes it.\r\n   */\n\n\n  Label.prototype.initLineCache = function () {\n    if (!$type.hasValue(this.getCache(\"lineInfo\"))) {\n      this.setCache(\"lineInfo\", [], 0);\n    }\n  };\n  /**\r\n   * Sets a [[DataItem]] to use for populating dynamic sections of the text.\r\n   *\r\n   * Check the description for [[Text]] class, for data binding.\r\n   *\r\n   * @param dataItem Data item\r\n   */\n\n\n  Label.prototype.setDataItem = function (dataItem) {\n    if (this._sourceDataItemEvents) {\n      this._sourceDataItemEvents.dispose();\n    }\n\n    if (dataItem) {\n      this._sourceDataItemEvents = new MultiDisposer([dataItem.events.on(\"valuechanged\", this.invalidate, this, false), dataItem.events.on(\"workingvaluechanged\", this.invalidate, this, false), dataItem.events.on(\"calculatedvaluechanged\", this.invalidate, this, false), dataItem.events.on(\"propertychanged\", this.invalidate, this, false)]);\n    }\n\n    _super.prototype.setDataItem.call(this, dataItem);\n  };\n\n  Object.defineProperty(Label.prototype, \"availableWidth\", {\n    /**\r\n     * Returns available horizontal space.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Available width (px)\r\n     */\n    get: function get() {\n      return $type.hasValue(this.maxWidth) ? this.maxWidth : this.pixelWidth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"availableHeight\", {\n    /**\r\n     * Returns available vertical space.\r\n     *\r\n     * @return Available height (px)\r\n     */\n    get: function get() {\n      return $type.hasValue(this.maxHeight) ? this.maxHeight : this.pixelHeight;\n    },\n    enumerable: true,\n    configurable: true\n  }); // temp, replacing textFormatter method\n\n  Label.prototype.getSvgElement = function (text, style) {\n    var element = this.paper.add(\"tspan\");\n    element.textContent = text;\n\n    if (style) {\n      element.node.setAttribute(\"style\", style);\n    }\n\n    return element;\n  };\n  /**\r\n   * Invalidates the whole element, including layout AND all its child\r\n   * elements.\r\n   */\n\n\n  Label.prototype.deepInvalidate = function () {\n    _super.prototype.deepInvalidate.call(this);\n\n    this.hardInvalidate();\n  };\n\n  Object.defineProperty(Label.prototype, \"readerTitle\", {\n    /**\r\n     * @return Title\r\n     */\n    get: function get() {\n      var title = this.getPropertyValue(\"readerTitle\");\n\n      if (!title) {\n        title = this.populateString($utils.plainText($utils.isNotEmpty(this.html) ? this.html : this.text));\n      }\n\n      return title;\n    },\n\n    /**\r\n     * Screen reader title of the element.\r\n     *\r\n     * @param value Title\r\n     */\n    set: function set(value) {\n      value = $type.toText(value);\n\n      if (this.setPropertyValue(\"readerTitle\", value)) {\n        this.applyAccessibility();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Label;\n}(Container);\n\nexport { Label };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Label\"] = Label;\n/**\r\n * Add default responsive rules\r\n */\n\n/**\r\n * Hide labels added directly to chart, like titles if chart is short.\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.heightXS,\n  state: function state(target, stateId) {\n    if (target instanceof Label && target.parent && target.parent.isBaseSprite) {\n      var state = target.states.create(stateId);\n      state.properties.disabled = true;\n      return state;\n    }\n\n    return null;\n  }\n});","map":{"version":3,"sources":["../../../../../src/.internal/core/elements/Label.ts"],"names":[],"mappings":"AAAA;;;;AAIA;;;;;;;AAMA,SAAS,SAAT,QAAsF,cAAtF;AAOA,SAAS,QAAT,QAAyB,aAAzB;AACA,SAAqB,gBAArB,QAA6C,6BAA7C;AACA,SAAS,aAAT,QAA8B,mBAA9B;AACA,SAAS,iBAAT,QAAkC,oCAAlC;AACA,OAAO,KAAK,KAAZ,MAAuB,eAAvB;AACA,OAAO,KAAK,MAAZ,MAAwB,gBAAxB;AACA,OAAO,KAAK,KAAZ,MAAuB,eAAvB;AAEA,OAAO,KAAK,IAAZ,MAAsB,cAAtB;AACA,SAAS,YAAT,EAAuB,qBAAvB,QAAoD,qBAApD;AAiIC;AA6BD;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,IAAA,KAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA2B,EAAA,SAAA,CAAA,KAAA,EAAA,MAAA,CAAA;AAuD1B;;;;;AAGA,WAAA,KAAA,GAAA;AAAA,QAAA,KAAA,GAEC;AACA,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IAHR;AA1CA;;;;;AAGO,IAAA,KAAA,CAAA,WAAA,GAAuB,KAAvB,CAuCP,CAKC;;AACA,IAAA,KAAI,CAAC,SAAL,GAAiB,OAAjB;AAEA,IAAA,KAAI,CAAC,IAAL,GAAY,IAAI,iBAAJ,GAAwB,MAAxB,CAA+B,MAA/B,CAAZ,CARD,CAUC;AACA;AACA;AAGA;;AACA,IAAA,KAAI,CAAC,IAAL,GAAY,KAAZ;AACA,IAAA,KAAI,CAAC,QAAL,GAAgB,KAAhB;AACA,IAAA,KAAI,CAAC,SAAL,GAAiB,IAAjB;AACA,IAAA,KAAI,CAAC,QAAL,GAAgB,GAAhB;AACA,IAAA,KAAI,CAAC,SAAL,GAAiB,OAAjB;AACA,IAAA,KAAI,CAAC,UAAL,GAAkB,KAAlB;AAEA,IAAA,KAAI,CAAC,MAAL,GAAc,UAAd;AACA,IAAA,KAAI,CAAC,aAAL,GAAqB,CAAC,IAAtB,CAxBD,CAyBC;;AACA,IAAA,KAAI,CAAC,kBAAL,GAA0B,CAA1B,CA1BD,CA4BC;AACA;;AACA,IAAA,KAAI,CAAC,MAAL,CAAY,EAAZ,CAAe,gBAAf,EAAiC,YAAA;AAChC,UAAI,KAAI,CAAC,MAAT,EAAiB;AAChB,QAAA,KAAI,CAAC,aAAL;AACA;AACD,KAJD,EAIG,KAJH,EAIS,KAJT,EA9BD,CAoCC;;;AACA,IAAA,KAAI,CAAC,MAAL,CAAY,IAAZ,CAAiB,WAAjB,EAA8B,KAAI,CAAC,cAAnC,EAAmD,KAAnD,EAAyD,KAAzD,EArCD,CAuCC;;;AACA,IAAA,KAAI,CAAC,UAAL;;;AACA;AAGD;;;;;;;;AAMU,EAAA,KAAA,CAAA,SAAA,CAAA,SAAA,GAAV,YAAA;AACC;AACA,IAAA,MAAA,CAAA,SAAA,CAAM,SAAN,CAAe,IAAf,CAAe,IAAf;;AACA,SAAK,gBAAL;AACA,GAJS;AAOV;;;;;;;;AAMO,EAAA,KAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,KAAhB,EAA4B;AAE3B,QAAI,OAAO,GAAG,MAAA,CAAA,SAAA,CAAM,QAAN,CAAc,IAAd,CAAc,IAAd,EAAe,KAAf,CAAd;;AAEA,QAAI,OAAJ,EAAa;AACZ,WAAK,cAAL;AACA;;AACD,WAAO,OAAP;AACA,GARM;AAUP;;;;;AAGU,EAAA,KAAA,CAAA,SAAA,CAAA,cAAA,GAAV,YAAA;AACC,QAAI,CAAC,KAAK,WAAL,IAAoB,KAAK,IAA1B,MAAoC,KAAK,IAAL,CAAU,KAAV,IAAmB,CAAnB,IAAwB,KAAK,IAAL,CAAU,MAAV,IAAoB,CAAhF,CAAJ,EAAwF;AACvF,MAAA,QAAQ,CAAC,MAAT,CAAgB,IAAhB,CAAqB,WAArB,EAAkC,KAAK,cAAvC,EAAuD,IAAvD;AACA;AACD,GAJS;AAMV;;;;;AAGU,EAAA,KAAA,CAAA,SAAA,CAAA,aAAA,GAAV,YAAA;AACC,QACE,KAAK,IAAL,CAAU,KAAV,GAAkB,KAAK,cAAxB,IACK,KAAK,IAAL,CAAU,KAAV,GAAkB,KAAK,cAAxB,KAA4C,KAAK,WAAL,IAAoB,KAAK,QAArE,CADJ,IAEI,KAAK,IAAL,CAAU,MAAV,GAAmB,KAAK,eAF5B,IAGK,KAAK,IAAL,CAAU,MAAV,GAAmB,KAAK,eAAzB,IAA6C,KAAK,WAJvD,EAKE;AACD,WAAK,UAAL;AACA,KAPD,MAQK;AACJ,WAAK,YAAL;AACA;AACD,GAZS;AAcV;;;;;;;;AAMO,EAAA,KAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA,CAEC,CAFM;AAIP;;;;;;;;AAMU,EAAA,KAAA,CAAA,SAAA,CAAA,iBAAA,GAAV,YAAA;AACC;AACA,QAAI,MAAJ,EAAoB,IAApB;;AAEA,QAAI,MAAM,CAAC,UAAP,CAAkB,KAAK,IAAvB,KAAgC,KAAK,KAAL,CAAW,qBAAX,EAApC,EAAwE;AAEvE;AACA,MAAA,MAAM,GAAG,MAAT;AACA,MAAA,IAAI,GAAG,KAAK,IAAZ;AACA,KALD,MAMK;AACJ,MAAA,MAAM,GAAG,KAAT;AACA,MAAA,IAAI,GAAG,KAAK,IAAZ;AACA,KAbF,CAeC;;;AACA,QAAI,KAAK,CAAC,QAAN,CAAe,IAAf,CAAJ,EAAiC;AAChC,MAAA,IAAI,GAAG,IAAI,CAAC,QAAL,EAAP;AACA,KAlBF,CAoBC;;;AACA,QAAI,KAAK,CAAC,QAAN,CAAe,IAAf,KAAwB,IAAI,KAAK,EAArC,EAAyC;AACxC,MAAA,IAAI,GAAG,KAAK,cAAL,CAAoB,IAApB,EAA0B,KAAK,QAA/B,CAAP;AACA;;AAED,QAAI,MAAM,IAAI,MAAd,EAAsB;AACrB,UAAI,KAAK,SAAT,EAAoB;AACnB,QAAA,IAAI,GAAG,KAAK,SAAL,CAAe,KAAf,CAAqB,YAArB,EAAmC,IAAnC,CAAP;AACA;AACD,KAJD,MAKK;AACJ,UAAI,KAAK,SAAT,EAAoB;AACnB,QAAA,IAAI,GAAG,KAAK,SAAL,CAAe,KAAf,CAAqB,YAArB,EAAmC,IAAnC,CAAP;AACA;AACD,KAlCF,CAoCC;;;AACA,QAAI,OAAO,GAAG,IAAI,IAAI,KAAK,WAAb,IAA4B,MAAM,IAAI,KAAK,cAAzD;AACA,SAAK,WAAL,GAAmB,IAAnB;AACA,SAAK,cAAL,GAAsB,MAAtB;AAEA,WAAO,OAAP;AACA,GA1CS;AA4CV;;;;;;;AAKO,EAAA,KAAA,CAAA,SAAA,CAAA,cAAA,GAAP,YAAA;AACC,SAAK,WAAL,GAAmB,EAAnB;AACA,SAAK,UAAL;AACA,GAHM;AAKP;;;;;;AAIU,EAAA,KAAA,CAAA,SAAA,CAAA,WAAA,GAAV,UAAsB,QAAtB,EAA6C;AAC5C;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,QAAI,OAAO,GAAG,QAAQ,IAAI,QAAQ,CAAC,OAAnC;AACA,QAAI,IAAI,GAAG,OAAO,IAAI,OAAO,CAAC,IAA9B,CAZ4C,CAc5C;;AACA,QAAI,IAAI,IAAI,IAAI,CAAC,UAAjB,EAA6B;AAC5B,MAAA,QAAQ,CAAC,IAAT,GAAgB,OAAO,CAAC,OAAR,EAAhB;AACA;AACD,GAlBS;AAoBV;;;;;;;AAKO,EAAA,KAAA,CAAA,SAAA,CAAA,IAAA,GAAP,YAAA;AAEC;AACA,IAAA,MAAA,CAAA,SAAA,CAAM,IAAN,CAAU,IAAV,CAAU,IAAV;;AAEA,QAAI,IAAI,GAAG,KAAK,IAAL,CAAU,KAArB;AACA,QAAI,IAAI,GAAG,KAAK,IAAL,CAAU,MAArB;AAEA,QAAI,SAAS,GAAG,KAAK,SAArB;;AACA,QAAI,SAAJ,EAAe;AACd,UAAI,CAAC,SAAS,CAAC,QAAX,IAAuB,CAAC,SAAS,CAAC,SAAtC,EAAiD;AAChD,QAAA,SAAS,CAAC,MAAV,CAAiB,IAAjB,CAAsB,gBAAtB,EAAwC,KAAK,cAA7C,EAA6D,IAA7D,EAAmE,KAAnE;AACA;AACA;AACD,KAdF,CAgBC;;;AACA,QAAI,QAAQ,GAAW,KAAK,CAAC,GAAN,CAAU,KAAK,cAAL,GAAsB,KAAK,gBAA3B,GAA8C,KAAK,iBAA7D,EAAgF,CAAhF,CAAvB;AACA,QAAI,SAAS,GAAW,KAAK,CAAC,GAAN,CAAU,KAAK,eAAL,GAAuB,KAAK,eAA5B,GAA8C,KAAK,kBAA7D,EAAiF,CAAjF,CAAxB,CAlBD,CAoBC;;AACA,QAAI,MAAM,GAAG,SAAS,GAAG,GAAZ,GAAkB,QAAlB,GAA6B,KAAK,IAAlC,GAAyC,KAAK,QAA9C,GAAyD,KAAK,SAA9D,GAA0E,KAAK,GAA/E,GAAqF,KAAK,QAAvG,CArBD,CAuBC;;AACA,QAAI,CAAC,KAAK,iBAAL,EAAD,IAA6B,KAAK,MAAlC,IAA4C,KAAK,WAAL,IAAoB,MAApE,EAA4E;AAC3E;AACA;;AAED,SAAK,cAAL,GAAsB,CAAtB;AACA,SAAK,eAAL,GAAuB,CAAvB,CA7BD,CA+BC;;AACA,SAAK,WAAL,GAAmB,KAAnB,CAhCD,CAkCC;;AACA,QAAI,MAAM,GAAG,KAAK,cAAlB;AACA,QAAI,IAAI,GAAG,KAAK,WAAhB,CApCD,CAsCC;;AACA,QAAI,CAAC,KAAK,CAAC,QAAN,CAAe,IAAf,CAAD,IAAyB,IAAI,IAAI,EAArC,EAAyC;AACxC,WAAK,OAAL,CAAa,IAAb,CAAkB;AAAE,QAAA,OAAO,EAAE;AAAX,OAAlB;AACA;AACA,KA1CF,CA4CC;AACA;;;AACA,QAAI,KAAK,GAAa,IAAI,CAAC,KAAL,CAAW,IAAX,CAAtB,CA9CD,CAgDC;AACA;;AAEA,SAAK,WAAL,GAAmB,MAAnB;AAEA,SAAK,SAAL,GAAiB,KAAK,SAAtB,CArDD,CAuDC;;AACA,QAAI,OAAO,GAAG,KAAK,KAAL,CAAW,OAAX,CAAmB,SAAnB,CAAd;;AACA,QAAI,OAAO,IAAI,MAAf,EAAuB;AACtB,WAAK,KAAL,CAAW,UAAX,CAAsB,SAAtB;AACA;;AAED,QAAI,KAAK,eAAT,EAA0B;AACzB,WAAK,eAAL,CAAqB,cAArB;AACA,KA/DF,CAiEC;;;AACA,QAAI,MAAM,KAAK,KAAf,EAAsB;AACrB;;;AAIA,WAAK,OAAL,CAAa,UAAb,CAAwB,SAAxB,EALqB,CAOrB;;AACA,UAAI,KAAK,GAAiB,KAAK,OAA/B;AAEA,WAAK,SAAL,GAVqB,CAYrB;;AACA,UAAI,aAAa,GAAW,CAA5B;AACA,UAAI,aAAa,GAAW,EAA5B,CAdqB,CAgBrB;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AAEtC;AACA,YAAI,IAAI,GAAW,KAAK,CAAC,CAAD,CAAxB,CAHsC,CAKtC;;AACA,YAAI,IAAI,IAAI,EAAZ,EAAgB;AACf;AACA;AACA;AACA;AACA,cAAI,WAAW,GAAG,KAAK,iBAAL,CAAuB,EAAvB,EAA2B,CAA3B,CAAlB;AACA,UAAA,WAAW,CAAC,GAAZ,CACC,KAAK,aAAL,CACC,GADD,EAEC,gBAAgB,GAAG,uBAAnB,CAA2C,aAA3C,CAFD,CADD;AAOA,UAAA,KAAK,CAAC,GAAN,CAAU,WAAV;AACA,cAAI,MAAM,GAAG,IAAI,CAAC,IAAL,CAAU,WAAW,CAAC,OAAZ,GAAsB,MAAhC,CAAb;;AACA,cAAI,MAAM,GAAG,CAAb,EAAgB;AACf,YAAA,aAAa,IAAI,MAAjB;AACA;;AACD,UAAA,KAAK,CAAC,aAAN,CAAoB,WAApB,EAlBe,CAoBf;;AACA,cAAI,UAAQ,GAAG,KAAK,WAAL,CAAiB,CAAjB,CAAf;;AACA,cAAI,UAAJ,EAAc;AACb,YAAA,UAAQ,CAAC,IAAT,GAAgB,EAAhB;AACA,YAAA,UAAQ,CAAC,OAAT,CAAiB,WAAjB,GAA+B,EAA/B;AACA;;AACD;AAEA,SAlCqC,CAoCtC;;;AACA,YAAI,MAAM,GAAiB,gBAAgB,GAAG,KAAnB,CAAyB,IAAzB,EAA+B,IAA/B,EAAqC,KAAK,gBAA1C,CAA3B;AACA,YAAI,iBAAiB,GAAW,CAAhC;AACA,YAAI,UAAU,GAAY,IAA1B;AACA,YAAI,cAAc,GAAY,KAA9B,CAxCsC,CA0CtC;;AACA,YAAI,QAAQ,GAAG,KAAK,WAAL,CAAiB,CAAjB,CAAf;;AAEA,YAAI,QAAJ,EAAc;AACb;AACA,UAAA,QAAQ,CAAC,IAAT,GAAgB,EAAhB;AACA,UAAA,QAAQ,CAAC,OAAT,CAAiB,WAAjB,GAA+B,EAA/B;AACA,SAJD,MAKK;AACJ;AACA,UAAA,QAAQ,GAAG;AACV,oBAAQ,EADE;AAEV,uBAAW,KAAK,iBAAL,CAAuB,EAAvB,EAA2B,CAA3B,CAFD;AAGV,uBAAW;AAHD,WAAX,CAFI,CAQJ;AACA;AACA;;AACA,UAAA,KAAK,CAAC,GAAN,CAAU,QAAQ,CAAC,OAAnB;AACA;;AAED,QAAA,QAAQ,CAAC,OAAT,CAAiB,UAAjB,CAA4B,SAA5B;AACA,QAAA,QAAQ,CAAC,OAAT,CAAiB,cAAjB,GAjEsC,CAiEH;;AAEnC,YAAI,KAAK,eAAT,EAA0B;AACzB,UAAA,QAAQ,CAAC,OAAT,CAAiB,GAAjB,CAAqB,KAAK,eAA1B;AACA;AAED;;;;AAKA;;;AACA,aAAK,IAAI,CAAC,GAAW,CAArB,EAAwB,CAAC,GAAG,MAAM,CAAC,MAAnC,EAA2C,CAAC,EAA5C,EAAgD;AAE/C;AACA,cAAI,CAAJ,EAAO;AACN,YAAA,QAAQ,CAAC,OAAT,GAAmB,IAAnB;AACA,WAL8C,CAO/C;;;AACA,cAAI,KAAK,GAAG,MAAM,CAAC,CAAD,CAAlB,CAR+C,CAU/C;;AACA,cAAI,KAAK,CAAC,IAAN,KAAe,QAAnB,EAA6B;AAE5B;AACA;AACA,YAAA,aAAa,GAAG,KAAK,CAAC,IAAtB;AAEA,WAND,MAOK;AAEJ;AAEA;AACA;AACA;AACA;AACA,gBAAI,cAAJ,EAAoB;AACnB;AACA,aAVG,CAYJ;AACA;;;AAEA,YAAA,QAAQ,CAAC,IAAT,GAAgB,KAAK,CAAC,IAAtB;AACA,YAAA,QAAQ,CAAC,KAAT,GAAiB,gBAAgB,GAAG,uBAAnB,CAA2C,aAA3C,CAAjB;AAEA,gBAAI,KAAK,GAAG,KAAK,aAAL,CAAmB,QAAQ,CAAC,IAA5B,EAAkC,QAAQ,CAAC,KAA3C,CAAZ;;AAEA,gBAAI,KAAK,eAAT,EAA0B;AACzB,mBAAK,eAAL,CAAqB,GAArB,CAAyB,KAAzB;AACA,aAFD,MAGK;AACJ,cAAA,QAAQ,CAAC,OAAT,CAAiB,GAAjB,CAAqB,KAArB;AACA;;AAED,iBAAK,WAAL,CAAiB,QAAjB;AACA,YAAA,QAAQ,CAAC,IAAT,CAAc,KAAd,GAAsB,IAAI,CAAC,IAAL,CAAU,QAAQ,CAAC,IAAT,CAAc,KAAxB,CAAtB,CA5BI,CA8BJ;;AACA,gBAAI,iBAAiB,GAAG,QAAQ,CAAC,IAAT,CAAc,MAAtC,EAA8C;AAC7C,cAAA,iBAAiB,GAAG,QAAQ,CAAC,IAAT,CAAc,MAAlC;AACA,aAjCG,CAmCJ;;;AACA,gBAAI,CAAC,KAAK,IAAL,IAAa,KAAK,QAAnB,KAAiC,QAAQ,CAAC,IAAT,CAAc,KAAd,GAAsB,QAA3D,EAAsE;AAErE;AACA,mBAAK,WAAL,GAAmB,IAAnB,CAHqE,CAKrE;;AACA,kBAAI,QAAQ,GAAW,QAAQ,CAAC,OAAT,CAAiB,WAAxC;AACA,kBAAI,YAAY,GAAY,QAAQ,CAAC,IAAT,CAAc,KAAd,GAAsB,QAAQ,CAAC,MAA3D,CAPqE,CAOD;AAEpE;;AACA,kBAAI,WAAW,GAAW,KAAK,CAAC,GAAN,CAAU,IAAI,CAAC,IAAL,CAAU,CAAC,QAAQ,CAAC,IAAT,CAAc,KAAd,GAAsB,QAAvB,IAAmC,YAA7C,CAAV,EAAsE,QAAQ,CAAC,MAA/E,CAA1B,CAVqE,CAYrE;;AACA,kBAAI,KAAK,QAAT,EAAmB;AAElB;;;;;;;;AASA;AACA;AACA;AACA;AACA,oBAAI,WAAW,GAAY,KAA3B,CAfkB,CAiBlB;AACA;AACA;;AACA,oBAAI,MAAI,GAAG,QAAQ,CAAC,OAAT,CAAiB,IAA5B;;AACA,oBAAI,MAAI,IAAI,MAAI,CAAC,UAAjB,EAA6B;AAC5B,uBAAK,IAAI,CAAC,GAAG,QAAQ,CAAC,OAAT,CAAiB,IAAjB,CAAsB,UAAtB,CAAiC,MAAjC,GAA0C,CAAvD,EAA0D,CAAC,IAAI,CAA/D,EAAkE,CAAC,EAAnE,EAAuE;AAEtE;AACA,wBAAI,MAAI,GAAG,QAAQ,CAAC,OAAT,CAAiB,IAAjB,CAAsB,UAAtB,CAAiC,CAAjC,CAAX,CAHsE,CAMtE;AACA;AACA;;AACA,wBAAI,WAAW,IAAK,QAAQ,CAAC,IAAT,CAAc,KAAd,IAAuB,QAA3C,EAAsD;AAErD;AACA,sBAAA,MAAI,CAAC,WAAL,IAAoB,MAAM,KAAK,QAA/B,CAHqD,CAKrD;;AACA,sBAAA,QAAQ,CAAC,IAAT,GAAgB,QAAQ,CAAC,OAAT,CAAiB,OAAjB,EAAhB;AACA,sBAAA,QAAQ,CAAC,IAAT,CAAc,KAAd,GAAsB,IAAI,CAAC,KAAL,CAAW,QAAQ,CAAC,IAAT,CAAc,KAAzB,CAAtB,CAPqD,CASrD;AACA;;AACA,0BAAI,QAAQ,CAAC,IAAT,CAAc,KAAd,IAAuB,QAA3B,EAAqC;AACpC;AACA;AAED;;AACD,oBAAA,WAAW,GAAG,KAAd,CAzBsE,CA2BtE;;AACA,wBAAI,WAAW,GAAG,MAAI,CAAC,WAAvB,CA5BsE,CA8BtE;;AACA,oBAAA,QAAQ,GAAG,QAAQ,CAAC,OAAT,CAAiB,WAA5B;AACA,oBAAA,WAAW,GAAG,KAAK,CAAC,GAAN,CAAU,IAAI,CAAC,IAAL,CAAU,CAAC,QAAQ,CAAC,IAAT,CAAc,KAAd,GAAsB,QAAvB,IAAmC,YAA7C,CAAV,EAAsE,QAAQ,CAAC,MAA/E,CAAd,CAhCsE,CAkCtE;;AACA,2BAAQ,QAAQ,CAAC,IAAT,CAAc,KAAd,GAAsB,QAAvB,IAAqC,WAAW,IAAI,QAAQ,CAAC,MAA7D,IAAyE,WAAW,GAAG,CAA9F,EAAkG;AAEjG;AACA,0BAAI,QAAQ,GAAW,KAAK,CAAC,GAAN,CAAU,QAAQ,CAAC,MAAT,GAAkB,WAAlB,GAAgC,KAAK,QAAL,CAAc,MAAxD,EAAgE,CAAhE,CAAvB,CAHiG,CAKjG;;AACA,0BAAI,QAAQ,IAAI,CAAhB,EAAmB;AAElB;AACA;AACA;AACA,wBAAA,WAAW,GAAG,CAAd,CALkB,CAOlB;AACA;;AACA,4BAAI,CAAC,GAAG,CAAR,EAAW;AAEV;AACA,0BAAA,WAAW,GAAG,IAAd,CAHU,CAKV;;AACA,0BAAA,QAAQ,CAAC,OAAT,CAAiB,IAAjB,CAAsB,WAAtB,CAAkC,MAAlC;AACA;AAED,uBAxBgG,CA0BjG;;;AACA,sBAAA,WAAW,GAAG,MAAM,CAAC,oBAAP,CAA4B,WAA5B,EAAyC,QAAzC,EAAmD,KAAK,QAAxD,EAAkE,KAAK,SAAvE,EAAkF,KAAK,GAAvF,CAAd;;AAEA,0BAAK,WAAW,CAAC,MAAZ,GAAqB,QAAtB,IAAmC,KAAK,SAA5C,EAAuD;AACtD;AACA;AACA,wBAAA,WAAW,GAAG,MAAM,CAAC,oBAAP,CAA4B,WAA5B,EAAyC,QAAzC,EAAmD,KAAK,QAAxD,EAAkE,KAAlE,EAAyE,KAAK,GAA9E,CAAd;AACA,uBAjCgG,CAmCjG;;;AACA,sBAAA,MAAI,CAAC,WAAL,GAAmB,WAAnB,CApCiG,CAsCjG;;AACA,sBAAA,QAAQ,CAAC,IAAT,GAAgB,QAAQ,CAAC,OAAT,CAAiB,OAAjB,EAAhB;AACA,sBAAA,QAAQ,CAAC,IAAT,CAAc,KAAd,GAAsB,IAAI,CAAC,KAAL,CAAW,QAAQ,CAAC,IAAT,CAAc,KAAzB,CAAtB,CAxCiG,CA2CjG;AACA;;AACA,sBAAA,WAAW,GAAG,IAAI,CAAC,IAAL,CAAU,WAAW,GAAG,GAAxB,CAAd;AAEA,qBAlFqE,CAoFtE;;;AACA,oBAAA,cAAc,GAAG,IAAjB;AACA;AACD;AAED,eA/GD,MAgHK;AAEJ;;;;;;AAMA;AACA,oBAAI,MAAI,GAAG,QAAQ,CAAC,OAAT,CAAiB,IAA5B;;AACA,oBAAI,MAAJ,EAAU;AACT,sBAAI,QAAQ,GAAG,QAAQ,CAAC,OAAT,CAAiB,IAAjB,CAAsB,SAArC,CADS,CAGT;;AACA,sBAAI,UAAU,GAAA,KAAA,CAAd;;AACA,yBAAQ,QAAQ,CAAC,IAAT,CAAc,KAAd,GAAsB,QAAvB,IAAqC,WAAW,IAAI,QAAQ,CAAC,MAA7D,IAAyE,WAAW,GAAG,CAA9F,EAAkG;AAEjG;AACA,wBAAI,QAAQ,GAAW,KAAK,CAAC,GAAN,CAAU,KAAK,CAAC,IAAN,CAAW,MAAX,GAAoB,WAA9B,EAA2C,CAA3C,CAAvB,CAHiG,CAKjG;AACA;;AACA,wBAAI,UAAJ,EAAgB;AAEf;AACA,sBAAA,UAAU,GAAG,MAAM,CAAC,oBAAP,CAA4B,KAAK,CAAC,IAAlC,EAAwC,QAAxC,EAAkD,IAAlD,EAAwD,KAAK,GAA7D,CAAb;AAEA,qBALD,MAMK;AAEJ;AACA,sBAAA,UAAU,GAAG,MAAM,CAAC,oBAAP,CAA4B,KAAK,CAAC,IAAlC,EAAwC,QAAxC,EAAkD,IAAlD,EAAwD,KAAK,GAA7D,CAAb,CAHI,CAKJ;;AACA,0BAAK,UAAU,CAAC,CAAD,CAAV,CAAc,MAAd,GAAuB,QAAxB,IAAqC,QAAQ,KAAK,CAAtD,EAAyD;AAExD;AACA;AACA,wBAAA,QAAQ,CAAC,OAAT,CAAiB,IAAjB,CAAsB,WAAtB,CAAkC,QAAlC,EAJwD,CAMxD;;AACA,wBAAA,WAAW,GAAG,CAAd;AACA;AAED,qBA7BgG,CA+BjG;;;AACA,wBAAI,WAAW,GAAG,CAAlB,EAAqB;AACpB,sBAAA,QAAQ,CAAC,WAAT,GAAuB,gBAAgB,GAAG,OAAnB,CAA2B,MAAM,CAAC,IAAP,CAAY,UAAU,CAAC,KAAX,EAAZ,CAA3B,CAAvB;AACA,qBAlCgG,CAoCjG;;;AACA,oBAAA,QAAQ,CAAC,IAAT,GAAgB,QAAQ,CAAC,OAAT,CAAiB,OAAjB,EAAhB;AACA,oBAAA,QAAQ,CAAC,IAAT,CAAc,KAAd,GAAsB,IAAI,CAAC,KAAL,CAAW,QAAQ,CAAC,IAAT,CAAc,KAAzB,CAAtB,CAtCiG,CAwCjG;AACA;;AACA,oBAAA,WAAW,GAAG,IAAI,CAAC,IAAL,CAAU,WAAW,GAAG,GAAxB,CAAd;AAEA,mBAjDQ,CAoDT;;;AACA,sBAAI,UAAU,CAAC,MAAX,GAAoB,CAAxB,EAA2B;AAE1B,wBAAI,UAAU,GAAW,EAAzB,CAF0B,CAI1B;;AACA,wBAAI,KAAK,CAAC,QAAN,CAAe,UAAf,CAAJ,EAAgC;AAC/B,0BAAI,KAAK,GAAT,EAAc;AACb,wBAAA,UAAU,IAAI,UAAU,CAAC,IAAX,CAAgB,EAAhB,IAAsB,aAApC;AACA,uBAFD,MAGK;AACJ,wBAAA,UAAU,IAAI,aAAa,GAAG,UAAU,CAAC,IAAX,CAAgB,EAAhB,EAAoB,OAApB,CAA4B,cAA5B,EAA4C,MAA5C,CAA9B;AACA;AACD,qBAZyB,CAc1B;;;AACA,yBAAK,IAAI,CAAC,GAAW,CAAC,GAAG,CAAzB,EAA4B,CAAC,GAAG,MAAM,CAAC,MAAvC,EAA+C,CAAC,EAAhD,EAAoD;AACnD,0BAAI,MAAM,CAAC,CAAD,CAAN,CAAU,IAAV,IAAkB,OAAtB,EAA+B;AAC9B;AACA;AACA;AACA;AACA,wBAAA,UAAU,IAAI,MAAM,CAAC,CAAD,CAAN,CAAU,IAAV,CAAe,OAAf,CAAuB,cAAvB,EAAuC,MAAvC,CAAd;AACA,uBAND,MAOK;AACJ,wBAAA,UAAU,IAAI,MAAM,CAAC,CAAD,CAAN,CAAU,IAAxB;AACA;AACD,qBA1ByB,CA4B1B;;;AAEA,oBAAA,KAAK,CAAC,MAAN,CAAa,CAAC,GAAG,CAAjB,EAAoB,CAApB,EAAuB,UAAvB;AACA,mBApFQ,CAqFT;;;AACA,kBAAA,cAAc,GAAG,IAAjB;AACA;AACD;AACD,aApQG,CAqQJ;;;AACA,gBAAI,KAAK,IAAL,CAAU,KAAV,GAAkB,QAAQ,CAAC,IAAT,CAAc,KAApC,EAA2C;AAC1C,mBAAK,IAAL,CAAU,KAAV,GAAkB,QAAQ,CAAC,IAAT,CAAc,KAAhC;AACA,aAxQG,CA0QJ;AACA;AACA;AACA;;;AAEA,iBAAK,IAAL,CAAU,MAAV,GAAmB,aAAa,GAAG,iBAAnC,CA/QI,CAiRJ;;AACA,gBAAI,CAAC,KAAK,eAAV,EAA2B;AAC1B,cAAA,QAAQ,CAAC,OAAT,CAAiB,IAAjB,CAAsB;AACrB,qBAAK,GADgB;AAErB,qBAAK,aAAa,GAAG,iBAFA;AAGrB,sBAAM,KAAK,CAAC,KAAN,CAAa,KAAK,aAAL,GAAqB,iBAAlC,EAAsD,CAAtD,EAAyD,QAAzD;AAHe,eAAtB;AAKA,aAND,MAOK;AACJ,cAAA,QAAQ,CAAC,OAAT,CAAiB,IAAjB,CAAsB;AACrB,sBAAM,CAAC,KAAK,aAAL,CAAmB,QAAnB;AADc,eAAtB;AAGA;;AACD,YAAA,UAAU,GAAG,KAAb;AACA;AAED,SAhYqC,CAkYtC;;;AACA,YAAI,IAAI,GAAG,QAAQ,CAAC,OAAT,CAAiB,IAA5B;;AACA,YAAI,IAAJ,EAAU;AACT,cAAI,QAAQ,GAAG,IAAI,CAAC,SAApB;;AACA,cAAI,QAAJ,EAAc;AACb,YAAA,QAAQ,CAAC,WAAT,GAAuB,KAAK,GAAL,GACtB,MAAM,CAAC,KAAP,CAAa,QAAQ,CAAC,WAAtB,CADsB,GAEtB,MAAM,CAAC,KAAP,CAAa,QAAQ,CAAC,WAAtB,CAFD;AAGA;AACD,SA3YqC,CA6YtC;;;AACA,QAAA,aAAa,IAAI,iBAAjB,CA9YsC,CAgZtC;;AACA,aAAK,WAAL,CAAiB,QAAjB,EAA2B,CAA3B;AACA,OAnaoB,CAqarB;;;AACA,WAAK,kBAAL;AAEA,WAAK,aAAL,GAAqB,KAArB;;AACA,UAAI,KAAK,IAAL,CAAU,KAAV,IAAmB,CAAnB,IAAwB,KAAK,IAAL,CAAU,MAAV,IAAoB,CAAhD,EAAmD;AAClD,aAAK,aAAL,GAAqB,IAArB;AACA,OA3aoB,CA6arB;;;AACA,WAAK,cAAL,GAAsB,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,GAAN,CAAU,KAAK,IAAL,CAAU,KAApB,EAA2B,KAAK,UAAL,GAAkB,KAAK,gBAAvB,GAA0C,KAAK,iBAA1E,CAAZ,CAAtB;AACA,WAAK,eAAL,GAAuB,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,GAAN,CAAU,KAAK,IAAL,CAAU,MAApB,EAA4B,KAAK,WAAL,GAAmB,KAAK,eAAxB,GAA0C,KAAK,kBAA3E,CAAZ,CAAvB,CA/aqB,CAibrB;;AACA,WAAK,YAAL;AAEA,WAAK,IAAL,CAAU,KAAV,GAAkB,KAAK,cAAvB;AACA,WAAK,IAAL,CAAU,MAAV,GAAmB,KAAK,eAAxB;;AAEA,UAAI,IAAI,IAAI,KAAK,eAAb,IAAgC,IAAI,IAAI,KAAK,cAAjD,EAAiE;AAChE,aAAK,QAAL,CAAc,aAAd;AACA;;AAED,WAAK,UAAL,CAAgB,KAAK,CAAC,MAAtB;AACA,KA5bD,MA6bK;AAEJ;;;AAIA,WAAK,OAAL,CAAa,UAAb,CAAwB,SAAxB;AACA,WAAK,SAAL,GAPI,CASJ;;AACA,UAAI,KAAK,GAAiB,KAAK,OAA/B;AACA,MAAA,KAAK,CAAC,cAAN,GAXI,CAaJ;;AACA,UAAI,EAAE,GAAG,KAAK,KAAL,CAAW,aAAX,EAAT;AACA,MAAA,KAAK,CAAC,GAAN,CAAU,EAAV,EAfI,CAiBJ;AACA;;AACA,UAAI,KAAK,QAAT,EAAmB;AAClB,QAAA,EAAE,CAAC,IAAH,CAAQ;AACP,UAAA,KAAK,EAAE,KAAK;AADL,SAAR;AAGA;;AACD,UAAI,KAAK,SAAT,EAAoB;AACnB,QAAA,EAAE,CAAC,IAAH,CAAQ;AACP,UAAA,MAAM,EAAE,KAAK;AADN,SAAR;AAGA,OA5BG,CA8BJ;AACA;;;AACA,UAAI,WAAW,GAAgB,KAAK,kBAAL,CAAwB,IAAxB,CAA/B;AACA,MAAA,EAAE,CAAC,IAAH,CAAQ,WAAR,CAAoB,WAApB,EAjCI,CAmCJ;;AACA,MAAA,WAAW,CAAC,KAAZ,CAAkB,OAAlB,GAA4B,cAA5B;AACA,UAAM,WAAW,GAAG,WAAW,CAAC,WAAhC;AACA,UAAM,YAAY,GAAG,WAAW,CAAC,YAAjC;AAEA,MAAA,WAAW,CAAC,KAAZ,CAAkB,OAAlB,GAA4B,OAA5B;AACA,WAAK,KAAL,GAAa;AACZ,QAAA,CAAC,EAAE,CADS;AAEZ,QAAA,CAAC,EAAE,CAFS;AAGZ,QAAA,KAAK,EAAE,WAHK;AAIZ,QAAA,MAAM,EAAE;AAJI,OAAb,CAzCI,CAgDJ;AACA;;AACA,MAAA,EAAE,CAAC,IAAH,CAAQ;AACP,QAAA,KAAK,EAAE,WADA;AAEP,QAAA,MAAM,EAAE;AAFD,OAAR,EAlDI,CAuDJ;;AACA,WAAK,kBAAL,GAxDI,CA0DJ;;AACA,WAAK,cAAL,GAAsB,KAAK,CAAC,GAAN,CAAU,KAAK,IAAL,CAAU,KAApB,EAA2B,KAAK,UAAL,GAAkB,KAAK,gBAAvB,GAA0C,KAAK,iBAA1E,CAAtB;AACA,WAAK,eAAL,GAAuB,KAAK,CAAC,GAAN,CAAU,KAAK,IAAL,CAAU,MAApB,EAA4B,KAAK,WAAL,GAAmB,KAAK,eAAxB,GAA0C,KAAK,kBAA3E,CAAvB;AAEA,WAAK,IAAL,CAAU,KAAV,GAAkB,KAAK,cAAvB;AACA,WAAK,IAAL,CAAU,MAAV,GAAmB,KAAK,eAAxB,CA/DI,CAiEJ;;AACA,UAAI,KAAK,QAAT,EAAmB;AAClB,QAAA,WAAW,CAAC,KAAZ,CAAkB,QAAlB,GAA6B,QAA7B;AACA;;AAED,UAAK,WAAW,GAAG,QAAf,IAA6B,YAAY,GAAG,SAAhD,EAA4D;AAC3D,aAAK,WAAL,GAAmB,IAAnB;AACA;AACD,KAxkBF,CA2kBC;;;AACA,SAAK,SAAL;AACA,SAAK,YAAL;AACA,SAAK,gBAAL;;AAEA,QAAI,OAAO,IAAI,MAAf,EAAuB;AACtB,WAAK,KAAL,CAAW,IAAX,CAAgB;AAAE,QAAA,OAAO,EAAE;AAAX,OAAhB;AACA;;AAED,QAAI,KAAK,WAAT,EAAsB;AACrB,WAAK,KAAL,CAAW,SAAX,CAAqB,KAAK,WAA1B;AACA;AACD,GAvlBM;AAylBP;;;;;AAGQ,EAAA,KAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,YAAA;AACC,QAAI,KAAK,aAAT,EAAwB;AACvB,UAAK,KAAK,cAAL,GAAsB,KAAK,IAAL,CAAU,KAAjC,IAA4C,KAAK,eAAL,GAAuB,KAAK,IAAL,CAAU,MAAjF,EAA0F;AACzF,aAAK,OAAL,CAAa,IAAb,CAAkB;AAAE,UAAA,OAAO,EAAE;AAAX,SAAlB;AACA,aAAK,WAAL,GAAmB,IAAnB;AACA,OAHD,MAIK;AACJ,aAAK,OAAL,CAAa,UAAb,CAAwB,SAAxB;AACA,aAAK,WAAL,GAAmB,KAAnB;AACA;AACD;AACD,GAXO;AAaR;;;;;;;AAKO,EAAA,KAAA,CAAA,SAAA,CAAA,YAAA,GAAP,YAAA;AACC;AACA,QAAI,KAAK,GAAiB,KAAK,OAA/B;AACA,QAAI,QAAQ,GAAG,KAAK,CAAC,IAAN,CAAW,QAAX,IAAuB,KAAK,CAAC,IAAN,CAAW,UAAjD,CAHD,CAKC;;AACA,QAAI,CAAC,QAAD,IAAc,QAAQ,IAAI,QAAQ,CAAC,MAAT,IAAmB,CAAjD,EAAqD;AACpD;AACA;;AAED,QAAI,KAAK,GAAG,KAAK,cAAjB;AACA,QAAI,MAAM,GAAG,KAAK,eAAlB,CAXD,CAaC;;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,KAAK,gBAAjB;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,KAAK,iBAAjB;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,KAAK,eAAjB;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,KAAK,kBAAjB,EAjBD,CAmBC;AACA;;AACA,SAAK,IAAI,CAAC,GAAG,QAAQ,CAAC,MAAT,GAAkB,CAA/B,EAAkC,CAAC,IAAI,CAAvC,EAA0C,CAAC,EAA3C,EAA+C;AAC9C;AACA;AACA;AACA,UAAI,IAAI,GAAe,QAAQ,CAAC,CAAD,CAA/B;AAEA,MAAA,IAAI,CAAC,YAAL,CAAkB,aAAlB,EAAiC,KAAK,SAAtC;;AAEA,UAAI,KAAK,eAAT,EAA0B;AACzB,QAAA,IAAI,CAAC,eAAL,CAAqB,GAArB;AACA,QAAA,IAAI,CAAC,eAAL,CAAqB,GAArB;AACA,OAHD,MAIK;AACJ,gBAAQ,KAAK,SAAb;AACC,eAAK,QAAL;AACC,YAAA,IAAI,CAAC,YAAL,CAAkB,GAAlB,EAAuB,CAAC,KAAK,GAAG,CAAT,EAAY,QAAZ,KAAyB,IAAhD;AACA;;AACD,eAAK,KAAL;AACC,gBAAI,KAAK,GAAT,EAAc,CAEb,CAFD,MAGK;AACJ,cAAA,IAAI,CAAC,YAAL,CAAkB,GAAlB,EAAuB,KAAK,CAAC,QAAN,EAAvB;AACA;;AACD;;AACD;AACC,gBAAI,KAAK,GAAT,EAAc;AACb,cAAA,IAAI,CAAC,YAAL,CAAkB,GAAlB,EAAuB,KAAK,CAAC,QAAN,EAAvB;AACA,aAFD,MAGK;AACJ,cAAA,IAAI,CAAC,eAAL,CAAqB,aAArB;AACA;;AACD;AAnBF;;AAsBA,YAAI,CAAC,GAAG,KAAK,CAAC,QAAN,CAAe,IAAI,CAAC,YAAL,CAAkB,GAAlB,CAAf,CAAR;;AAEA,gBAAQ,KAAK,UAAb;AACC,eAAK,QAAL;AACC,YAAA,IAAI,CAAC,YAAL,CAAkB,GAAlB,EAAuB,CAAC,CAAC,CAAC,IAAI,CAAN,IAAW,CAAC,MAAM,GAAG,KAAK,IAAL,CAAU,MAApB,IAA8B,CAA1C,EAA6C,QAA7C,EAAvB;AACA;;AACD,eAAK,QAAL;AACC,YAAA,IAAI,CAAC,YAAL,CAAkB,GAAlB,EAAuB,CAAC,CAAC,CAAC,IAAI,CAAN,IAAW,MAAX,GAAoB,KAAK,IAAL,CAAU,MAA/B,EAAuC,QAAvC,EAAvB;AACA;;AACD;AACC,YAAA,IAAI,CAAC,YAAL,CAAkB,GAAlB,EAAuB,CAAC,CAAC,IAAI,CAAN,EAAS,QAAT,EAAvB;AACA;AATF;AAWA;AACD;AACD,GAvEM;AAyEP;;;;;;;;;;;AASO,EAAA,KAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,UAAyB,IAAzB,EAAuC,CAAvC,EAAiD;AAEhD;AACA,QAAI,OAAO,GAAU,KAAK,KAAL,CAAW,QAAX,CAAoB,MAApB,CAArB;AACA,IAAA,OAAO,CAAC,WAAR,GAAsB,IAAtB,CAJgD,CAMhD;;AACA,IAAA,OAAO,CAAC,IAAR,CAAa;AACZ,WAAK,GADO,CAEZ;AACA;AACA;;AAJY,KAAb,EAPgD,CAchD;;AACA,QAAI,KAAK,CAAC,QAAN,CAAe,CAAf,CAAJ,EAAuB;AACtB,MAAA,OAAO,CAAC,IAAR,CAAa;AACZ,aAAK,CAAC,CAAC,QAAF;AADO,OAAb;AAGA,KAnB+C,CAqBhD;;;AACA,QAAI,KAAK,QAAL,IAAiB,KAAK,IAA1B,EAAgC;AAC/B,MAAA,OAAO,CAAC,IAAR,CAAa;AAAE,oBAAY;AAAd,OAAb;AACA,KAxB+C,CA0BhD;;;AACA,QAAI,KAAK,GAAT,EAAc;AACb,MAAA,OAAO,CAAC,IAAR,CAAa;AACZ,qBAAa;AADD,OAAb;AAIA;;AAED,WAAO,OAAP;AACA,GAnCM;AAqCP;;;;;;;AAKO,EAAA,KAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACC,SAAK,KAAL,GAAa;AAAE,MAAA,CAAC,EAAE,CAAL;AAAQ,MAAA,CAAC,EAAE,CAAX;AAAc,MAAA,KAAK,EAAE,CAArB;AAAwB,MAAA,MAAM,EAAE;AAAhC,KAAb;AACA,GAFM;AAKP;;;;;;;;;AAOO,EAAA,KAAA,CAAA,SAAA,CAAA,kBAAA,GAAP,UAA0B,IAA1B,EAAsC;AAErC;AACA,QAAI,GAAG,GAAgB,QAAQ,CAAC,aAAT,CAAuB,KAAvB,CAAvB;AACA,IAAA,GAAG,CAAC,SAAJ,GAAgB,IAAhB,CAJqC,CAMrC;;AACA,YAAQ,KAAK,SAAb;AACC,WAAK,QAAL;AACC,QAAA,GAAG,CAAC,KAAJ,CAAU,SAAV,GAAsB,QAAtB;AACA;;AACD,WAAK,KAAL;AACC,QAAA,GAAG,CAAC,KAAJ,CAAU,SAAV,GAAsB,OAAtB;AACA;AANF,KAPqC,CAgBrC;;;AACA,QAAI,KAAK,IAAT,EAAe;AACd,MAAA,GAAG,CAAC,KAAJ,CAAU,QAAV,GAAqB,YAArB;AACA,KAFD,MAGK;AACJ,MAAA,GAAG,CAAC,KAAJ,CAAU,UAAV,GAAuB,QAAvB;AACA,KAtBoC,CAwBrC;AACA;;AACA;;;AAIA;;;AACA,QAAI,KAAK,GAAT,EAAc;AACb,MAAA,GAAG,CAAC,KAAJ,CAAU,SAAV,GAAsB,KAAtB,CADa,CAEb;AACA,KAlCoC,CAoCrC;;;AACA,QAAI,KAAK,CAAC,QAAN,CAAe,KAAK,IAApB,CAAJ,EAA+B;AAC9B,MAAA,GAAG,CAAC,KAAJ,CAAU,KAAV,GAAkB,KAAK,IAAL,CAAU,QAAV,EAAlB;AACA;;AAED,WAAO,GAAP;AACA,GA1CM;AA4CP;;;;;;;;;AAOO,EAAA,KAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACC,QAAI,KAAK,GAAiB,KAAK,OAA/B;;AACA,QAAI,CAAC,KAAK,UAAN,IAAoB,KAAK,SAAzB,IAAsC,KAAK,SAA3C,IAAwD,KAAK,SAAjE,EAA4E;AAC3E,MAAA,KAAK,CAAC,QAAN,CAAe;AACd,4BAAoB,MADN;AAEd,wBAAgB;AAFF,OAAf;AAIA,KALD,MAMK,IAAI,KAAK,UAAT,EAAqB;AACzB,MAAA,KAAK,CAAC,WAAN,CAAkB,kBAAlB;AACA,MAAA,KAAK,CAAC,WAAN,CAAkB,cAAlB;AACA;AACD,GAZM;AAcP;;;;;AAGU,EAAA,KAAA,CAAA,SAAA,CAAA,UAAA,GAAV,UAAqB,KAArB,EAAkC;AACjC,SAAK,aAAL;AACA,QAAI,KAAK,GAAoB,KAAK,QAAL,CAAc,UAAd,CAA7B;;AACA,QAAI,KAAK,CAAC,MAAN,IAAgB,KAApB,EAA2B;AAC1B,WAAK,IAAI,CAAC,GAAG,KAAb,EAAoB,CAAC,GAAG,KAAK,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AAC1C,YAAI,IAAI,GAAG,KAAK,CAAC,CAAD,CAAhB;;AACA,YAAI,IAAI,IAAI,IAAI,CAAC,OAAjB,EAA0B;AACzB,UAAA,IAAI,CAAC,OAAL,CAAa,IAAb,CAAkB;AAAE,uBAAW;AAAb,WAAlB;AACA;AACD;AACD;AACD,GAXS;;AAsBV,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,MAAX,EAAe;AAKf;;;SAGA,eAAA;AACC,aAAO,KAAK,gBAAL,CAAsB,MAAtB,CAAP;AACA,KAVc;;AATf;;;;;;;;;SASA,aAAgB,KAAhB,EAA6B;AAC5B;AACA,WAAK,gBAAL,CAAsB,MAAtB,EAA8B,KAA9B,EAAqC,IAArC;AACA,KAHc;oBAAA;;AAAA,GAAf;AAwBA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,MAAX,EAAe;AAwBf;;;SAGA,eAAA;AACC,aAAO,KAAK,gBAAL,CAAsB,MAAtB,CAAP;AACA,KA7Bc;;AAZf;;;;;;;;;;;;SAYA,aAAgB,KAAhB,EAA6B;AAC5B,UAAI,KAAK,gBAAL,CAAsB,MAAtB,EAA8B,KAA9B,EAAqC,IAArC,CAAJ,EAAgD;AAC/C,YAAI,KAAK,WAAT,EAAsB;AACrB,eAAK,WAAL,CAAiB,OAAjB;AACA;;AAED,YAAI,KAAK,eAAT,EAA0B;AACzB,eAAK,eAAL,CAAqB,OAArB;AACA;;AAED,aAAK,WAAL,GAAmB,KAAK,KAAL,CAAW,GAAX,CAAe,MAAf,CAAnB;AACA,aAAK,WAAL,CAAiB,IAAjB,CAAsB;AAAE,eAAK;AAAP,SAAtB;AACA,aAAK,WAAL,CAAiB,IAAjB,CAAsB;AAAE,gBAAM,eAAe,KAAK;AAA5B,SAAtB;;AACA,aAAK,UAAL,CAAgB,IAAhB,CAAqB,KAAK,WAA1B;;AAEA,aAAK,eAAL,GAAuB,KAAK,KAAL,CAAW,QAAX,CAAoB,UAApB,CAAvB;AACA,aAAK,eAAL,CAAqB,MAArB,CAA4B,IAAI,CAAC,KAAjC,EAAwC,YAAxC,EAAsD,gBAAgB,KAAK,GAA3E,EAf+C,CAgB/C;;AACA,aAAK,eAAL,CAAqB,IAArB,CAA0B;AAAE,kBAAQ;AAAV,SAA1B;;AACA,aAAK,UAAL,CAAgB,IAAhB,CAAqB,KAAK,eAA1B;;AACA,aAAK,cAAL;AACA;AACD,KAtBc;oBAAA;;AAAA,GAAf;AAyCA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,gBAAX,EAAyB;AAOzB;;;SAGA,eAAA;AACC,aAAO,KAAK,gBAAL,CAAsB,gBAAtB,CAAP;AACA,KAZwB;;AAVzB;;;;;;;;;;SAUA,aAA0B,KAA1B,EAAuC;AACtC,WAAK,gBAAL,CAAsB,gBAAtB,EAAwC,KAAxC;;AACA,UAAI,KAAK,eAAT,EAA0B;AACzB,aAAK,eAAL,CAAqB,IAArB,CAA0B;AAAE,yBAAgB,KAAK,GAAG,GAAT,GAAgB;AAAjC,SAA1B;AACA;AACD,KALwB;oBAAA;;AAAA,GAAzB;AAsBA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,eAAX,EAAwB;AAIxB;;;SAGA,eAAA;AACC,aAAO,KAAK,gBAAL,CAAsB,eAAtB,CAAP;AACA,KATuB;;AARxB;;;;;;;;SAQA,aAAyB,KAAzB,EAAsC;AACrC,WAAK,gBAAL,CAAsB,eAAtB,EAAuC,KAAvC;AACA,KAFuB;oBAAA;;AAAA,GAAxB;AAgBA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,MAAX,EAAe;AAKf;;;SAGA,eAAA;AACC,aAAO,KAAK,gBAAL,CAAsB,MAAtB,CAAP;AACA,KAVc;;AALf;;;;;SAKA,aAAgB,KAAhB,EAA8B;AAC7B,WAAK,SAAL;AACA,WAAK,gBAAL,CAAsB,MAAtB,EAA8B,KAA9B,EAAqC,IAArC;AACA,KAHc;oBAAA;;AAAA,GAAf;AAwBA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,UAAX,EAAmB;AAKnB;;;SAGA,eAAA;AACC,aAAO,KAAK,gBAAL,CAAsB,UAAtB,CAAP;AACA,KAVkB;;AAZnB;;;;;;;;;;;;SAYA,aAAoB,KAApB,EAAkC;AACjC,WAAK,SAAL;AACA,WAAK,gBAAL,CAAsB,UAAtB,EAAkC,KAAlC,EAAyC,IAAzC;AACA,KAHkB;oBAAA;;AAAA,GAAnB;AAmBA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,WAAX,EAAoB;AAIpB;;;SAGA,eAAA;AACC,aAAO,KAAK,gBAAL,CAAsB,WAAtB,CAAP;AACA,KATmB;;AAPpB;;;;;;;SAOA,aAAqB,KAArB,EAAmC;AAClC,WAAK,gBAAL,CAAsB,WAAtB,EAAmC,KAAnC,EAA0C,IAA1C;AACA,KAFmB;oBAAA;;AAAA,GAApB;AAiBA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,UAAX,EAAmB;AAInB;;;SAGA,eAAA;AACC,aAAO,KAAK,gBAAL,CAAsB,UAAtB,CAAP;AACA,KATkB;;AANnB;;;;;;SAMA,aAAoB,KAApB,EAAiC;AAChC,WAAK,gBAAL,CAAsB,UAAtB,EAAkC,KAAlC,EAAyC,IAAzC;AACA,KAFkB;oBAAA;;AAAA,GAAnB;AAmBA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AAKrB;;;SAGA,eAAA;AACC,aAAO,KAAK,gBAAL,CAAsB,YAAtB,CAAP;AACA,KAVoB;;AARrB;;;;;;;;SAQA,aAAsB,KAAtB,EAAoC;AACnC,WAAK,gBAAL,CAAsB,YAAtB,EAAoC,KAApC,EAA2C,IAA3C;AACA,WAAK,SAAL;AACA,KAHoB;oBAAA;;AAAA,GAArB;AAsBA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,WAAX,EAAoB;AAIpB;;;SAGA,eAAA;AACC,aAAO,KAAK,gBAAL,CAAsB,WAAtB,CAAP;AACA,KATmB;;AAVpB;;;;;;;;;;SAUA,aAAqB,KAArB,EAAqC;AACpC,WAAK,gBAAL,CAAsB,WAAtB,EAAmC,KAAnC,EAA0C,IAA1C;AACA,KAFmB;oBAAA;;AAAA,GAApB;AAkBA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AAIrB;;;;;SAKA,eAAA;AACC,aAAO,KAAK,gBAAL,CAAsB,YAAtB,CAAP;AACA,KAXoB;;AAPrB;;;;;;;SAOA,aAAsB,KAAtB,EAAuC;AACtC,WAAK,gBAAL,CAAsB,YAAtB,EAAoC,KAApC,EAA2C,IAA3C;AACA,KAFoB;oBAAA;;AAAA,GAArB;AA2BA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,MAAX,EAAe;AAIf;;;SAGA,eAAA;AACC,aAAO,KAAK,gBAAL,CAAsB,MAAtB,CAAP;AACA,KATc;;AAbf;;;;;;;;;;;;;SAaA,aAAgB,KAAhB,EAA6B;AAC5B,WAAK,gBAAL,CAAsB,MAAtB,EAA8B,KAA9B,EAAqC,IAArC;AACA,KAFc;oBAAA;;AAAA,GAAf;AAiBA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,eAAX,EAAwB;AAIxB;;;SAGA,eAAA;AACC,aAAO,KAAK,gBAAL,CAAsB,eAAtB,CAAP;AACA,KATuB;;AANxB;;;;;;SAMA,aAAyB,KAAzB,EAAuC;AACtC,WAAK,gBAAL,CAAsB,eAAtB,EAAuC,KAAvC,EAA8C,IAA9C;AACA,KAFuB;oBAAA;;AAAA,GAAxB;AAkBA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,kBAAX,EAA2B;AAI3B;;;SAGA,eAAA;AACC,aAAO,KAAK,gBAAL,CAAsB,kBAAtB,CAAP;AACA,KAT0B;;AAP3B;;;;;;;SAOA,aAA4B,KAA5B,EAA0C;AACzC,WAAK,gBAAL,CAAsB,kBAAtB,EAA0C,KAA1C,EAAiD,IAAjD;AACA,KAF0B;oBAAA;;AAAA,GAA3B;AAWA;;;;;AAIO,EAAA,KAAA,CAAA,SAAA,CAAA,cAAA,GAAP,YAAA,CAAiC,CAA1B;AAEP;;;;;;;;;AAOO,EAAA,KAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,KAAnB,EAAgC;AAC/B,SAAK,aAAL;AACA,QAAI,KAAK,GAAG,KAAK,QAAL,CAAc,UAAd,CAAZ;AACA,WAAO,KAAK,CAAC,MAAN,GAAe,KAAf,GAAuB,KAAK,CAAC,KAAD,CAA5B,GAAsC,SAA7C;AACA,GAJM;AAMP;;;;;;;;;AAOO,EAAA,KAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,IAAnB,EAAwC,KAAxC,EAAqD;AACpD,SAAK,aAAL;AACA,SAAK,QAAL,CAAc,UAAd,EAA0B,KAA1B,IAAmC,IAAnC;AACA,GAHM;AAKP;;;;;AAGQ,EAAA,KAAA,CAAA,SAAA,CAAA,aAAA,GAAR,YAAA;AACC,QAAI,CAAC,KAAK,CAAC,QAAN,CAAe,KAAK,QAAL,CAAc,UAAd,CAAf,CAAL,EAAgD;AAC/C,WAAK,QAAL,CAAc,UAAd,EAA0B,EAA1B,EAA8B,CAA9B;AACA;AACD,GAJO;AAMR;;;;;;;;;AAOO,EAAA,KAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,QAAnB,EAAqC;AACpC,QAAI,KAAK,qBAAT,EAAgC;AAC/B,WAAK,qBAAL,CAA2B,OAA3B;AACA;;AACD,QAAI,QAAJ,EAAc;AACb,WAAK,qBAAL,GAA6B,IAAI,aAAJ,CAAkB,CAC9C,QAAQ,CAAC,MAAT,CAAgB,EAAhB,CAAmB,cAAnB,EAAmC,KAAK,UAAxC,EAAoD,IAApD,EAA0D,KAA1D,CAD8C,EAE9C,QAAQ,CAAC,MAAT,CAAgB,EAAhB,CAAmB,qBAAnB,EAA0C,KAAK,UAA/C,EAA2D,IAA3D,EAAiE,KAAjE,CAF8C,EAG9C,QAAQ,CAAC,MAAT,CAAgB,EAAhB,CAAmB,wBAAnB,EAA6C,KAAK,UAAlD,EAA8D,IAA9D,EAAoE,KAApE,CAH8C,EAI9C,QAAQ,CAAC,MAAT,CAAgB,EAAhB,CAAmB,iBAAnB,EAAsC,KAAK,UAA3C,EAAuD,IAAvD,EAA6D,KAA7D,CAJ8C,CAAlB,CAA7B;AAMA;;AACD,IAAA,MAAA,CAAA,SAAA,CAAM,WAAN,CAAiB,IAAjB,CAAiB,IAAjB,EAAkB,QAAlB;AACA,GAbM;;AAqBP,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,gBAAX,EAAyB;AANzB;;;;;;SAMA,eAAA;AACC,aAAO,KAAK,CAAC,QAAN,CAAe,KAAK,QAApB,IAAgC,KAAK,QAArC,GAAgD,KAAK,UAA5D;AACA,KAFwB;oBAAA;;AAAA,GAAzB;AASA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,iBAAX,EAA0B;AAL1B;;;;;SAKA,eAAA;AACC,aAAO,KAAK,CAAC,QAAN,CAAe,KAAK,SAApB,IAAiC,KAAK,SAAtC,GAAkD,KAAK,WAA9D;AACA,KAFyB;oBAAA;;AAAA,GAA1B,EAp8CD,CAw8CC;;AACO,EAAA,KAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,IAArB,EAAmC,KAAnC,EAAiD;AAChD,QAAI,OAAO,GAAG,KAAK,KAAL,CAAW,GAAX,CAAe,OAAf,CAAd;AACA,IAAA,OAAO,CAAC,WAAR,GAAsB,IAAtB;;AACA,QAAI,KAAJ,EAAW;AACV,MAAA,OAAO,CAAC,IAAR,CAAa,YAAb,CAA0B,OAA1B,EAAmC,KAAnC;AACA;;AACD,WAAO,OAAP;AACA,GAPM;AASP;;;;;;AAIO,EAAA,KAAA,CAAA,SAAA,CAAA,cAAA,GAAP,YAAA;AACC,IAAA,MAAA,CAAA,SAAA,CAAM,cAAN,CAAoB,IAApB,CAAoB,IAApB;;AACA,SAAK,cAAL;AACA,GAHM;;AAUP,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,aAAX,EAAsB;AAOtB;;;SAGA,eAAA;AACC,UAAI,KAAK,GAAG,KAAK,gBAAL,CAAsB,aAAtB,CAAZ;;AACA,UAAI,CAAC,KAAL,EAAY;AACX,QAAA,KAAK,GAAG,KAAK,cAAL,CACP,MAAM,CAAC,SAAP,CACC,MAAM,CAAC,UAAP,CAAkB,KAAK,IAAvB,IACG,KAAK,IADR,GAEG,KAAK,IAHT,CADO,CAAR;AAOA;;AACD,aAAO,KAAP;AACA,KAtBqB;;AALtB;;;;;SAKA,aAAuB,KAAvB,EAAoC;AACnC,MAAA,KAAK,GAAG,KAAK,CAAC,MAAN,CAAa,KAAb,CAAR;;AACA,UAAI,KAAK,gBAAL,CAAsB,aAAtB,EAAqC,KAArC,CAAJ,EAAiD;AAChD,aAAK,kBAAL;AACA;AACD,KALqB;oBAAA;;AAAA,GAAtB;AAuBD,SAAA,KAAA;AAAC,CAv/CD,CAA2B,SAA3B,CAAA;;;AAy/CA;;;;;;;AAMA,QAAQ,CAAC,iBAAT,CAA2B,OAA3B,IAAsC,KAAtC;AAEA;;;;AAIA;;;;AAGA,YAAY,CAAC,IAAb,CAAkB;AACjB,EAAA,QAAQ,EAAE,qBAAqB,CAAC,QADf;AAEjB,EAAA,KAAK,EAAE,eAAS,MAAT,EAAiB,OAAjB,EAAwB;AAC9B,QAAI,MAAM,YAAY,KAAlB,IAA2B,MAAM,CAAC,MAAlC,IAA4C,MAAM,CAAC,MAAP,CAAc,YAA9D,EAA4E;AAC3E,UAAI,KAAK,GAAG,MAAM,CAAC,MAAP,CAAc,MAAd,CAAqB,OAArB,CAAZ;AACA,MAAA,KAAK,CAAC,UAAN,CAAiB,QAAjB,GAA4B,IAA5B;AACA,aAAO,KAAP;AACA;;AAED,WAAO,IAAP;AACA;AAVgB,CAAlB","sourcesContent":["/**\r\n * Text class deals with all text placed on chart.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container, IContainerProperties, IContainerAdapters, IContainerEvents } from \"../Container\";\r\nimport { DataItem } from \"../DataItem\";\r\nimport { TextValign } from \"../defs/TextValign\";\r\nimport { TextAlign } from \"../defs/TextAlign\";\r\nimport { IRectangle } from \"../defs/IRectangle\";\r\nimport { AMElement } from \"../rendering/AMElement\";\r\nimport { Group } from \"../rendering/Group\";\r\nimport { registry } from \"../Registry\";\r\nimport { ITextChunk, getTextFormatter } from \"../formatters/TextFormatter\";\r\nimport { MultiDisposer } from \"../utils/Disposer\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $utils from \"../utils/Utils\";\r\nimport * as $type from \"../utils/Type\";\r\nimport { Paper } from \"../rendering/Paper\";\r\nimport * as $dom from \"../utils/DOM\";\r\nimport { defaultRules, ResponsiveBreakpoints } from \"../utils/Responsive\";\r\n\r\n\r\n/**\r\n * Defines properties for [[Text]].\r\n */\r\nexport interface ILabelProperties extends IContainerProperties {\r\n\r\n\t/**\r\n\t * Horizontal align of the text.\r\n\t *\r\n\t * @default \"start\"\r\n\t */\r\n\ttextAlign?: TextAlign;\r\n\r\n\t/**\r\n\t * Vertical align of the text.\r\n\t *\r\n\t * @default \"top\"\r\n\t */\r\n\ttextValign?: TextValign;\r\n\r\n\t/**\r\n\t * A plain text content.\r\n\t */\r\n\ttext?: string;\r\n\r\n\t/**\r\n\t * Should the lines wrap if they do not fit into max width?\r\n\t *\r\n\t * @default false\r\n\t */\r\n\twrap?: boolean;\r\n\r\n\t/**\r\n\t * Should the text be selectable>\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tselectable?: boolean;\r\n\r\n\t/**\r\n\t * HTML content.\r\n\t */\r\n\thtml?: string;\r\n\r\n\t/**\r\n\t * Should the lines be truncated (optionally with ellipsis) if they do not\r\n\t * fit into max width?\r\n\t *\r\n\t * @default false\r\n\t */\r\n\ttruncate?: boolean;\r\n\r\n\t/**\r\n\t * If `truncate` is enabled, should Label try to break only on full words\r\n\t * (`true`), or whenever needed, including middle of the word. (`false`)\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tfullWords?: boolean;\r\n\r\n\t/**\r\n\t * If lines are truncated, this ellipsis will be added at the end.\r\n\t *\r\n\t * @default \"â€¦\"\r\n\t */\r\n\tellipsis?: string;\r\n\r\n\t/**\r\n\t * Hide text of it does not fit into element's dimensions?\r\n\t *\r\n\t * @default false\r\n\t */\r\n\thideOversized?: boolean;\r\n\r\n\t/**\r\n\t * If set to `true` square-bracket formatting blocks will be treated as\r\n\t * regular text.\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tignoreFormatting?: boolean;\r\n\r\n\t/**\r\n\t * Path string along which text should be arranged\r\n\t */\r\n\tpath?: string\r\n\r\n\t/**\r\n\t * Relative label location on path.\r\n\t */\r\n\tlocationOnPath?: number;\r\n\r\n\t/**\r\n\t * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n\t * the label.\r\n\t *\r\n\t * @default -0.27\r\n\t */\r\n\tbaseLineRatio?: number;\r\n}\r\n\r\n/**\r\n * Text line information.\r\n *\r\n * Objects used to hold cached information about lines in a Text element.\r\n */\r\nexport interface ITextLineInfo {\r\n\r\n\t/**\r\n\t * Measurements for the bounding box of the line.\r\n\t */\r\n\t\"bbox\"?: IRectangle,\r\n\r\n\t/**\r\n\t * A reference to an SVG `<g>` element that holds line elements.\r\n\t */\r\n\t\"element\"?: Group,\r\n\r\n\t/**\r\n\t * Indicates if line contains more than one element, e.g. has multiple\r\n\t * formatted blocks.\r\n\t */\r\n\t\"complex\"?: boolean,\r\n\r\n\t\"text\"?: string,\r\n\r\n\t\"style\"?: string\r\n};\r\n\r\n/**\r\n * Defines events for [[Text]].\r\n */\r\nexport interface ILabelEvents extends IContainerEvents { }\r\n\r\n/**\r\n * Adapters for [[Text]].\r\n *\r\n * Includes both the [[Adapter]] definitions and properties.\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface ILabelAdapters extends IContainerAdapters, ILabelProperties {\r\n\r\n\t/**\r\n\t * Applied to the final formatted label text.\r\n\t */\r\n\ttextOutput: string;\r\n\r\n\t/**\r\n\t * Applied to the final formatted label HTML.\r\n\t */\r\n\thtmlOutput: string;\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Text is used to display highly configurable, data-enabled textual elements.\r\n *\r\n * ## Data Binding\r\n *\r\n * A Text element can dynamically parse and populate its contents with values\r\n * from a [[DataItem]].\r\n *\r\n * To activate such binding, set element's `dataItem` property.\r\n *\r\n * When activated, text contents will be parsed for special tags, e.g.:\r\n *\r\n * ```TypeScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n * ```JavaScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n *\r\n * The above will automatically replace \"{title}\" in the string with the\r\n * actual data value from `myDataItem`.\r\n *\r\n * Note, that most often dataItem is set by the Component.\r\n *\r\n *\r\n * @see {@link ILabelEvents} for a list of available events\r\n * @see {@link ILabelAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/} for info on string formatting and data binding\r\n * @todo Vertical align\r\n * @important\r\n */\r\nexport class Label extends Container {\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: ILabelProperties;\r\n\r\n\t/**\r\n\t * Defines Adapter type.\r\n\t */\r\n\tpublic _adapter!: ILabelAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: ILabelEvents;\r\n\r\n\t/**\r\n\t * Indicates if the whole text does not fit into max dimenstions set for it.\r\n\t */\r\n\tpublic isOversized: boolean = false;\r\n\r\n\t/**\r\n\t * Currently formatted text, read only.\r\n\t */\r\n\tpublic currentText: string;\r\n\r\n\t/**\r\n\t * Current format to be used for outputing text.\r\n\t */\r\n\tprotected _currentFormat: string;\r\n\r\n\t/**\r\n\t * [_sourceDataItemEvents description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _sourceDataItemEvents: MultiDisposer;\r\n\r\n\r\n\tprotected _prevStatus: string;\r\n\r\n\t/**\r\n\t * SVG path element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic pathElement: $type.Optional<AMElement>;\r\n\r\n\t/**\r\n\t * SVG textpath element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic textPathElement: $type.Optional<Group>;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Execute super's constructor\r\n\t\tsuper();\r\n\r\n\t\t// Set this class name\r\n\t\tthis.className = \"Label\";\r\n\r\n\t\tthis.fill = new InterfaceColorSet().getFor(\"text\");\r\n\r\n\t\t// not good to set this, as then these will appear on each label and values set on container won't be applied.\r\n\t\t//this.textDecoration = \"none\";\r\n\t\t//this.fontWeight = \"normal\";\r\n\r\n\r\n\t\t// Set defaults\r\n\t\tthis.wrap = false;\r\n\t\tthis.truncate = false;\r\n\t\tthis.fullWords = true;\r\n\t\tthis.ellipsis = \"â€¦\";\r\n\t\tthis.textAlign = \"start\";\r\n\t\tthis.textValign = \"top\";\r\n\r\n\t\tthis.layout = \"absolute\";\r\n\t\tthis.baseLineRatio = -0.27;\r\n\t\t//this.pixelPerfect = true;\r\n\t\tthis._positionPrecision = 1;\r\n\r\n\t\t// Add events to watch for maxWidth/maxHeight changes so that we can\r\n\t\t// invalidate this\r\n\t\tthis.events.on(\"maxsizechanged\", () => {\r\n\t\t\tif (this.inited) {\r\n\t\t\t\tthis.handleMaxSize()\r\n\t\t\t}\r\n\t\t}, this, false);\r\n\r\n\t\t// this solves strange bug when text just added to svg is 0x0\r\n\t\tthis.events.once(\"validated\", this.handleValidate, this, false);\r\n\r\n\t\t// Aply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * A placeholder method that is called **after** element finishes drawing\r\n\t * itself.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected afterDraw(): void {\r\n\t\t// since we removed validatePosition from sprite, we still need it here to handle rotated text\r\n\t\tsuper.afterDraw();\r\n\t\tthis.validatePosition();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Sets [[Paper]] instance to use to draw elements.\r\n\t * @ignore\r\n\t * @param paper Paper\r\n\t * @return true if paper was changed, false, if it's the same\r\n\t */\r\n\tpublic setPaper(paper: Paper): boolean {\r\n\r\n\t\tlet changed = super.setPaper(paper);\r\n\r\n\t\tif (changed) {\r\n\t\t\tthis.hardInvalidate();\r\n\t\t}\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected handleValidate() {\r\n\t\tif ((this.currentText || this.text) && (this.bbox.width == 0 || this.bbox.height == 0)) {\r\n\t\t\tregistry.events.once(\"exitframe\", this.hardInvalidate, this);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected handleMaxSize() {\r\n\t\tif (\r\n\t\t\t(this.bbox.width > this.availableWidth)\r\n\t\t\t|| ((this.bbox.width < this.availableWidth) && (this.isOversized || this.truncate))\r\n\t\t\t|| (this.bbox.height > this.availableHeight)\r\n\t\t\t|| ((this.bbox.height < this.availableHeight) && this.isOversized)\r\n\t\t) {\r\n\t\t\tthis.invalidate();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.alignSVGText();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [arrange description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic arrange(): void {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Updates current text according to data item and supported features.\r\n\t * Returns `true` if current text has changed.\r\n\t *\r\n\t * @return Text changed?\r\n\t */\r\n\tprotected updateCurrentText(): boolean {\r\n\t\t// Determine output format\r\n\t\tlet output: string, text: string;\r\n\r\n\t\tif ($utils.isNotEmpty(this.html) && this.paper.supportsForeignObject()) {\r\n\r\n\t\t\t// We favor HTML text if it's set and browser supports `foreignObject`\r\n\t\t\toutput = \"html\";\r\n\t\t\ttext = this.html;\r\n\t\t}\r\n\t\telse {\r\n\t\t\toutput = \"svg\";\r\n\t\t\ttext = this.text;\r\n\t\t}\r\n\r\n\t\t// Need to toString source?\r\n\t\tif ($type.isObject(text as any)) {\r\n\t\t\ttext = text.toString();\r\n\t\t}\r\n\r\n\t\t// Need to format text all the time\r\n\t\tif ($type.hasValue(text) && text !== \"\") {\r\n\t\t\ttext = this.populateString(text, this.dataItem);\r\n\t\t}\r\n\r\n\t\tif (output == \"html\") {\r\n\t\t\tif (this._adapterO) {\r\n\t\t\t\ttext = this._adapterO.apply(\"htmlOutput\", text);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (this._adapterO) {\r\n\t\t\t\ttext = this._adapterO.apply(\"textOutput\", text);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Update the text\r\n\t\tlet changed = text != this.currentText || output != this._currentFormat;\r\n\t\tthis.currentText = text;\r\n\t\tthis._currentFormat = output;\r\n\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t/**\r\n\t * Hard invalidate means the text will be redrawn even if it hasn't changed.\r\n\t * This is used when we change `fontSize`, `fontFamily`, or for some other\r\n\t * reasons.\r\n\t */\r\n\tpublic hardInvalidate() {\r\n\t\tthis._prevStatus = \"\";\r\n\t\tthis.invalidate();\r\n\t}\r\n\r\n\t/**\r\n\t * Gets line bbox, uses caching to save cpu\r\n\t * @ignore\r\n\t */\r\n\tprotected getLineBBox(lineInfo: ITextLineInfo) {\r\n\t\t//let cacheKey = lineInfo.text + lineInfo.style;\r\n\r\n\t\t//let lineBBox = this.getCache(cacheKey);\r\n\t\t//if (!lineBBox) {\r\n\t\t//lineBBox = lineInfo.element.getBBox();\r\n\t\t//if (lineBBox.width != 0 && lineBBox.height != 0) {\r\n\t\t//\tthis.setCache(cacheKey, lineBBox, 5000);\r\n\t\t//}\r\n\t\t//}\r\n\r\n\t\tlet element = lineInfo && lineInfo.element;\r\n\t\tlet node = element && element.node;\r\n\r\n\t\t// Check for the parent Node to avoid FF from throwing errors\r\n\t\tif (node && node.parentNode) {\r\n\t\t\tlineInfo.bbox = element.getBBox();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Draws the textual label.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic draw(): void {\r\n\r\n\t\t// Draw super\r\n\t\tsuper.draw();\r\n\r\n\t\tlet oldW = this.bbox.width;\r\n\t\tlet oldH = this.bbox.height;\r\n\r\n\t\tlet topParent = this.topParent;\r\n\t\tif (topParent) {\r\n\t\t\tif (!topParent.maxWidth || !topParent.maxHeight) {\r\n\t\t\t\ttopParent.events.once(\"maxsizechanged\", this.hardInvalidate, this, false);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Calculate max width and height\r\n\t\tlet maxWidth: number = $math.max(this.availableWidth - this.pixelPaddingLeft - this.pixelPaddingRight, 0);\r\n\t\tlet maxHeight: number = $math.max(this.availableHeight - this.pixelPaddingTop - this.pixelPaddingBottom, 0);\r\n\r\n\t\t// save\r\n\t\tlet status = maxHeight + \",\" + maxWidth + this.wrap + this.truncate + this.fullWords + this.rtl + this.ellipsis;\r\n\r\n\t\t// Update text\r\n\t\tif (!this.updateCurrentText() && this.inited && this._prevStatus == status) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._measuredWidth = 0;\r\n\t\tthis._measuredHeight = 0;\r\n\r\n\t\t// Reset\r\n\t\tthis.isOversized = false;\r\n\r\n\t\t// Determine output format\r\n\t\tlet output = this._currentFormat;\r\n\t\tlet text = this.currentText;\r\n\r\n\t\t// Empty string\r\n\t\tif (!$type.hasValue(text) || text == \"\") {\r\n\t\t\tthis.element.attr({ display: \"none\" });\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Chop up text into lines\r\n\t\t// We're still processing SVG and HTML in the same way for now\r\n\t\tlet lines: string[] = text.split(\"\\n\");\r\n\r\n\t\t// Do we need to go through the trouble of measuring lines\r\n\t\t//let measure: boolean = true;// (lines.length > 1) || this.wrap;\r\n\r\n\t\tthis._prevStatus = status;\r\n\r\n\t\tthis.textAlign = this.textAlign;\r\n\r\n\t\t// need this to measure\r\n\t\tlet display = this.group.getAttr(\"display\");\r\n\t\tif (display == \"none\") {\r\n\t\t\tthis.group.removeAttr(\"display\");\r\n\t\t}\r\n\r\n\t\tif (this.textPathElement) {\r\n\t\t\tthis.textPathElement.removeChildren();\r\n\t\t}\r\n\r\n\t\t// SVG or HTML?\r\n\t\tif (output === \"svg\") {\r\n\t\t\t/**\r\n\t\t\t * SVG\r\n\t\t\t */\r\n\r\n\t\t\tthis.element.removeAttr(\"display\");\r\n\r\n\t\t\t// Clear the element\r\n\t\t\tlet group: Group = <Group>this.element;\r\n\r\n\t\t\tthis.resetBBox();\r\n\r\n\t\t\t// Init state variables\r\n\t\t\tlet currentHeight: number = 0;\r\n\t\t\tlet currentFormat: string = \"\";\r\n\r\n\t\t\t// Process each line\r\n\t\t\tfor (let i = 0; i < lines.length; i++) {\r\n\r\n\t\t\t\t// Get line\r\n\t\t\t\tlet line: string = lines[i];\r\n\r\n\t\t\t\t// Check if line is empty\r\n\t\t\t\tif (line == \"\") {\r\n\t\t\t\t\t// It is, let's just update currentHeight and go to the next one\r\n\t\t\t\t\t// If it's the first line, we'll have to use arbirary line height,\r\n\t\t\t\t\t// since there's nothing to measure. For subsequent lines we can take\r\n\t\t\t\t\t// previous line's height\r\n\t\t\t\t\tlet tempElement = this.getSVGLineElement(\"\", 0);\r\n\t\t\t\t\ttempElement.add(\r\n\t\t\t\t\t\tthis.getSvgElement(\r\n\t\t\t\t\t\t\t\".\",\r\n\t\t\t\t\t\t\tgetTextFormatter().translateStyleShortcuts(currentFormat)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tgroup.add(tempElement);\r\n\t\t\t\t\tlet offset = Math.ceil(tempElement.getBBox().height);\r\n\t\t\t\t\tif (offset > 0) {\r\n\t\t\t\t\t\tcurrentHeight += offset;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgroup.removeElement(tempElement);\r\n\r\n\t\t\t\t\t// Clear cache if necessary\r\n\t\t\t\t\tlet lineInfo = this.getLineInfo(i);\r\n\t\t\t\t\tif (lineInfo) {\r\n\t\t\t\t\t\tlineInfo.text = \"\";\r\n\t\t\t\t\t\tlineInfo.element.textContent = \"\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Chunk up the line and process each chunk\r\n\t\t\t\tlet chunks: ITextChunk[] = getTextFormatter().chunk(line, null, this.ignoreFormatting);\r\n\t\t\t\tlet currentLineHeight: number = 0;\r\n\t\t\t\tlet firstChunk: boolean = true;\r\n\t\t\t\tlet skipTextChunks: boolean = false;\r\n\r\n\t\t\t\t// Create line element or grab it from cache\r\n\t\t\t\tlet lineInfo = this.getLineInfo(i);\r\n\r\n\t\t\t\tif (lineInfo) {\r\n\t\t\t\t\t// Empty line\r\n\t\t\t\t\tlineInfo.text = \"\";\r\n\t\t\t\t\tlineInfo.element.textContent = \"\";\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Init new line info\r\n\t\t\t\t\tlineInfo = {\r\n\t\t\t\t\t\t\"text\": \"\",\r\n\t\t\t\t\t\t\"element\": this.getSVGLineElement(\"\", 0),\r\n\t\t\t\t\t\t\"complex\": false\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Create the line element\r\n\t\t\t\t\t//lineInfo.element = this.getSVGLineElement(\"\", 0);\r\n\t\t\t\t\t//lineElement = this.getSVGLineElement(\"\", 0);\r\n\t\t\t\t\tgroup.add(lineInfo.element);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlineInfo.element.removeAttr(\"display\");\r\n\t\t\t\tlineInfo.element.removeChildren(); // memory leak without this\r\n\r\n\t\t\t\tif (this.textPathElement) {\r\n\t\t\t\t\tlineInfo.element.add(this.textPathElement);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*// @todo not needed anymore\r\n\t\t\t\tif (this.rtl) {\r\n\t\t\t\t\tchunks.reverse();\r\n\t\t\t\t}*/\r\n\r\n\t\t\t\t// Process each chunk\r\n\t\t\t\tfor (let x: number = 0; x < chunks.length; x++) {\r\n\r\n\t\t\t\t\t// If there's more than one chunk, means the line is \"complex\"\r\n\t\t\t\t\tif (x) {\r\n\t\t\t\t\t\tlineInfo.complex = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Get chunk\r\n\t\t\t\t\tlet chunk = chunks[x];\r\n\r\n\t\t\t\t\t// Is this chunk format or text?\r\n\t\t\t\t\tif (chunk.type === \"format\") {\r\n\r\n\t\t\t\t\t\t// Log current format, so that we can apply it to multiple lines if\r\n\t\t\t\t\t\t// necessary\r\n\t\t\t\t\t\tcurrentFormat = chunk.text;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t// It's text block\r\n\r\n\t\t\t\t\t\t// Need to skip?\r\n\t\t\t\t\t\t// We do this when truncating. We can't just simply go ahead and\r\n\t\t\t\t\t\t// abandon chunk processing as they might have formatting\r\n\t\t\t\t\t\t// instructions in them that are relevant for subsequent lines\r\n\t\t\t\t\t\tif (skipTextChunks) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Add chunk to the current element\r\n\t\t\t\t\t\t//lineInfo.element.content += $utils.trim(getTextFormatter().format(currentFormat + chunk.text, output));\r\n\r\n\t\t\t\t\t\tlineInfo.text = chunk.text;\r\n\t\t\t\t\t\tlineInfo.style = getTextFormatter().translateStyleShortcuts(currentFormat);\r\n\r\n\t\t\t\t\t\tlet tspan = this.getSvgElement(lineInfo.text, lineInfo.style);\r\n\r\n\t\t\t\t\t\tif (this.textPathElement) {\r\n\t\t\t\t\t\t\tthis.textPathElement.add(tspan);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tlineInfo.element.add(tspan);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tthis.getLineBBox(lineInfo);\r\n\t\t\t\t\t\tlineInfo.bbox.width = Math.ceil(lineInfo.bbox.width);\r\n\r\n\t\t\t\t\t\t// Updated current line height\r\n\t\t\t\t\t\tif (currentLineHeight < lineInfo.bbox.height) {\r\n\t\t\t\t\t\t\tcurrentLineHeight = lineInfo.bbox.height;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Wrapping?\r\n\t\t\t\t\t\tif ((this.wrap || this.truncate) && (lineInfo.bbox.width > maxWidth)) {\r\n\r\n\t\t\t\t\t\t\t// Set oversized\r\n\t\t\t\t\t\t\tthis.isOversized = true;\r\n\r\n\t\t\t\t\t\t\t// Take temporary measurements\r\n\t\t\t\t\t\t\tlet lineText: string = lineInfo.element.textContent;\r\n\t\t\t\t\t\t\tlet avgCharWidth: number = (lineInfo.bbox.width / lineText.length); // * .9;\r\n\r\n\t\t\t\t\t\t\t// Calculate average number of symbols / width\r\n\t\t\t\t\t\t\tlet excessChars: number = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\r\n\r\n\t\t\t\t\t\t\t// Are we truncating or auto-wrapping text?\r\n\t\t\t\t\t\t\tif (this.truncate) {\r\n\r\n\t\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t\t * Processing line truncation\r\n\t\t\t\t\t\t\t\t * With the addition of each text chunk we measure if current\r\n\t\t\t\t\t\t\t\t * line does not exceed maxWidth. If it does, we will stop\r\n\t\t\t\t\t\t\t\t * addition of further chunks as well as try to truncate\r\n\t\t\t\t\t\t\t\t * current or any number of previous chunks with an added\r\n\t\t\t\t\t\t\t\t * ellipsis\r\n\t\t\t\t\t\t\t\t */\r\n\r\n\t\t\t\t\t\t\t\t// Indicator whether we need to add ellipsis to the current\r\n\t\t\t\t\t\t\t\t// element, even if it fits. This is needed to indicate\r\n\t\t\t\t\t\t\t\t// whether we have already removed some subsequent chunks in\r\n\t\t\t\t\t\t\t\t// which case we need to add ellipsis.\r\n\t\t\t\t\t\t\t\tlet addEllipsis: boolean = false;\r\n\r\n\t\t\t\t\t\t\t\t// Process each child in the temporary line, until the whole\r\n\t\t\t\t\t\t\t\t// line fits, preferably with an ellipsis\r\n\t\t\t\t\t\t\t\t// TODO use iterator instead\r\n\t\t\t\t\t\t\t\tlet node = lineInfo.element.node;\r\n\t\t\t\t\t\t\t\tif (node && node.childNodes) {\r\n\t\t\t\t\t\t\t\t\tfor (let e = lineInfo.element.node.childNodes.length - 1; e >= 0; e--) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Get current element\r\n\t\t\t\t\t\t\t\t\t\tlet node = lineInfo.element.node.childNodes[e];\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Add ellipsis only if previous chunk was removed in full\r\n\t\t\t\t\t\t\t\t\t\t// and this chunk already fits\r\n\t\t\t\t\t\t\t\t\t\t//if (addEllipsis && (bbox.width <= maxWidth)) {\r\n\t\t\t\t\t\t\t\t\t\tif (addEllipsis && (lineInfo.bbox.width <= maxWidth)) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Add ellipsis\r\n\t\t\t\t\t\t\t\t\t\t\tnode.textContent += \" \" + this.ellipsis;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Measure again (we need to make sure ellipsis fits)\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox = lineInfo.element.getBBox();\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// If it fits, we're done here\r\n\t\t\t\t\t\t\t\t\t\t\t// If it doesn't we continue rolling\r\n\t\t\t\t\t\t\t\t\t\t\tif (lineInfo.bbox.width <= maxWidth) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\taddEllipsis = false;\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Get element text\r\n\t\t\t\t\t\t\t\t\t\tlet elementText = node.textContent;\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Calculate average number of symbols / width\r\n\t\t\t\t\t\t\t\t\t\tlineText = lineInfo.element.textContent;\r\n\t\t\t\t\t\t\t\t\t\texcessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Do this until we fit\r\n\t\t\t\t\t\t\t\t\t\twhile ((lineInfo.bbox.width > maxWidth) && (excessChars <= lineText.length) && (excessChars > 0)) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Calculate max available chars\r\n\t\t\t\t\t\t\t\t\t\t\tlet maxChars: number = $math.max(lineText.length - excessChars - this.ellipsis.length, 1);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Is there anything left?\r\n\t\t\t\t\t\t\t\t\t\t\tif (maxChars <= 1) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Nope, let's jump to the previous item\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Set excess characters to zero so that this loop does\r\n\t\t\t\t\t\t\t\t\t\t\t\t// not repeat when it over\r\n\t\t\t\t\t\t\t\t\t\t\t\texcessChars = 0;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Add ellipsis to previous item\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Subsequent iterations will check if the ellipsis fits\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (e > 0) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Indicating to add ellipsis to previous item\r\n\t\t\t\t\t\t\t\t\t\t\t\t\taddEllipsis = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Removing this node\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlineInfo.element.node.removeChild(node);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Truncate the text\r\n\t\t\t\t\t\t\t\t\t\t\telementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, this.fullWords, this.rtl);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ((elementText.length > maxChars) && this.fullWords) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Still too long?\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Let's try truncating breaking words anyway\r\n\t\t\t\t\t\t\t\t\t\t\t\telementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, false, this.rtl);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Set truncated text\r\n\t\t\t\t\t\t\t\t\t\t\tnode.textContent = elementText;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Measure again\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox = lineInfo.element.getBBox();\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Increase excess characters count, just in case it still\r\n\t\t\t\t\t\t\t\t\t\t\t// doesn't fit and we have to go at it again\r\n\t\t\t\t\t\t\t\t\t\t\texcessChars = Math.ceil(excessChars * 1.1);\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Do not process further chunks\r\n\t\t\t\t\t\t\t\t\t\tskipTextChunks = true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t\t * Processign auto-wrap\r\n\t\t\t\t\t\t\t\t * In this case we're going to be adding text chunks until\r\n\t\t\t\t\t\t\t\t * they don't fit into current line. Once that happens we will\r\n\t\t\t\t\t\t\t\t * inject the rest of the chunks to the next line\r\n\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\t// Get last node added and measure it\r\n\t\t\t\t\t\t\t\tlet node = lineInfo.element.node;\r\n\t\t\t\t\t\t\t\tif (node) {\r\n\t\t\t\t\t\t\t\t\tlet lastNode = lineInfo.element.node.lastChild;\r\n\r\n\t\t\t\t\t\t\t\t\t// Init split lines\r\n\t\t\t\t\t\t\t\t\tlet splitLines: string[];\r\n\t\t\t\t\t\t\t\t\twhile ((lineInfo.bbox.width > maxWidth) && (excessChars <= lineText.length) && (excessChars > 0)) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Calculate max available chars\r\n\t\t\t\t\t\t\t\t\t\tlet maxChars: number = $math.max(chunk.text.length - excessChars, 1);\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Don't split the words mid-word if it's not the first chunk\r\n\t\t\t\t\t\t\t\t\t\t// in the line\r\n\t\t\t\t\t\t\t\t\t\tif (firstChunk) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Split mid-word if necessary\r\n\t\t\t\t\t\t\t\t\t\t\tsplitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl);\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Don't split mid-word\r\n\t\t\t\t\t\t\t\t\t\t\tsplitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Check if the first word is too long\r\n\t\t\t\t\t\t\t\t\t\t\tif ((splitLines[0].length > maxChars) || maxChars === 1) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Yes - move the whole chunk to the next line\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Remove the element we just added\r\n\t\t\t\t\t\t\t\t\t\t\t\tlineInfo.element.node.removeChild(lastNode)\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Break out of the while on next cycle\r\n\t\t\t\t\t\t\t\t\t\t\t\texcessChars = 0;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Use the first line to update last item\r\n\t\t\t\t\t\t\t\t\t\tif (excessChars > 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tlastNode.textContent = getTextFormatter().cleanUp($utils.trim(splitLines.shift()));\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Measure again, just in case\r\n\t\t\t\t\t\t\t\t\t\tlineInfo.bbox = lineInfo.element.getBBox();\r\n\t\t\t\t\t\t\t\t\t\tlineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Increase excess characters count, just in case it still\r\n\t\t\t\t\t\t\t\t\t\t// doesn't fit and we have to go at it again\r\n\t\t\t\t\t\t\t\t\t\texcessChars = Math.ceil(excessChars * 1.1);\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t// Construct the rest of the line\r\n\t\t\t\t\t\t\t\t\tif (splitLines.length > 0) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tlet restOfLine: string = \"\";\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Add leftovers from splitting the current chunk\r\n\t\t\t\t\t\t\t\t\t\tif ($type.hasValue(splitLines)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (this.rtl) {\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += splitLines.join(\"\") + currentFormat;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += currentFormat + splitLines.join(\"\").replace(/([\\[\\]]{1})/g, \"$1$1\");\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Add the rest of the chunks\r\n\t\t\t\t\t\t\t\t\t\tfor (let c: number = x + 1; c < chunks.length; c++) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (chunks[c].type == \"value\") {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// We're escaping single square brackets that were\r\n\t\t\t\t\t\t\t\t\t\t\t\t// cleaned up by chunk() back to double square brackets\r\n\t\t\t\t\t\t\t\t\t\t\t\t// so that they are not being treated as format on\r\n\t\t\t\t\t\t\t\t\t\t\t\t// next pass.\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += chunks[c].text.replace(/([\\[\\]]{1})/g, \"$1$1\");\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += chunks[c].text;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Inject the rest of the lines as chunks for subsequent\r\n\r\n\t\t\t\t\t\t\t\t\t\tlines.splice(i + 1, 0, restOfLine);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t// Skip processing the rest of the chunks\r\n\t\t\t\t\t\t\t\t\tskipTextChunks = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Let's update the text's bbox with the line's one\r\n\t\t\t\t\t\tif (this.bbox.width < lineInfo.bbox.width) {\r\n\t\t\t\t\t\t\tthis.bbox.width = lineInfo.bbox.width;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// commented to avoid bug (seen on sankey link) where text is incorrectly aligned\r\n\t\t\t\t\t\t//if (this.bbox.x > lineInfo.bbox.x) {\r\n\t\t\t\t\t\t//this.bbox.x = lineInfo.bbox.x;\r\n\t\t\t\t\t\t//}\r\n\r\n\t\t\t\t\t\tthis.bbox.height = currentHeight + currentLineHeight;\r\n\r\n\t\t\t\t\t\t// Position current line\r\n\t\t\t\t\t\tif (!this.textPathElement) {\r\n\t\t\t\t\t\t\tlineInfo.element.attr({\r\n\t\t\t\t\t\t\t\t\"x\": \"0\",\r\n\t\t\t\t\t\t\t\t\"y\": currentHeight + currentLineHeight,\r\n\t\t\t\t\t\t\t\t\"dy\": $math.round((this.baseLineRatio * currentLineHeight), 3).toString()\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tlineInfo.element.attr({\r\n\t\t\t\t\t\t\t\t\"dy\": -this.paddingBottom.toString()\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfirstChunk = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Trim the last item\r\n\t\t\t\tlet node = lineInfo.element.node;\r\n\t\t\t\tif (node) {\r\n\t\t\t\t\tlet lastNode = node.lastChild;\r\n\t\t\t\t\tif (lastNode) {\r\n\t\t\t\t\t\tlastNode.textContent = this.rtl ?\r\n\t\t\t\t\t\t\t$utils.ltrim(lastNode.textContent) :\r\n\t\t\t\t\t\t\t$utils.rtrim(lastNode.textContent);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Increment collective height\r\n\t\t\t\tcurrentHeight += currentLineHeight;\r\n\r\n\t\t\t\t// Save line cache\r\n\t\t\t\tthis.addLineInfo(lineInfo, i);\r\n\t\t\t}\r\n\r\n\t\t\t// Check if maybe we need to hide the whole label if it doesn't fit\r\n\t\t\tthis.maybeHideOversized();\r\n\r\n\t\t\tthis.measureFailed = false;\r\n\t\t\tif (this.bbox.width == 0 || this.bbox.height == 0) {\r\n\t\t\t\tthis.measureFailed = true;\r\n\t\t\t}\r\n\r\n\t\t\t// Updated measured dims\r\n\t\t\tthis._measuredWidth = $math.round($math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight));\r\n\t\t\tthis._measuredHeight = $math.round($math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom));\r\n\r\n\t\t\t// Align the lines\r\n\t\t\tthis.alignSVGText();\r\n\r\n\t\t\tthis.bbox.width = this._measuredWidth;\r\n\t\t\tthis.bbox.height = this._measuredHeight;\r\n\r\n\t\t\tif (oldH != this._measuredHeight || oldW != this._measuredWidth) {\r\n\t\t\t\tthis.dispatch(\"transformed\");\r\n\t\t\t}\r\n\r\n\t\t\tthis.hideUnused(lines.length);\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\t/**\r\n\t\t\t * HTML\r\n\t\t\t */\r\n\r\n\t\t\tthis.element.removeAttr(\"display\");\r\n\t\t\tthis.resetBBox();\r\n\r\n\t\t\t// Clear the element\r\n\t\t\tlet group: Group = <Group>this.element;\r\n\t\t\tgroup.removeChildren();\r\n\r\n\t\t\t// Create a ForeignObject to use as HTML container\r\n\t\t\tlet fo = this.paper.foreignObject();\r\n\t\t\tgroup.add(fo);\r\n\r\n\t\t\t// Set widths on foreignObject so that autosizing measurements work\r\n\t\t\t// This will bet reset to actual content width/height\r\n\t\t\tif (this.maxWidth) {\r\n\t\t\t\tfo.attr({\r\n\t\t\t\t\twidth: this.maxWidth\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tif (this.maxHeight) {\r\n\t\t\t\tfo.attr({\r\n\t\t\t\t\theight: this.maxHeight\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Create line element\r\n\t\t\t//let lineElement: HTMLElement = this.getHTMLLineElement(getTextFormatter().format(this.html, output));\r\n\t\t\tlet lineElement: HTMLElement = this.getHTMLLineElement(text);\r\n\t\t\tfo.node.appendChild(lineElement);\r\n\r\n\t\t\t// Temporarily set to inline-block so we can measure real width and height\r\n\t\t\tlineElement.style.display = \"inline-block\";\r\n\t\t\tconst clientWidth = lineElement.clientWidth;\r\n\t\t\tconst clientHeight = lineElement.clientHeight;\r\n\r\n\t\t\tlineElement.style.display = \"block\";\r\n\t\t\tthis._bbox = {\r\n\t\t\t\tx: 0,\r\n\t\t\t\ty: 0,\r\n\t\t\t\twidth: clientWidth,\r\n\t\t\t\theight: clientHeight\r\n\t\t\t};\r\n\r\n\t\t\t// Set exact dimensions of foreignObject so it is sized exactly as\r\n\t\t\t// the content within\r\n\t\t\tfo.attr({\r\n\t\t\t\twidth: clientWidth,\r\n\t\t\t\theight: clientHeight\r\n\t\t\t});\r\n\r\n\t\t\t// Check if maybe we need to hide the whole label if it doesn't fit\r\n\t\t\tthis.maybeHideOversized();\r\n\r\n\t\t\t// Set measurements and update bbox\r\n\t\t\tthis._measuredWidth = $math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);\r\n\t\t\tthis._measuredHeight = $math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);\r\n\r\n\t\t\tthis.bbox.width = this._measuredWidth;\r\n\t\t\tthis.bbox.height = this._measuredHeight;\r\n\r\n\t\t\t// Don't let labels bleed out of the alotted area\r\n\t\t\tif (this.truncate) {\r\n\t\t\t\tlineElement.style.overflow = \"hidden\";\r\n\t\t\t}\r\n\r\n\t\t\tif ((clientWidth > maxWidth) || (clientHeight > maxHeight)) {\r\n\t\t\t\tthis.isOversized = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t// Set applicable styles\r\n\t\tthis.setStyles();\r\n\t\tthis.updateCenter();\r\n\t\tthis.updateBackground();\r\n\r\n\t\tif (display == \"none\") {\r\n\t\t\tthis.group.attr({ display: \"none\" });\r\n\t\t}\r\n\r\n\t\tif (this.pathElement) {\r\n\t\t\tthis.paper.appendDef(this.pathElement);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Hides element if it does not fit into available space\r\n\t */\r\n\tprivate maybeHideOversized(): void {\r\n\t\tif (this.hideOversized) {\r\n\t\t\tif ((this.availableWidth < this.bbox.width) || (this.availableHeight < this.bbox.height)) {\r\n\t\t\t\tthis.element.attr({ display: \"none\" });\r\n\t\t\t\tthis.isOversized = true;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.element.removeAttr(\"display\");\r\n\t\t\t\tthis.isOversized = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Aligns the lines horizontally ant vertically, based on properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic alignSVGText(): void {\r\n\t\t// Get Group\r\n\t\tlet group: Group = <Group>this.element;\r\n\t\tlet children = group.node.children || group.node.childNodes;\r\n\r\n\t\t// Is there anything to align?\r\n\t\tif (!children || (children && children.length == 0)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet width = this._measuredWidth;\r\n\t\tlet height = this._measuredHeight;\r\n\r\n\t\t// TODO maybe these aren't needed ?\r\n\t\t$utils.used(this.pixelPaddingLeft);\r\n\t\t$utils.used(this.pixelPaddingRight);\r\n\t\t$utils.used(this.pixelPaddingTop);\r\n\t\t$utils.used(this.pixelPaddingBottom);\r\n\r\n\t\t// Process each line\r\n\t\t//$iter.each(group.children.backwards().iterator(), (element) => {\r\n\t\tfor (let i = children.length - 1; i >= 0; i--) {\r\n\t\t\t// Align horizontally\r\n\t\t\t// Since we are using `text-anchor` for horizontal alignment, all we need\r\n\t\t\t// to do here is move the `x` position\r\n\t\t\tlet node = <SVGElement>children[i];\r\n\r\n\t\t\tnode.setAttribute(\"text-anchor\", this.textAlign);\r\n\r\n\t\t\tif (this.textPathElement) {\r\n\t\t\t\tnode.removeAttribute(\"x\");\r\n\t\t\t\tnode.removeAttribute(\"y\");\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tswitch (this.textAlign) {\r\n\t\t\t\t\tcase \"middle\":\r\n\t\t\t\t\t\tnode.setAttribute(\"x\", (width / 2).toString() + \"px\");\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"end\":\r\n\t\t\t\t\t\tif (this.rtl) {\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tnode.setAttribute(\"x\", width.toString());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tif (this.rtl) {\r\n\t\t\t\t\t\t\tnode.setAttribute(\"x\", width.toString());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tnode.removeAttribute(\"text-anchor\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet y = $type.toNumber(node.getAttribute(\"y\"));\r\n\r\n\t\t\t\tswitch (this.textValign) {\r\n\t\t\t\t\tcase \"middle\":\r\n\t\t\t\t\t\tnode.setAttribute(\"y\", ((y || 0) + (height - this.bbox.height) / 2).toString());\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"bottom\":\r\n\t\t\t\t\t\tnode.setAttribute(\"y\", ((y || 0) + height - this.bbox.height).toString());\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tnode.setAttribute(\"y\", (y || 0).toString());\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Produces an SVG line element with formatted text.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text    Text to wrap into line\r\n\t * @param y       Current line vertical position\r\n\t * @return A DOM element\r\n\t * @todo Implement HTML support\r\n\t */\r\n\tpublic getSVGLineElement(text: string, y?: number): Group {\r\n\r\n\t\t// Create a <text> node and set text\r\n\t\tlet element: Group = this.paper.addGroup(\"text\");\r\n\t\telement.textContent = text;\r\n\r\n\t\t// Set parameters\r\n\t\telement.attr({\r\n\t\t\t\"x\": \"0\"\r\n\t\t\t//\"alignment-baseline\": \"hanging\",\r\n\t\t\t//\"baseline-shift\": \"-20%\",\r\n\t\t\t//\"text-anchor\": \"center\"\r\n\t\t});\r\n\r\n\t\t// Set `y` position\r\n\t\tif ($type.hasValue(y)) {\r\n\t\t\telement.attr({\r\n\t\t\t\t\"y\": y.toString()\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Don't let labels blled out of the alotted area\r\n\t\tif (this.truncate || this.wrap) {\r\n\t\t\telement.attr({ \"overflow\": \"hidden\" });\r\n\t\t}\r\n\r\n\t\t// Add RTL?\r\n\t\tif (this.rtl) {\r\n\t\t\telement.attr({\r\n\t\t\t\t\"direction\": \"rtl\",\r\n\t\t\t\t//\"unicode-bidi\": \"bidi-override\"\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * Resets cached BBox.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic resetBBox(): void {\r\n\t\tthis._bbox = { x: 0, y: 0, width: 0, height: 0 };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Creates and returns an HTML line element (`<div>`).\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Text to add\r\n\t * @return `<div>` element reference\r\n\t */\r\n\tpublic getHTMLLineElement(text: string): HTMLElement {\r\n\r\n\t\t// Create the <div> element\r\n\t\tlet div: HTMLElement = document.createElement(\"div\");\r\n\t\tdiv.innerHTML = text;\r\n\r\n\t\t// Set text alignment\r\n\t\tswitch (this.textAlign) {\r\n\t\t\tcase \"middle\":\r\n\t\t\t\tdiv.style.textAlign = \"center\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"end\":\r\n\t\t\t\tdiv.style.textAlign = \"right\";\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Disable or enable wrapping\r\n\t\tif (this.wrap) {\r\n\t\t\tdiv.style.wordWrap = \"break-word\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdiv.style.whiteSpace = \"nowrap\";\r\n\t\t}\r\n\r\n\t\t// Don't let labels bleed out of the alotted area\r\n\t\t// Moved to `draw()` because setting \"hidden\" kills all measuring\r\n\t\t/*if (this.truncate) {\r\n\t\t\tdiv.style.overflow = \"hidden\";\r\n\t\t}*/\r\n\r\n\t\t// Set RTL-related styles\r\n\t\tif (this.rtl) {\r\n\t\t\tdiv.style.direction = \"rtl\";\r\n\t\t\t//div.style.unicodeBidi = \"bidi-override\";\r\n\t\t}\r\n\r\n\t\t// Translate some of the SVG styles into CSS\r\n\t\tif ($type.hasValue(this.fill)) {\r\n\t\t\tdiv.style.color = this.fill.toString();\r\n\t\t}\r\n\r\n\t\treturn div;\r\n\t}\r\n\r\n\t/**\r\n\t * Applies specific styles to text to make it not selectable, unless it is\r\n\t * explicitly set as `selectable`.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Set styles via AMElement\r\n\t */\r\n\tpublic setStyles(): void {\r\n\t\tlet group: Group = <Group>this.element;\r\n\t\tif (!this.selectable || this.draggable || this.resizable || this.swipeable) {\r\n\t\t\tgroup.addStyle({\r\n\t\t\t\t\"webkitUserSelect\": \"none\",\r\n\t\t\t\t\"msUserSelect\": \"none\"\r\n\t\t\t});\r\n\t\t}\r\n\t\telse if (this.selectable) {\r\n\t\t\tgroup.removeStyle(\"webkitUserSelect\");\r\n\t\t\tgroup.removeStyle(\"msUserSelect\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Hides unused lines\r\n\t */\r\n\tprotected hideUnused(index: number) {\r\n\t\tthis.initLineCache();\r\n\t\tlet lines: ITextLineInfo[] = this.getCache(\"lineInfo\");\r\n\t\tif (lines.length >= index) {\r\n\t\t\tfor (let i = index; i < lines.length; i++) {\r\n\t\t\t\tlet line = lines[i];\r\n\t\t\t\tif (line && line.element) {\r\n\t\t\t\t\tline.element.attr({ \"display\": \"none\" });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * An SVG text.\r\n\t *\r\n\t * Please note that setting `html` will override this setting if browser\r\n\t * supports `foreignObject` in SGV, such as most modern browsers excluding\r\n\t * IEs.\r\n\t *\r\n\t * @param value  SVG Text\r\n\t */\r\n\tpublic set text(value: string) {\r\n\t\t//this.setPropertyValue(\"html\", undefined);\r\n\t\tthis.setPropertyValue(\"text\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return SVG text\r\n\t */\r\n\tpublic get text(): string {\r\n\t\treturn this.getPropertyValue(\"text\");\r\n\t}\r\n\r\n\t/**\r\n\t * An SVG path string to position text along. If set, the text will follow\r\n\t * the curvature of the path.\r\n\t *\r\n\t * Location along the path can be set using `locationOnPath`.\r\n\t *\r\n\t * IMPORTANT: Only SVG text can be put on path. If you are using HTML text\r\n\t * this setting will be ignored.\r\n\t *\r\n\t * @since 4.1.2\r\n\t * @param  value  Path\r\n\t */\r\n\tpublic set path(value: string) {\r\n\t\tif (this.setPropertyValue(\"path\", value, true)) {\r\n\t\t\tif (this.pathElement) {\r\n\t\t\t\tthis.pathElement.dispose();\r\n\t\t\t}\r\n\r\n\t\t\tif (this.textPathElement) {\r\n\t\t\t\tthis.textPathElement.dispose();\r\n\t\t\t}\r\n\r\n\t\t\tthis.pathElement = this.paper.add(\"path\");\r\n\t\t\tthis.pathElement.attr({ \"d\": value });\r\n\t\t\tthis.pathElement.attr({ \"id\": \"text-path-\" + this.uid });\r\n\t\t\tthis._disposers.push(this.pathElement);\r\n\r\n\t\t\tthis.textPathElement = this.paper.addGroup(\"textPath\");\r\n\t\t\tthis.textPathElement.attrNS($dom.XLINK, \"xlink:href\", \"#text-path-\" + this.uid);\r\n\t\t\t// TODO remove after https://bugzilla.mozilla.org/show_bug.cgi?id=455986 is fixed\r\n\t\t\tthis.textPathElement.attr({ \"path\": value });\r\n\t\t\tthis._disposers.push(this.textPathElement);\r\n\t\t\tthis.hardInvalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Path\r\n\t */\r\n\tpublic get path(): string {\r\n\t\treturn this.getPropertyValue(\"path\");\r\n\t}\r\n\r\n\t/**\r\n\t * Relative label location on `path`. Value range is from 0 (beginning)\r\n\t * to 1 (end).\r\n\t *\r\n\t * Works only if you set `path` setting to an SVG path.\r\n\t *\r\n\t * @since 4.1.2\r\n\t * @default 0\r\n\t * @param  value  Relatvie location on path\r\n\t */\r\n\tpublic set locationOnPath(value: number) {\r\n\t\tthis.setPropertyValue(\"locationOnPath\", value);\r\n\t\tif (this.textPathElement) {\r\n\t\t\tthis.textPathElement.attr({ \"startOffset\": (value * 100) + \"%\" })\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Relatvie location on path\r\n\t */\r\n\tpublic get locationOnPath(): number {\r\n\t\treturn this.getPropertyValue(\"locationOnPath\");\r\n\t}\r\n\r\n\t/**\r\n\t * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n\t * the label.\r\n\t *\r\n\t * @since 4.4.2\r\n\t * @default -0.27\r\n\t * @param  value  Base line ratio\r\n\t */\r\n\tpublic set baseLineRatio(value: number) {\r\n\t\tthis.setPropertyValue(\"baseLineRatio\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Base line ratio\r\n\t */\r\n\tpublic get baseLineRatio(): number {\r\n\t\treturn this.getPropertyValue(\"baseLineRatio\");\r\n\t}\r\n\r\n\t/**\r\n\t * Enables or disables autowrapping of text.\r\n\t *\r\n\t * @param value  Auto-wrapping enabled\r\n\t */\r\n\tpublic set wrap(value: boolean) {\r\n\t\tthis.resetBBox();\r\n\t\tthis.setPropertyValue(\"wrap\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Auto-wrap enabled or not\r\n\t */\r\n\tpublic get wrap(): boolean {\r\n\t\treturn this.getPropertyValue(\"wrap\");\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates if text lines need to be truncated if they do not fit, using\r\n\t * configurable `ellipsis` string.\r\n\t *\r\n\t * `truncate` overrides `wrap` if both are set to `true`.\r\n\t *\r\n\t * NOTE: For HTML text, this setting **won't** trigger a parser and actual\r\n\t * line truncation with ellipsis. It will just hide everything that goes\r\n\t * outside the label.\r\n\t *\r\n\t * @param value  trincate text?\r\n\t */\r\n\tpublic set truncate(value: boolean) {\r\n\t\tthis.resetBBox();\r\n\t\tthis.setPropertyValue(\"truncate\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Truncate text?\r\n\t */\r\n\tpublic get truncate(): boolean {\r\n\t\treturn this.getPropertyValue(\"truncate\");\r\n\t}\r\n\r\n\t/**\r\n\t * If `truncate` is enabled, should Label try to break only on full words\r\n\t * (`true`), or whenever needed, including middle of the word. (`false`)\r\n\t *\r\n\t * @default true\r\n\t * @param value  Truncate on full words?\r\n\t */\r\n\tpublic set fullWords(value: boolean) {\r\n\t\tthis.setPropertyValue(\"fullWords\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Truncate on full words?\r\n\t */\r\n\tpublic get fullWords(): boolean {\r\n\t\treturn this.getPropertyValue(\"fullWords\");\r\n\t}\r\n\r\n\t/**\r\n\t * Ellipsis character to use if `truncate` is enabled.\r\n\t *\r\n\t * @param value Ellipsis string\r\n\t * @default \"...\"\r\n\t */\r\n\tpublic set ellipsis(value: string) {\r\n\t\tthis.setPropertyValue(\"ellipsis\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Ellipsis string\r\n\t */\r\n\tpublic get ellipsis(): string {\r\n\t\treturn this.getPropertyValue(\"ellipsis\");\r\n\t}\r\n\r\n\t/**\r\n\t * Forces the text to be selectable. This setting will be ignored if the\r\n\t * object has some kind of interaction attached to it, such as it is\r\n\t * `draggable`, `swipeable`, `resizable`.\r\n\t *\r\n\t * @param value  Text selectable?\r\n\t * @default false\r\n\t */\r\n\tpublic set selectable(value: boolean) {\r\n\t\tthis.setPropertyValue(\"selectable\", value, true);\r\n\t\tthis.setStyles();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Text selectable?\r\n\t */\r\n\tpublic get selectable(): boolean {\r\n\t\treturn this.getPropertyValue(\"selectable\");\r\n\t}\r\n\r\n\t/**\r\n\t * Horizontal text alignment.\r\n\t *\r\n\t * Available choices:\r\n\t * * \"start\"\r\n\t * * \"middle\"\r\n\t * * \"end\"\r\n\t *\r\n\t * @param value  Alignment\r\n\t */\r\n\tpublic set textAlign(value: TextAlign) {\r\n\t\tthis.setPropertyValue(\"textAlign\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Alignment\r\n\t */\r\n\tpublic get textAlign(): TextAlign {\r\n\t\treturn this.getPropertyValue(\"textAlign\");\r\n\t}\r\n\r\n\t/**\r\n\t * Vertical text alignment.\r\n\t *\r\n\t * @ignore Exclude from docs (not used)\r\n\t * @param value  Alignment\r\n\t * @deprecated\r\n\t */\r\n\tpublic set textValign(value: TextValign) {\r\n\t\tthis.setPropertyValue(\"textValign\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs (not used)\r\n\t * @return Alignment\r\n\t * @deprecated\r\n\t */\r\n\tpublic get textValign(): TextValign {\r\n\t\treturn this.getPropertyValue(\"textValign\");\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Raw HTML to be used as text.\r\n\t *\r\n\t * NOTE: HTML text is subject to browser support. It relies on browsers\r\n\t * supporting SVG `foreignObject` nodes. Some browsers (read IEs) do not\r\n\t * support it. On those browsers, the text will fall back to basic SVG text,\r\n\t * striping out all HTML markup and styling that goes with it.\r\n\t *\r\n\t * For more information about `foreignObject` and its browser compatibility\r\n\t * refer to [this page](https://developer.mozilla.org/en/docs/Web/SVG/Element/foreignObject#Browser_compatibility).\r\n\t *\r\n\t * @param value HTML text\r\n\t */\r\n\tpublic set html(value: string) {\r\n\t\tthis.setPropertyValue(\"html\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return HTML content\r\n\t */\r\n\tpublic get html(): string {\r\n\t\treturn this.getPropertyValue(\"html\");\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates whether the whole text should be hidden if it does not fit into\r\n\t * its allotted space.\r\n\t *\r\n\t * @param value  Hide if text does not fit?\r\n\t */\r\n\tpublic set hideOversized(value: boolean) {\r\n\t\tthis.setPropertyValue(\"hideOversized\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Hide if text does not fit?\r\n\t */\r\n\tpublic get hideOversized(): boolean {\r\n\t\treturn this.getPropertyValue(\"hideOversized\");\r\n\t}\r\n\r\n\t/**\r\n\t * If set to `true` square-bracket formatting blocks will be treated as\r\n\t * regular text.\r\n\t *\r\n\t * @default false\r\n\t * @param value  Ignore formatting?\r\n\t */\r\n\tpublic set ignoreFormatting(value: boolean) {\r\n\t\tthis.setPropertyValue(\"ignoreFormatting\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Ignore formatting?\r\n\t */\r\n\tpublic get ignoreFormatting(): boolean {\r\n\t\treturn this.getPropertyValue(\"ignoreFormatting\");\r\n\t}\r\n\r\n\t/**\r\n\t * Override `mesaureElement` so it does not get measure again, because\r\n\t * internal `_bbox` is being updated by measuring routines in Text itself.\r\n\t */\r\n\tpublic measureElement(): void { }\r\n\r\n\t/**\r\n\t * Returns information about a line element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param index  Line index\r\n\t * @return Line info object\r\n\t */\r\n\tpublic getLineInfo(index: number): ITextLineInfo {\r\n\t\tthis.initLineCache();\r\n\t\tlet lines = this.getCache(\"lineInfo\");\r\n\t\treturn lines.length > index ? lines[index] : undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a line to line info cache.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param line     Line info object\r\n\t * @param index    Insert at specified index\r\n\t */\r\n\tpublic addLineInfo(line: ITextLineInfo, index: number): void {\r\n\t\tthis.initLineCache();\r\n\t\tthis.getCache(\"lineInfo\")[index] = line;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if line cache is initialized and initializes it.\r\n\t */\r\n\tprivate initLineCache(): void {\r\n\t\tif (!$type.hasValue(this.getCache(\"lineInfo\"))) {\r\n\t\t\tthis.setCache(\"lineInfo\", [], 0);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a [[DataItem]] to use for populating dynamic sections of the text.\r\n\t *\r\n\t * Check the description for [[Text]] class, for data binding.\r\n\t *\r\n\t * @param dataItem Data item\r\n\t */\r\n\tpublic setDataItem(dataItem: DataItem): void {\r\n\t\tif (this._sourceDataItemEvents) {\r\n\t\t\tthis._sourceDataItemEvents.dispose();\r\n\t\t}\r\n\t\tif (dataItem) {\r\n\t\t\tthis._sourceDataItemEvents = new MultiDisposer([\r\n\t\t\t\tdataItem.events.on(\"valuechanged\", this.invalidate, this, false),\r\n\t\t\t\tdataItem.events.on(\"workingvaluechanged\", this.invalidate, this, false),\r\n\t\t\t\tdataItem.events.on(\"calculatedvaluechanged\", this.invalidate, this, false),\r\n\t\t\t\tdataItem.events.on(\"propertychanged\", this.invalidate, this, false)\r\n\t\t\t]);\r\n\t\t}\r\n\t\tsuper.setDataItem(dataItem);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns available horizontal space.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Available width (px)\r\n\t */\r\n\tpublic get availableWidth(): number {\r\n\t\treturn $type.hasValue(this.maxWidth) ? this.maxWidth : this.pixelWidth;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns available vertical space.\r\n\t *\r\n\t * @return Available height (px)\r\n\t */\r\n\tpublic get availableHeight(): number {\r\n\t\treturn $type.hasValue(this.maxHeight) ? this.maxHeight : this.pixelHeight;\r\n\t}\r\n\r\n\t// temp, replacing textFormatter method\r\n\tpublic getSvgElement(text: string, style?: string): AMElement {\r\n\t\tlet element = this.paper.add(\"tspan\");\r\n\t\telement.textContent = text;\r\n\t\tif (style) {\r\n\t\t\telement.node.setAttribute(\"style\", style);\r\n\t\t}\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * Invalidates the whole element, including layout AND all its child\r\n\t * elements.\r\n\t */\r\n\tpublic deepInvalidate() {\r\n\t\tsuper.deepInvalidate();\r\n\t\tthis.hardInvalidate();\r\n\t}\r\n\r\n\t/**\r\n\t * Screen reader title of the element.\r\n\t *\r\n\t * @param value Title\r\n\t */\r\n\tpublic set readerTitle(value: string) {\r\n\t\tvalue = $type.toText(value);\r\n\t\tif (this.setPropertyValue(\"readerTitle\", value)) {\r\n\t\t\tthis.applyAccessibility();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Title\r\n\t */\r\n\tpublic get readerTitle(): string {\r\n\t\tlet title = this.getPropertyValue(\"readerTitle\");\r\n\t\tif (!title) {\r\n\t\t\ttitle = this.populateString(\r\n\t\t\t\t$utils.plainText(\r\n\t\t\t\t\t$utils.isNotEmpty(this.html)\r\n\t\t\t\t\t\t? this.html\r\n\t\t\t\t\t\t: this.text\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\t\treturn title;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Label\"] = Label;\r\n\r\n/**\r\n * Add default responsive rules\r\n */\r\n\r\n/**\r\n * Hide labels added directly to chart, like titles if chart is short.\r\n */\r\ndefaultRules.push({\r\n\trelevant: ResponsiveBreakpoints.heightXS,\r\n\tstate: function(target, stateId) {\r\n\t\tif (target instanceof Label && target.parent && target.parent.isBaseSprite) {\r\n\t\t\tlet state = target.states.create(stateId);\r\n\t\t\tstate.properties.disabled = true;\r\n\t\t\treturn state;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n});\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}