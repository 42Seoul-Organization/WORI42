{"ast":null,"code":"/**\r\n * A collection of functions that deals with path calculations.\r\n */\nimport * as $math from \"../utils/Math\";\nimport * as $type from \"../utils/Type\";\nimport { getGhostPaper } from \"../rendering/Paper\";\nimport { options } from \"../Options\";\n/**\r\n * ============================================================================\r\n * PATH FUNCTIONS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Returns an SVG path from a number of points.\r\n *\r\n * @ignore Exclude from docs\r\n * @param points  An array of line elbow points\r\n * @return SVG path\r\n */\n\nexport function polyline(points) {\n  var path = lineTo(points[0]);\n  var prevPoint = {\n    x: 0,\n    y: 0\n  };\n  var minStep = options.minPolylineStep;\n\n  if (!$type.isNumber(minStep)) {\n    minStep = 0.5;\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if ($math.getDistance(point, prevPoint) > minStep) {\n      path += lineTo(point);\n      prevPoint = point;\n    }\n  }\n\n  return path;\n}\n/**\r\n * Returns a starting point of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point  Starting point\r\n * @return SVG path\r\n */\n\nexport function moveTo(point) {\n  return \" M\" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4) + \" \";\n}\n/**\r\n * Returns a line part of SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point  SVG path\r\n * @return SVG path\r\n */\n\nexport function lineTo(point) {\n  return \" L\" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4) + \" \";\n}\n/**\r\n * Returns a quadratic curve part of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point         End point of the curve\r\n * @param controlPoint  Control point\r\n * @return SVG path\r\n */\n\nexport function quadraticCurveTo(point, controlPoint) {\n  return \" Q\" + $math.round(controlPoint.x, 4) + \",\" + $math.round(controlPoint.y, 4) + \" \" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4);\n}\n/**\r\n * Returns a cubic curve part of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point          End point of the curve\r\n * @param controlPointA  Control point A\r\n * @param controlPointB  Control point B\r\n * @return SVG path\r\n */\n\nexport function cubicCurveTo(point, controlPointA, controlPointB) {\n  return \" C\" + $math.round(controlPointA.x, 4) + \",\" + $math.round(controlPointA.y, 4) + \" \" + $math.round(controlPointB.x, 4) + \",\" + $math.round(controlPointB.y, 4) + \" \" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4);\n}\n/**\r\n * Returns a terminator for an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @return SVG path\r\n */\n\nexport function closePath() {\n  return \" Z\";\n}\n/**\r\n * Returns an arc part of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Better parameter descriptions\r\n * @param startAngle  Starting angle\r\n * @param arc         Arc\r\n * @param radius      Radius\r\n * @param radiusY     Vertical radius\r\n * @return SVG path\r\n */\n\nexport function arcTo(startAngle, arc, radius, radiusY) {\n  if (arc == 0) {\n    return \"\";\n  }\n\n  if (!$type.isNumber(radiusY)) {\n    radiusY = radius;\n  }\n\n  var path = \"\";\n  var c = \",\";\n  var segments = Math.ceil(Math.abs(arc) / 180);\n  var l = 1;\n\n  if (arc < 0) {\n    l = 0;\n  } // previous, as we use a not A\n\n\n  var pax = 0;\n  var pay = 0; // center\n\n  var cx = -$math.cos(startAngle) * radius;\n  var cy = -$math.sin(startAngle) * radiusY; // foir very short angles and big radius, solves artefacts\n\n  if (arc < 0.5 && radius > 3000) {\n    var endAngle = startAngle + arc;\n    var ax = $math.round($math.cos(endAngle) * radius, 4);\n    var ay = $math.round($math.sin(endAngle) * radiusY, 4);\n    return lineTo({\n      x: ax,\n      y: ay\n    });\n  }\n\n  for (var i = 0; i < segments; i++) {\n    var endAngle = startAngle + arc / segments * (i + 1);\n    var ax = $math.round($math.cos(endAngle) * radius + cx - pax, 4);\n    var ay = $math.round($math.sin(endAngle) * radiusY + cy - pay, 4);\n    path += \" a\" + radius + c + radiusY + c + 0 + c + 0 + c + l + c + ax + c + ay;\n    pax = ax;\n    pay = ay;\n  }\n\n  return path;\n}\n/**\r\n * Creates an arc path.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param startAngle         [description]\r\n * @param arc                [description]\r\n * @param radius             [description]\r\n * @param innerRadius        [description]\r\n * @param radiusY            [description]\r\n * @param cornerRadius       [description]\r\n * @param innerCornerRadius  [description]\r\n * @return SVG path\r\n */\n\nexport function arc(startAngle, arc, radius, innerRadius, radiusY, cornerRadius, innerCornerRadius) {\n  if (arc == 0) {\n    return \"\";\n  }\n\n  if (!$type.isNumber(innerRadius)) {\n    innerRadius = 0;\n  }\n\n  if (radius == 0 && innerRadius <= 0) {\n    return \"\";\n  }\n\n  if (radius < innerRadius) {\n    var temp = radius;\n    radius = innerRadius;\n    innerRadius = temp;\n\n    if ($type.isNumber(radiusY)) {\n      radiusY = radiusY / innerRadius * radius;\n    }\n  }\n\n  arc = $math.min(arc, 360);\n\n  if (arc == 360) {\n    cornerRadius = 0;\n    innerCornerRadius = 0;\n  }\n\n  var endAngle = startAngle + arc;\n  var crSin = $math.sin($math.min(arc, 45) / 2);\n  radiusY = $type.isNumber(radiusY) ? radiusY : radius;\n  cornerRadius = cornerRadius || 0;\n  innerCornerRadius = $type.isNumber(innerCornerRadius) ? innerCornerRadius : cornerRadius;\n  var innerRadiusY = radiusY / radius * innerRadius;\n  var cornerRadiusY = radiusY / radius * cornerRadius;\n  var innerCornerRadiusY = radiusY / radius * innerCornerRadius;\n  cornerRadius = $math.fitToRange(cornerRadius, 0, (radius - innerRadius) / 2);\n  cornerRadiusY = $math.fitToRange(cornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\n  innerCornerRadius = $math.fitToRange(innerCornerRadius, 0, (radius - innerRadius) / 2);\n  innerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\n  cornerRadius = $math.round($math.fitToRange(cornerRadius, 0, radius * crSin), 4);\n  cornerRadiusY = $math.round($math.fitToRange(cornerRadiusY, 0, radiusY * crSin), 4);\n  innerCornerRadius = $math.round($math.fitToRange(innerCornerRadius, 0, innerRadius * crSin), 4);\n  innerCornerRadiusY = $math.round($math.fitToRange(innerCornerRadiusY, 0, innerRadiusY * crSin), 4);\n  var crAngle = Math.asin(cornerRadius / radius / 2) * $math.DEGREES * 2;\n  var crAngleY = Math.asin(cornerRadiusY / radiusY / 2) * $math.DEGREES * 2;\n\n  if (innerRadius < innerCornerRadius) {\n    innerRadius = innerCornerRadius;\n  }\n\n  if (innerRadiusY < innerCornerRadiusY) {\n    innerRadiusY = innerCornerRadiusY;\n  }\n\n  var crInnerAngle = Math.asin(innerCornerRadius / innerRadius / 2) * $math.DEGREES * 2;\n  var crInnerAngleY = Math.asin(innerCornerRadiusY / innerRadiusY / 2) * $math.DEGREES * 2;\n\n  if (!$type.isNumber(crInnerAngle)) {\n    crInnerAngle = 0;\n  }\n\n  if (!$type.isNumber(crInnerAngleY)) {\n    crInnerAngleY = 0;\n  }\n\n  var middleAngle = startAngle + arc / 2;\n  var mPoint = {\n    x: $math.round($math.cos(middleAngle) * innerRadius, 4),\n    y: $math.sin(middleAngle) * innerRadiusY\n  };\n  var a0 = {\n    x: $math.cos(startAngle) * (innerRadius + innerCornerRadius),\n    y: $math.sin(startAngle) * (innerRadiusY + innerCornerRadiusY)\n  };\n  var b0 = {\n    x: $math.cos(startAngle) * (radius - cornerRadius),\n    y: $math.sin(startAngle) * (radiusY - cornerRadiusY)\n  };\n  var c0 = {\n    x: $math.cos(endAngle) * (radius - cornerRadius),\n    y: $math.sin(endAngle) * (radiusY - cornerRadiusY)\n  };\n  var d0 = {\n    x: $math.cos(endAngle) * (innerRadius + innerCornerRadius),\n    y: $math.sin(endAngle) * (innerRadiusY + innerCornerRadiusY)\n  };\n  var b1 = {\n    x: $math.cos(startAngle + crAngle) * radius,\n    y: $math.sin(startAngle + crAngleY) * radiusY\n  };\n  var d1 = {\n    x: $math.cos(endAngle - crInnerAngle) * innerRadius,\n    y: $math.sin(endAngle - crInnerAngleY) * innerRadiusY\n  }; // some magic math\n\n  innerCornerRadius += innerCornerRadius * $math.sin(crInnerAngle / 2);\n  innerCornerRadiusY += innerCornerRadiusY * $math.sin(crInnerAngleY / 2);\n\n  if (crInnerAngle > (endAngle - startAngle) / 2) {\n    d1 = mPoint;\n  }\n\n  var path = \"\"; // start from b if this is full circle\n\n  if (arc == 360) {\n    path = moveTo(b0);\n  } // otherwise start from a\n  else {\n      path = moveTo(a0);\n      path += lineTo(b0);\n      path += arcToPoint(b1, cornerRadius, cornerRadiusY, true);\n    } // draw arc\n\n\n  path += arcTo(startAngle + crAngle, arc - 2 * crAngle, radius, radiusY); // draw inner arc\n\n  if ($type.isNumber(innerRadius) && innerRadius != 0) {\n    // move to B if this is full circle\n    if (arc == 360 && cornerRadius == 0) {\n      path += moveTo(d0);\n    } // draw line otherwise\n    else {\n        path += arcToPoint(c0, cornerRadius, cornerRadiusY, true);\n        path += lineTo(d0);\n        path += arcToPoint(d1, innerCornerRadius, innerCornerRadiusY, true);\n      }\n\n    path += arcTo(endAngle - crInnerAngle, -(arc - 2 * crInnerAngle), innerRadius, innerRadiusY);\n\n    if (arc < 360 || cornerRadius > 0) {\n      path += arcToPoint(a0, innerCornerRadius, innerCornerRadiusY, true);\n    }\n\n    path += lineTo(a0);\n  } else {\n    path += arcToPoint(c0, cornerRadius, cornerRadiusY, true);\n\n    if (arc < 360) {\n      path += lineTo(a0);\n    }\n  }\n\n  return path;\n}\n/**\r\n * Creates a path for an arc to specific coordinate.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param point         Reference point\r\n * @param radius        Radius\r\n * @param radiusY       Vertical radius (for skewed arcs)\r\n * @param sweepFlag     [description]\r\n * @param largeArcFlag  [description]\r\n * @param xAxisRotation [description]\r\n * @return Arc path\r\n */\n\nexport function arcToPoint(point, radius, radiusY, sweepFlag, largeArcFlag, xAxisRotation) {\n  if (radius == 0) {\n    return \"\";\n  }\n\n  xAxisRotation = xAxisRotation || 0;\n  largeArcFlag = Boolean(largeArcFlag);\n  sweepFlag = Boolean(sweepFlag);\n  var c = \",\";\n  var sweepFlagValue = +sweepFlag; // converts to 1 or 0\n\n  var largeArcFlagValue = +largeArcFlag; // converts to 1 or 0\n\n  return \" A\" + radius + c + radiusY + c + xAxisRotation + c + largeArcFlagValue + c + sweepFlagValue + c + $math.round(point.x, 4) + c + $math.round(point.y, 4);\n}\n/**\r\n * Creates a new rectangle.\r\n *\r\n * @ignore Exclude from docs\r\n * @param width   Width (px)\r\n * @param height  Height (px)\r\n * @param x       X position\r\n * @param y       Y position\r\n * @return Rectangle\r\n */\n\nexport function rectangle(width, height, x, y) {\n  if (!$type.isNumber(x)) {\n    x = 0;\n  }\n\n  if (!$type.isNumber(y)) {\n    y = 0;\n  }\n\n  return moveTo({\n    x: x,\n    y: y\n  }) + lineTo({\n    x: x + width,\n    y: y\n  }) + lineTo({\n    x: x + width,\n    y: y + height\n  }) + lineTo({\n    x: x,\n    y: y + height\n  }) + closePath();\n}\n/**\r\n * Converts a rectangle to an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param rect  Rectangle\r\n * @param ccw   Counter-clockwise?\r\n * @return SVG path\r\n */\n\nexport function rectToPath(rect, ccw) {\n  var c = \",\";\n  var L = \" L\";\n\n  if (ccw) {\n    return \"M\" + rect.x + c + rect.y + L + rect.x + c + (rect.y + rect.height) + L + (rect.x + rect.width) + c + (rect.y + rect.height) + L + (rect.x + rect.width) + c + rect.y + L + rect.x + c + rect.y;\n  } else {\n    return \"M\" + rect.x + c + rect.y + L + (rect.x + rect.width) + c + rect.y + L + (rect.x + rect.width) + c + (rect.y + rect.height) + L + rect.x + c + (rect.y + rect.height) + L + rect.x + c + rect.y;\n  }\n}\n/**\r\n * Converts SVG path to array of points.\r\n *\r\n * Note, this is experimental feature based on method which is deprecated\r\n * on some browsers and some browsers do not support it at all.\r\n *\r\n * You can save the output of this function, but not rely on it completely.\r\n */\n\nexport function pathToPoints(path, pointCount) {\n  var paper = getGhostPaper();\n  var svgPath = paper.add(\"path\").node;\n  svgPath.setAttribute(\"d\", path);\n\n  if (svgPath.getPointAtLength && svgPath.getTotalLength) {\n    var length_1 = svgPath.getTotalLength();\n    var toPoints = [];\n\n    for (var i = 0; i < pointCount; i++) {\n      var point = svgPath.getPointAtLength(i / pointCount * length_1);\n      toPoints.push({\n        x: point.x,\n        y: point.y\n      });\n    }\n\n    return toPoints;\n  }\n\n  svgPath.remove();\n}\nexport function spiralPoints(cx, cy, radius, radiusY, innerRadius, step, radiusStep, startAngle, endAngle) {\n  if (!$type.isNumber(startAngle)) {\n    startAngle = 0;\n  }\n\n  if (!$type.isNumber(startAngle)) {\n    endAngle = startAngle;\n  }\n\n  var r = innerRadius + 0.01;\n  var angle = startAngle * $math.RADIANS;\n  var points = [];\n\n  while (r < radius + radiusStep) {\n    var stepSize = step;\n\n    if (stepSize / 2 > r) {\n      stepSize = 2 * r;\n    }\n\n    angle += 2 * Math.asin(stepSize / 2 / r);\n\n    if (angle * $math.DEGREES > endAngle + (radius - innerRadius) / radiusStep * 360) {\n      break;\n    }\n\n    var degrees = angle * $math.DEGREES;\n    var point = {\n      x: cx + r * Math.cos(angle),\n      y: cy + r * radiusY / radius * Math.sin(angle)\n    };\n    points.push(point);\n    r = innerRadius + degrees / 360 * radiusStep;\n  }\n\n  points.shift();\n  return points;\n}\nexport function pointsToPath(points) {\n  if (!points || points.length == 0) {\n    return \"\";\n  }\n\n  var path = moveTo(points[0]);\n\n  if (points && points.length > 0) {\n    for (var i = 1; i < points.length; i++) {\n      path += lineTo(points[i]);\n    }\n  }\n\n  return path;\n}","map":{"version":3,"sources":["../../../../../src/.internal/core/rendering/Path.ts"],"names":[],"mappings":"AAAA;;;AAYA,OAAO,KAAK,KAAZ,MAAuB,eAAvB;AACA,OAAO,KAAK,KAAZ,MAAuB,eAAvB;AACA,SAAS,aAAT,QAA8B,oBAA9B;AACA,SAAS,OAAT,QAAwB,YAAxB;AAEA;;;;;;;AAOA;;;;;;;;AAOA,OAAM,SAAU,QAAV,CAAmB,MAAnB,EAAmC;AACxC,MAAI,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,CAAD,CAAP,CAAjB;AACA,MAAI,SAAS,GAAG;AAAE,IAAA,CAAC,EAAE,CAAL;AAAQ,IAAA,CAAC,EAAE;AAAX,GAAhB;AAEA,MAAI,OAAO,GAAG,OAAO,CAAC,eAAtB;;AACA,MAAI,CAAC,KAAK,CAAC,QAAN,CAAe,OAAf,CAAL,EAA8B;AAC7B,IAAA,OAAO,GAAG,GAAV;AACA;;AAED,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,GAAG,GAAG,MAAM,CAAC,MAA7B,EAAqC,CAAC,GAAG,GAAzC,EAA8C,CAAC,EAA/C,EAAmD;AAClD,QAAI,KAAK,GAAG,MAAM,CAAC,CAAD,CAAlB;;AACA,QAAI,KAAK,CAAC,WAAN,CAAkB,KAAlB,EAAyB,SAAzB,IAAsC,OAA1C,EAAmD;AAClD,MAAA,IAAI,IAAI,MAAM,CAAC,KAAD,CAAd;AACA,MAAA,SAAS,GAAG,KAAZ;AACA;AACD;;AACD,SAAO,IAAP;AACA;AAGD;;;;;;;;AAOA,OAAM,SAAU,MAAV,CAAiB,KAAjB,EAA8B;AACnC,SAAO,OAAO,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,CAAlB,EAAqB,CAArB,CAAP,GAAiC,GAAjC,GAAuC,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,CAAlB,EAAqB,CAArB,CAAvC,GAAiE,GAAxE;AACA;AAED;;;;;;;;AAOA,OAAM,SAAU,MAAV,CAAiB,KAAjB,EAA8B;AACnC,SAAO,OAAO,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,CAAlB,EAAqB,CAArB,CAAP,GAAiC,GAAjC,GAAuC,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,CAAlB,EAAqB,CAArB,CAAvC,GAAiE,GAAxE;AACA;AAED;;;;;;;;;AAQA,OAAM,SAAU,gBAAV,CAA2B,KAA3B,EAA0C,YAA1C,EAA8D;AACnE,SAAO,OAAO,KAAK,CAAC,KAAN,CAAY,YAAY,CAAC,CAAzB,EAA4B,CAA5B,CAAP,GACJ,GADI,GACE,KAAK,CAAC,KAAN,CAAY,YAAY,CAAC,CAAzB,EAA4B,CAA5B,CADF,GACmC,GADnC,GACyC,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,CAAlB,EAAqB,CAArB,CADzC,GAEJ,GAFI,GAEE,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,CAAlB,EAAqB,CAArB,CAFT;AAGA;AAED;;;;;;;;;;AASA,OAAM,SAAU,YAAV,CAAuB,KAAvB,EAAsC,aAAtC,EAA6D,aAA7D,EAAkF;AACvF,SAAO,OAAO,KAAK,CAAC,KAAN,CAAY,aAAa,CAAC,CAA1B,EAA6B,CAA7B,CAAP,GACJ,GADI,GACE,KAAK,CAAC,KAAN,CAAY,aAAa,CAAC,CAA1B,EAA6B,CAA7B,CADF,GACoC,GADpC,GAC0C,KAAK,CAAC,KAAN,CAAY,aAAa,CAAC,CAA1B,EAA6B,CAA7B,CAD1C,GAEJ,GAFI,GAEE,KAAK,CAAC,KAAN,CAAY,aAAa,CAAC,CAA1B,EAA6B,CAA7B,CAFF,GAEoC,GAFpC,GAE0C,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,CAAlB,EAAqB,CAArB,CAF1C,GAGJ,GAHI,GAGE,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,CAAlB,EAAqB,CAArB,CAHT;AAIA;AAED;;;;;;;AAMA,OAAM,SAAU,SAAV,GAAmB;AACxB,SAAO,IAAP;AACA;AAED;;;;;;;;;;;;AAWA,OAAM,SAAU,KAAV,CAAgB,UAAhB,EAAoC,GAApC,EAAiD,MAAjD,EAAiE,OAAjE,EAAiF;AAEtF,MAAI,GAAG,IAAI,CAAX,EAAc;AACb,WAAO,EAAP;AACA;;AAED,MAAI,CAAC,KAAK,CAAC,QAAN,CAAe,OAAf,CAAL,EAA8B;AAC7B,IAAA,OAAO,GAAG,MAAV;AACA;;AAED,MAAI,IAAI,GAAG,EAAX;AACA,MAAI,CAAC,GAAG,GAAR;AACA,MAAI,QAAQ,GAAG,IAAI,CAAC,IAAL,CAAU,IAAI,CAAC,GAAL,CAAS,GAAT,IAAgB,GAA1B,CAAf;AACA,MAAI,CAAC,GAAG,CAAR;;AAEA,MAAI,GAAG,GAAG,CAAV,EAAa;AACZ,IAAA,CAAC,GAAG,CAAJ;AACA,GAjBqF,CAmBtF;;;AACA,MAAI,GAAG,GAAW,CAAlB;AACA,MAAI,GAAG,GAAW,CAAlB,CArBsF,CAuBtF;;AACA,MAAI,EAAE,GAAW,CAAC,KAAK,CAAC,GAAN,CAAU,UAAV,CAAD,GAAyB,MAA1C;AACA,MAAI,EAAE,GAAW,CAAC,KAAK,CAAC,GAAN,CAAU,UAAV,CAAD,GAAyB,OAA1C,CAzBsF,CA2BtF;;AACA,MAAI,GAAG,GAAG,GAAN,IAAa,MAAM,GAAG,IAA1B,EAAgC;AAC/B,QAAI,QAAQ,GAAG,UAAU,GAAG,GAA5B;AACA,QAAI,EAAE,GAAG,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,GAAN,CAAU,QAAV,IAAsB,MAAlC,EAA0C,CAA1C,CAAT;AACA,QAAI,EAAE,GAAG,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,GAAN,CAAU,QAAV,IAAsB,OAAlC,EAA2C,CAA3C,CAAT;AACA,WAAO,MAAM,CAAC;AAAE,MAAA,CAAC,EAAE,EAAL;AAAS,MAAA,CAAC,EAAE;AAAZ,KAAD,CAAb;AACA;;AAED,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAApB,EAA8B,CAAC,EAA/B,EAAmC;AAClC,QAAI,QAAQ,GAAG,UAAU,GAAG,GAAG,GAAG,QAAN,IAAkB,CAAC,GAAG,CAAtB,CAA5B;AAEA,QAAI,EAAE,GAAG,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,GAAN,CAAU,QAAV,IAAsB,MAAtB,GAA+B,EAA/B,GAAoC,GAAhD,EAAqD,CAArD,CAAT;AACA,QAAI,EAAE,GAAG,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,GAAN,CAAU,QAAV,IAAsB,OAAtB,GAAgC,EAAhC,GAAqC,GAAjD,EAAsD,CAAtD,CAAT;AAEA,IAAA,IAAI,IAAI,OAAO,MAAP,GAAgB,CAAhB,GAAoB,OAApB,GAA8B,CAA9B,GAAkC,CAAlC,GAAsC,CAAtC,GAA0C,CAA1C,GAA8C,CAA9C,GAAkD,CAAlD,GAAsD,CAAtD,GAA0D,EAA1D,GAA+D,CAA/D,GAAmE,EAA3E;AAEA,IAAA,GAAG,GAAG,EAAN;AACA,IAAA,GAAG,GAAG,EAAN;AACA;;AACD,SAAO,IAAP;AACA;AAED;;;;;;;;;;;;;;;AAcA,OAAM,SAAU,GAAV,CAAc,UAAd,EAAkC,GAAlC,EAA+C,MAA/C,EAA+D,WAA/D,EAAqF,OAArF,EAAuG,YAAvG,EAA8H,iBAA9H,EAAwJ;AAC7J,MAAI,GAAG,IAAI,CAAX,EAAc;AACb,WAAO,EAAP;AACA;;AAED,MAAI,CAAC,KAAK,CAAC,QAAN,CAAe,WAAf,CAAL,EAAkC;AACjC,IAAA,WAAW,GAAG,CAAd;AACA;;AAED,MAAI,MAAM,IAAI,CAAV,IAAe,WAAW,IAAI,CAAlC,EAAqC;AACpC,WAAO,EAAP;AACA;;AAED,MAAI,MAAM,GAAG,WAAb,EAA0B;AACzB,QAAI,IAAI,GAAG,MAAX;AACA,IAAA,MAAM,GAAG,WAAT;AACA,IAAA,WAAW,GAAG,IAAd;;AAEA,QAAI,KAAK,CAAC,QAAN,CAAe,OAAf,CAAJ,EAA6B;AAC5B,MAAA,OAAO,GAAG,OAAO,GAAG,WAAV,GAAwB,MAAlC;AACA;AACD;;AAED,EAAA,GAAG,GAAG,KAAK,CAAC,GAAN,CAAU,GAAV,EAAe,GAAf,CAAN;;AAEA,MAAI,GAAG,IAAI,GAAX,EAAgB;AACf,IAAA,YAAY,GAAG,CAAf;AACA,IAAA,iBAAiB,GAAG,CAApB;AACA;;AAED,MAAI,QAAQ,GAAG,UAAU,GAAG,GAA5B;AACA,MAAI,KAAK,GAAG,KAAK,CAAC,GAAN,CAAU,KAAK,CAAC,GAAN,CAAU,GAAV,EAAe,EAAf,IAAqB,CAA/B,CAAZ;AAEA,EAAA,OAAO,GAAG,KAAK,CAAC,QAAN,CAAe,OAAf,IAA0B,OAA1B,GAAoC,MAA9C;AACA,EAAA,YAAY,GAAG,YAAY,IAAI,CAA/B;AACA,EAAA,iBAAiB,GAAG,KAAK,CAAC,QAAN,CAAe,iBAAf,IAAoC,iBAApC,GAAwD,YAA5E;AAEA,MAAI,YAAY,GAAI,OAAO,GAAG,MAAX,GAAqB,WAAxC;AAEA,MAAI,aAAa,GAAI,OAAO,GAAG,MAAX,GAAqB,YAAzC;AACA,MAAI,kBAAkB,GAAI,OAAO,GAAG,MAAX,GAAqB,iBAA9C;AAEA,EAAA,YAAY,GAAG,KAAK,CAAC,UAAN,CAAiB,YAAjB,EAA+B,CAA/B,EAAkC,CAAC,MAAM,GAAG,WAAV,IAAyB,CAA3D,CAAf;AACA,EAAA,aAAa,GAAG,KAAK,CAAC,UAAN,CAAiB,aAAjB,EAAgC,CAAhC,EAAmC,CAAC,OAAO,GAAG,YAAX,IAA2B,CAA9D,CAAhB;AAEA,EAAA,iBAAiB,GAAG,KAAK,CAAC,UAAN,CAAiB,iBAAjB,EAAoC,CAApC,EAAuC,CAAC,MAAM,GAAG,WAAV,IAAyB,CAAhE,CAApB;AACA,EAAA,kBAAkB,GAAG,KAAK,CAAC,UAAN,CAAiB,kBAAjB,EAAqC,CAArC,EAAwC,CAAC,OAAO,GAAG,YAAX,IAA2B,CAAnE,CAArB;AAEA,EAAA,YAAY,GAAG,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,UAAN,CAAiB,YAAjB,EAA+B,CAA/B,EAAkC,MAAM,GAAG,KAA3C,CAAZ,EAA+D,CAA/D,CAAf;AACA,EAAA,aAAa,GAAG,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,UAAN,CAAiB,aAAjB,EAAgC,CAAhC,EAAmC,OAAO,GAAG,KAA7C,CAAZ,EAAiE,CAAjE,CAAhB;AAEA,EAAA,iBAAiB,GAAG,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,UAAN,CAAiB,iBAAjB,EAAoC,CAApC,EAAuC,WAAW,GAAG,KAArD,CAAZ,EAAyE,CAAzE,CAApB;AACA,EAAA,kBAAkB,GAAG,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,UAAN,CAAiB,kBAAjB,EAAqC,CAArC,EAAwC,YAAY,GAAG,KAAvD,CAAZ,EAA2E,CAA3E,CAArB;AAEA,MAAI,OAAO,GAAW,IAAI,CAAC,IAAL,CAAU,YAAY,GAAG,MAAf,GAAwB,CAAlC,IAAuC,KAAK,CAAC,OAA7C,GAAuD,CAA7E;AACA,MAAI,QAAQ,GAAW,IAAI,CAAC,IAAL,CAAU,aAAa,GAAG,OAAhB,GAA0B,CAApC,IAAyC,KAAK,CAAC,OAA/C,GAAyD,CAAhF;;AAEA,MAAI,WAAW,GAAG,iBAAlB,EAAqC;AACpC,IAAA,WAAW,GAAG,iBAAd;AACA;;AAED,MAAI,YAAY,GAAG,kBAAnB,EAAuC;AACtC,IAAA,YAAY,GAAG,kBAAf;AACA;;AAED,MAAI,YAAY,GAAW,IAAI,CAAC,IAAL,CAAU,iBAAiB,GAAG,WAApB,GAAkC,CAA5C,IAAiD,KAAK,CAAC,OAAvD,GAAiE,CAA5F;AACA,MAAI,aAAa,GAAW,IAAI,CAAC,IAAL,CAAU,kBAAkB,GAAG,YAArB,GAAoC,CAA9C,IAAmD,KAAK,CAAC,OAAzD,GAAmE,CAA/F;;AAEA,MAAI,CAAC,KAAK,CAAC,QAAN,CAAe,YAAf,CAAL,EAAmC;AAClC,IAAA,YAAY,GAAG,CAAf;AACA;;AACD,MAAI,CAAC,KAAK,CAAC,QAAN,CAAe,aAAf,CAAL,EAAoC;AACnC,IAAA,aAAa,GAAG,CAAhB;AACA;;AAED,MAAI,WAAW,GAAG,UAAU,GAAG,GAAG,GAAG,CAArC;AACA,MAAI,MAAM,GAAG;AAAE,IAAA,CAAC,EAAE,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,GAAN,CAAU,WAAV,IAAyB,WAArC,EAAkD,CAAlD,CAAL;AAA2D,IAAA,CAAC,EAAE,KAAK,CAAC,GAAN,CAAU,WAAV,IAAyB;AAAvF,GAAb;AAEA,MAAI,EAAE,GAAG;AAAE,IAAA,CAAC,EAAE,KAAK,CAAC,GAAN,CAAU,UAAV,KAAyB,WAAW,GAAG,iBAAvC,CAAL;AAAgE,IAAA,CAAC,EAAE,KAAK,CAAC,GAAN,CAAU,UAAV,KAAyB,YAAY,GAAG,kBAAxC;AAAnE,GAAT;AACA,MAAI,EAAE,GAAG;AAAE,IAAA,CAAC,EAAE,KAAK,CAAC,GAAN,CAAU,UAAV,KAAyB,MAAM,GAAG,YAAlC,CAAL;AAAsD,IAAA,CAAC,EAAE,KAAK,CAAC,GAAN,CAAU,UAAV,KAAyB,OAAO,GAAG,aAAnC;AAAzD,GAAT;AACA,MAAI,EAAE,GAAG;AAAE,IAAA,CAAC,EAAE,KAAK,CAAC,GAAN,CAAU,QAAV,KAAuB,MAAM,GAAG,YAAhC,CAAL;AAAoD,IAAA,CAAC,EAAE,KAAK,CAAC,GAAN,CAAU,QAAV,KAAuB,OAAO,GAAG,aAAjC;AAAvD,GAAT;AACA,MAAI,EAAE,GAAG;AAAE,IAAA,CAAC,EAAE,KAAK,CAAC,GAAN,CAAU,QAAV,KAAuB,WAAW,GAAG,iBAArC,CAAL;AAA8D,IAAA,CAAC,EAAE,KAAK,CAAC,GAAN,CAAU,QAAV,KAAuB,YAAY,GAAG,kBAAtC;AAAjE,GAAT;AAEA,MAAI,EAAE,GAAG;AAAE,IAAA,CAAC,EAAE,KAAK,CAAC,GAAN,CAAU,UAAU,GAAG,OAAvB,IAAkC,MAAvC;AAA+C,IAAA,CAAC,EAAE,KAAK,CAAC,GAAN,CAAU,UAAU,GAAG,QAAvB,IAAmC;AAArF,GAAT;AACA,MAAI,EAAE,GAAG;AAAE,IAAA,CAAC,EAAE,KAAK,CAAC,GAAN,CAAU,QAAQ,GAAG,YAArB,IAAqC,WAA1C;AAAuD,IAAA,CAAC,EAAE,KAAK,CAAC,GAAN,CAAU,QAAQ,GAAG,aAArB,IAAsC;AAAhG,GAAT,CApF6J,CAsF7J;;AACA,EAAA,iBAAiB,IAAI,iBAAiB,GAAG,KAAK,CAAC,GAAN,CAAU,YAAY,GAAG,CAAzB,CAAzC;AACA,EAAA,kBAAkB,IAAI,kBAAkB,GAAG,KAAK,CAAC,GAAN,CAAU,aAAa,GAAG,CAA1B,CAA3C;;AAEA,MAAI,YAAY,GAAG,CAAC,QAAQ,GAAG,UAAZ,IAA0B,CAA7C,EAAgD;AAC/C,IAAA,EAAE,GAAG,MAAL;AACA;;AAED,MAAI,IAAI,GAAW,EAAnB,CA9F6J,CA+F7J;;AACA,MAAI,GAAG,IAAI,GAAX,EAAgB;AACf,IAAA,IAAI,GAAG,MAAM,CAAC,EAAD,CAAb;AACA,GAFD,CAGA;AAHA,OAIK;AACJ,MAAA,IAAI,GAAG,MAAM,CAAC,EAAD,CAAb;AACA,MAAA,IAAI,IAAI,MAAM,CAAC,EAAD,CAAd;AACA,MAAA,IAAI,IAAI,UAAU,CAAC,EAAD,EAAK,YAAL,EAAmB,aAAnB,EAAkC,IAAlC,CAAlB;AACA,KAxG4J,CA0G7J;;;AACA,EAAA,IAAI,IAAI,KAAK,CAAC,UAAU,GAAG,OAAd,EAAuB,GAAG,GAAG,IAAI,OAAjC,EAA0C,MAA1C,EAAkD,OAAlD,CAAb,CA3G6J,CA6G7J;;AACA,MAAI,KAAK,CAAC,QAAN,CAAe,WAAf,KAA+B,WAAW,IAAI,CAAlD,EAAqD;AAEpD;AACA,QAAI,GAAG,IAAI,GAAP,IAAc,YAAY,IAAI,CAAlC,EAAqC;AACpC,MAAA,IAAI,IAAI,MAAM,CAAC,EAAD,CAAd;AACA,KAFD,CAGA;AAHA,SAIK;AACJ,QAAA,IAAI,IAAI,UAAU,CAAC,EAAD,EAAK,YAAL,EAAmB,aAAnB,EAAkC,IAAlC,CAAlB;AACA,QAAA,IAAI,IAAI,MAAM,CAAC,EAAD,CAAd;AACA,QAAA,IAAI,IAAI,UAAU,CAAC,EAAD,EAAK,iBAAL,EAAwB,kBAAxB,EAA4C,IAA5C,CAAlB;AACA;;AAED,IAAA,IAAI,IAAI,KAAK,CAAC,QAAQ,GAAG,YAAZ,EAA0B,EAAE,GAAG,GAAG,IAAI,YAAZ,CAA1B,EAAqD,WAArD,EAAkE,YAAlE,CAAb;;AACA,QAAI,GAAG,GAAG,GAAN,IAAa,YAAY,GAAG,CAAhC,EAAmC;AAClC,MAAA,IAAI,IAAI,UAAU,CAAC,EAAD,EAAK,iBAAL,EAAwB,kBAAxB,EAA4C,IAA5C,CAAlB;AACA;;AACD,IAAA,IAAI,IAAI,MAAM,CAAC,EAAD,CAAd;AACA,GAlBD,MAmBK;AACJ,IAAA,IAAI,IAAI,UAAU,CAAC,EAAD,EAAK,YAAL,EAAmB,aAAnB,EAAkC,IAAlC,CAAlB;;AACA,QAAI,GAAG,GAAG,GAAV,EAAe;AACd,MAAA,IAAI,IAAI,MAAM,CAAC,EAAD,CAAd;AACA;AACD;;AAED,SAAO,IAAP;AACA;AAED;;;;;;;;;;;;;;AAaA,OAAM,SAAU,UAAV,CAAqB,KAArB,EAAoC,MAApC,EAAoD,OAApD,EAAsE,SAAtE,EAA2F,YAA3F,EAAmH,aAAnH,EAAyI;AAC9I,MAAI,MAAM,IAAI,CAAd,EAAiB;AAChB,WAAO,EAAP;AACA;;AACD,EAAA,aAAa,GAAG,aAAa,IAAI,CAAjC;AACA,EAAA,YAAY,GAAG,OAAO,CAAC,YAAD,CAAtB;AACA,EAAA,SAAS,GAAG,OAAO,CAAC,SAAD,CAAnB;AAEA,MAAI,CAAC,GAAG,GAAR;AACA,MAAI,cAAc,GAAW,CAAC,SAA9B,CAT8I,CASrG;;AACzC,MAAI,iBAAiB,GAAW,CAAC,YAAjC,CAV8I,CAU9F;;AAEhD,SAAO,OAAO,MAAP,GAAgB,CAAhB,GAAoB,OAApB,GAA8B,CAA9B,GAAkC,aAAlC,GAAkD,CAAlD,GAAsD,iBAAtD,GAA0E,CAA1E,GAA8E,cAA9E,GAA+F,CAA/F,GAAmG,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,CAAlB,EAAqB,CAArB,CAAnG,GAA6H,CAA7H,GAAiI,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,CAAlB,EAAqB,CAArB,CAAxI;AACA;AAED;;;;;;;;;;;AAUA,OAAM,SAAU,SAAV,CAAoB,KAApB,EAAmC,MAAnC,EAAmD,CAAnD,EAA+D,CAA/D,EAAyE;AAC9E,MAAI,CAAC,KAAK,CAAC,QAAN,CAAe,CAAf,CAAL,EAAwB;AACvB,IAAA,CAAC,GAAG,CAAJ;AACA;;AACD,MAAI,CAAC,KAAK,CAAC,QAAN,CAAe,CAAf,CAAL,EAAwB;AACvB,IAAA,CAAC,GAAG,CAAJ;AACA;;AACD,SAAO,MAAM,CAAC;AAAE,IAAA,CAAC,EAAE,CAAL;AAAQ,IAAA,CAAC,EAAE;AAAX,GAAD,CAAN,GAAyB,MAAM,CAAC;AAAE,IAAA,CAAC,EAAE,CAAC,GAAG,KAAT;AAAgB,IAAA,CAAC,EAAE;AAAnB,GAAD,CAA/B,GAA0D,MAAM,CAAC;AAAE,IAAA,CAAC,EAAE,CAAC,GAAG,KAAT;AAAgB,IAAA,CAAC,EAAE,CAAC,GAAG;AAAvB,GAAD,CAAhE,GAAoG,MAAM,CAAC;AAAE,IAAA,CAAC,EAAE,CAAL;AAAQ,IAAA,CAAC,EAAE,CAAC,GAAG;AAAf,GAAD,CAA1G,GAAsI,SAAS,EAAtJ;AACA;AAED;;;;;;;;;AAQA,OAAM,SAAU,UAAV,CAAqB,IAArB,EAAuC,GAAvC,EAAoD;AACzD,MAAI,CAAC,GAAG,GAAR;AACA,MAAI,CAAC,GAAG,IAAR;;AACA,MAAI,GAAJ,EAAS;AACR,WAAO,MAAM,IAAI,CAAC,CAAX,GACJ,CADI,GACA,IAAI,CAAC,CADL,GACS,CADT,GACa,IAAI,CAAC,CADlB,GAEJ,CAFI,IAEC,IAAI,CAAC,CAAL,GAAS,IAAI,CAAC,MAFf,IAEyB,CAFzB,IAE8B,IAAI,CAAC,CAAL,GAAS,IAAI,CAAC,KAF5C,IAGJ,CAHI,IAGC,IAAI,CAAC,CAAL,GAAS,IAAI,CAAC,MAHf,IAGyB,CAHzB,IAG8B,IAAI,CAAC,CAAL,GAAS,IAAI,CAAC,KAH5C,IAIJ,CAJI,GAIA,IAAI,CAAC,CAJL,GAIS,CAJT,GAIa,IAAI,CAAC,CAJlB,GAKJ,CALI,GAKA,IAAI,CAAC,CALZ;AAMA,GAPD,MAQK;AACJ,WAAO,MAAM,IAAI,CAAC,CAAX,GACJ,CADI,GACA,IAAI,CAAC,CADL,GACS,CADT,IACc,IAAI,CAAC,CAAL,GAAS,IAAI,CAAC,KAD5B,IAEJ,CAFI,GAEA,IAAI,CAAC,CAFL,GAES,CAFT,IAEc,IAAI,CAAC,CAAL,GAAS,IAAI,CAAC,KAF5B,IAGJ,CAHI,IAGC,IAAI,CAAC,CAAL,GAAS,IAAI,CAAC,MAHf,IAGyB,CAHzB,GAG6B,IAAI,CAAC,CAHlC,GAIJ,CAJI,IAIC,IAAI,CAAC,CAAL,GAAS,IAAI,CAAC,MAJf,IAIyB,CAJzB,GAI6B,IAAI,CAAC,CAJlC,GAKJ,CALI,GAKA,IAAI,CAAC,CALZ;AAMA;AACD;AAED;;;;;;;;;AAQA,OAAM,SAAU,YAAV,CAAuB,IAAvB,EAAqC,UAArC,EAAuD;AAE5D,MAAI,KAAK,GAAG,aAAa,EAAzB;AACA,MAAI,OAAO,GAAwB,KAAK,CAAC,GAAN,CAAU,MAAV,EAAkB,IAArD;AACA,EAAA,OAAO,CAAC,YAAR,CAAqB,GAArB,EAA0B,IAA1B;;AAEA,MAAI,OAAO,CAAC,gBAAR,IAA4B,OAAO,CAAC,cAAxC,EAAwD;AACvD,QAAI,QAAM,GAAG,OAAO,CAAC,cAAR,EAAb;AAEA,QAAI,QAAQ,GAAG,EAAf;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AACpC,UAAI,KAAK,GAAG,OAAO,CAAC,gBAAR,CAAyB,CAAC,GAAG,UAAJ,GAAiB,QAA1C,CAAZ;AACA,MAAA,QAAQ,CAAC,IAAT,CAAc;AAAE,QAAA,CAAC,EAAE,KAAK,CAAC,CAAX;AAAc,QAAA,CAAC,EAAE,KAAK,CAAC;AAAvB,OAAd;AACA;;AAED,WAAO,QAAP;AACA;;AAED,EAAA,OAAO,CAAC,MAAR;AACA;AAGD,OAAM,SAAU,YAAV,CAAuB,EAAvB,EAAmC,EAAnC,EAA+C,MAA/C,EAA+D,OAA/D,EAAgF,WAAhF,EAAqG,IAArG,EAAmH,UAAnH,EAAuI,UAAvI,EAA4J,QAA5J,EAA6K;AAElL,MAAI,CAAC,KAAK,CAAC,QAAN,CAAe,UAAf,CAAL,EAAiC;AAChC,IAAA,UAAU,GAAG,CAAb;AACA;;AAED,MAAI,CAAC,KAAK,CAAC,QAAN,CAAe,UAAf,CAAL,EAAiC;AAChC,IAAA,QAAQ,GAAG,UAAX;AACA;;AAED,MAAI,CAAC,GAAG,WAAW,GAAG,IAAtB;AACA,MAAI,KAAK,GAAG,UAAU,GAAG,KAAK,CAAC,OAA/B;AACA,MAAI,MAAM,GAAG,EAAb;;AAEA,SAAO,CAAC,GAAG,MAAM,GAAG,UAApB,EAAgC;AAE/B,QAAI,QAAQ,GAAG,IAAf;;AACA,QAAI,QAAQ,GAAG,CAAX,GAAe,CAAnB,EAAsB;AACrB,MAAA,QAAQ,GAAG,IAAI,CAAf;AACA;;AAED,IAAA,KAAK,IAAI,IAAI,IAAI,CAAC,IAAL,CAAU,QAAQ,GAAG,CAAX,GAAe,CAAzB,CAAb;;AAEA,QAAI,KAAK,GAAG,KAAK,CAAC,OAAd,GAAwB,QAAQ,GAAI,CAAC,MAAM,GAAG,WAAV,IAAyB,UAA1B,GAAwC,GAA/E,EAAoF;AACnF;AACA;;AAED,QAAI,OAAO,GAAG,KAAK,GAAG,KAAK,CAAC,OAA5B;AAEA,QAAI,KAAK,GAAG;AAAE,MAAA,CAAC,EAAE,EAAE,GAAG,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,CAAd;AAA+B,MAAA,CAAC,EAAE,EAAE,GAAG,CAAC,GAAG,OAAJ,GAAc,MAAd,GAAuB,IAAI,CAAC,GAAL,CAAS,KAAT;AAA9D,KAAZ;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,KAAZ;AAEA,IAAA,CAAC,GAAG,WAAW,GAAG,OAAO,GAAG,GAAV,GAAgB,UAAlC;AAEA;;AAED,EAAA,MAAM,CAAC,KAAP;AAEA,SAAO,MAAP;AACA;AAED,OAAM,SAAU,YAAV,CAAuB,MAAvB,EAAuC;AAC5C,MAAI,CAAC,MAAD,IAAW,MAAM,CAAC,MAAP,IAAiB,CAAhC,EAAmC;AAClC,WAAO,EAAP;AACA;;AACD,MAAI,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,CAAD,CAAP,CAAjB;;AACA,MAAI,MAAM,IAAI,MAAM,CAAC,MAAP,GAAgB,CAA9B,EAAiC;AAChC,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACvC,MAAA,IAAI,IAAI,MAAM,CAAC,MAAM,CAAC,CAAD,CAAP,CAAd;AACA;AACD;;AACD,SAAO,IAAP;AACA","sourcesContent":["/**\r\n * A collection of functions that deals with path calculations.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { IPoint } from \"../defs/IPoint\";\r\nimport { IRectangle } from \"../defs/IRectangle\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $type from \"../utils/Type\";\r\nimport { getGhostPaper } from \"../rendering/Paper\";\r\nimport { options } from \"../Options\";\r\n\r\n/**\r\n * ============================================================================\r\n * PATH FUNCTIONS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Returns an SVG path from a number of points.\r\n *\r\n * @ignore Exclude from docs\r\n * @param points  An array of line elbow points\r\n * @return SVG path\r\n */\r\nexport function polyline(points: IPoint[]): string {\r\n\tlet path = lineTo(points[0]);\r\n\tlet prevPoint = { x: 0, y: 0 };\r\n\r\n\tlet minStep = options.minPolylineStep;\r\n\tif (!$type.isNumber(minStep)) {\r\n\t\tminStep = 0.5;\r\n\t}\r\n\r\n\tfor (let i = 0, len = points.length; i < len; i++) {\r\n\t\tlet point = points[i];\r\n\t\tif ($math.getDistance(point, prevPoint) > minStep) {\r\n\t\t\tpath += lineTo(point);\r\n\t\t\tprevPoint = point;\r\n\t\t}\r\n\t}\r\n\treturn path;\r\n}\r\n\r\n\r\n/**\r\n * Returns a starting point of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point  Starting point\r\n * @return SVG path\r\n */\r\nexport function moveTo(point: IPoint): string {\r\n\treturn \" M\" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4) + \" \";\r\n}\r\n\r\n/**\r\n * Returns a line part of SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point  SVG path\r\n * @return SVG path\r\n */\r\nexport function lineTo(point: IPoint): string {\r\n\treturn \" L\" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4) + \" \";\r\n}\r\n\r\n/**\r\n * Returns a quadratic curve part of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point         End point of the curve\r\n * @param controlPoint  Control point\r\n * @return SVG path\r\n */\r\nexport function quadraticCurveTo(point: IPoint, controlPoint: IPoint): string {\r\n\treturn \" Q\" + $math.round(controlPoint.x, 4)\r\n\t\t+ \",\" + $math.round(controlPoint.y, 4) + \" \" + $math.round(point.x, 4)\r\n\t\t+ \",\" + $math.round(point.y, 4);\r\n}\r\n\r\n/**\r\n * Returns a cubic curve part of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point          End point of the curve\r\n * @param controlPointA  Control point A\r\n * @param controlPointB  Control point B\r\n * @return SVG path\r\n */\r\nexport function cubicCurveTo(point: IPoint, controlPointA: IPoint, controlPointB: IPoint): string {\r\n\treturn \" C\" + $math.round(controlPointA.x, 4)\r\n\t\t+ \",\" + $math.round(controlPointA.y, 4) + \" \" + $math.round(controlPointB.x, 4)\r\n\t\t+ \",\" + $math.round(controlPointB.y, 4) + \" \" + $math.round(point.x, 4)\r\n\t\t+ \",\" + $math.round(point.y, 4);\r\n}\r\n\r\n/**\r\n * Returns a terminator for an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @return SVG path\r\n */\r\nexport function closePath(): string {\r\n\treturn \" Z\";\r\n}\r\n\r\n/**\r\n * Returns an arc part of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Better parameter descriptions\r\n * @param startAngle  Starting angle\r\n * @param arc         Arc\r\n * @param radius      Radius\r\n * @param radiusY     Vertical radius\r\n * @return SVG path\r\n */\r\nexport function arcTo(startAngle: number, arc: number, radius: number, radiusY?: number): string {\r\n\r\n\tif (arc == 0) {\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\tif (!$type.isNumber(radiusY)) {\r\n\t\tradiusY = radius;\r\n\t}\r\n\r\n\tlet path = \"\";\r\n\tlet c = \",\";\r\n\tlet segments = Math.ceil(Math.abs(arc) / 180);\r\n\tlet l = 1;\r\n\r\n\tif (arc < 0) {\r\n\t\tl = 0;\r\n\t}\r\n\r\n\t// previous, as we use a not A\r\n\tlet pax: number = 0;\r\n\tlet pay: number = 0;\r\n\r\n\t// center\r\n\tlet cx: number = -$math.cos(startAngle) * radius;\r\n\tlet cy: number = -$math.sin(startAngle) * radiusY;\r\n\r\n\t// foir very short angles and big radius, solves artefacts\r\n\tif (arc < 0.5 && radius > 3000) {\r\n\t\tlet endAngle = startAngle + arc\r\n\t\tlet ax = $math.round($math.cos(endAngle) * radius, 4);\r\n\t\tlet ay = $math.round($math.sin(endAngle) * radiusY, 4);\r\n\t\treturn lineTo({ x: ax, y: ay })\r\n\t}\r\n\r\n\tfor (let i = 0; i < segments; i++) {\r\n\t\tlet endAngle = startAngle + arc / segments * (i + 1);\r\n\r\n\t\tlet ax = $math.round($math.cos(endAngle) * radius + cx - pax, 4);\r\n\t\tlet ay = $math.round($math.sin(endAngle) * radiusY + cy - pay, 4);\r\n\r\n\t\tpath += \" a\" + radius + c + radiusY + c + 0 + c + 0 + c + l + c + ax + c + ay;\r\n\r\n\t\tpax = ax;\r\n\t\tpay = ay;\r\n\t}\r\n\treturn path;\r\n}\r\n\r\n/**\r\n * Creates an arc path.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param startAngle         [description]\r\n * @param arc                [description]\r\n * @param radius             [description]\r\n * @param innerRadius        [description]\r\n * @param radiusY            [description]\r\n * @param cornerRadius       [description]\r\n * @param innerCornerRadius  [description]\r\n * @return SVG path\r\n */\r\nexport function arc(startAngle: number, arc: number, radius: number, innerRadius?: number, radiusY?: number, cornerRadius?: number, innerCornerRadius?: number): string {\r\n\tif (arc == 0) {\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\tif (!$type.isNumber(innerRadius)) {\r\n\t\tinnerRadius = 0;\r\n\t}\r\n\r\n\tif (radius == 0 && innerRadius <= 0) {\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\tif (radius < innerRadius) {\r\n\t\tlet temp = radius;\r\n\t\tradius = innerRadius;\r\n\t\tinnerRadius = temp;\r\n\r\n\t\tif ($type.isNumber(radiusY)) {\r\n\t\t\tradiusY = radiusY / innerRadius * radius;\r\n\t\t}\r\n\t}\r\n\r\n\tarc = $math.min(arc, 360);\r\n\r\n\tif (arc == 360) {\r\n\t\tcornerRadius = 0;\r\n\t\tinnerCornerRadius = 0;\r\n\t}\r\n\r\n\tlet endAngle = startAngle + arc;\r\n\tlet crSin = $math.sin($math.min(arc, 45) / 2);\r\n\r\n\tradiusY = $type.isNumber(radiusY) ? radiusY : radius;\r\n\tcornerRadius = cornerRadius || 0;\r\n\tinnerCornerRadius = $type.isNumber(innerCornerRadius) ? innerCornerRadius : cornerRadius;\r\n\r\n\tlet innerRadiusY = (radiusY / radius) * innerRadius;\r\n\r\n\tlet cornerRadiusY = (radiusY / radius) * cornerRadius;\r\n\tlet innerCornerRadiusY = (radiusY / radius) * innerCornerRadius;\r\n\r\n\tcornerRadius = $math.fitToRange(cornerRadius, 0, (radius - innerRadius) / 2);\r\n\tcornerRadiusY = $math.fitToRange(cornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\r\n\r\n\tinnerCornerRadius = $math.fitToRange(innerCornerRadius, 0, (radius - innerRadius) / 2);\r\n\tinnerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\r\n\r\n\tcornerRadius = $math.round($math.fitToRange(cornerRadius, 0, radius * crSin), 4);\r\n\tcornerRadiusY = $math.round($math.fitToRange(cornerRadiusY, 0, radiusY * crSin), 4);\r\n\r\n\tinnerCornerRadius = $math.round($math.fitToRange(innerCornerRadius, 0, innerRadius * crSin), 4);\r\n\tinnerCornerRadiusY = $math.round($math.fitToRange(innerCornerRadiusY, 0, innerRadiusY * crSin), 4);\r\n\r\n\tlet crAngle: number = Math.asin(cornerRadius / radius / 2) * $math.DEGREES * 2;\r\n\tlet crAngleY: number = Math.asin(cornerRadiusY / radiusY / 2) * $math.DEGREES * 2;\r\n\r\n\tif (innerRadius < innerCornerRadius) {\r\n\t\tinnerRadius = innerCornerRadius;\r\n\t}\r\n\r\n\tif (innerRadiusY < innerCornerRadiusY) {\r\n\t\tinnerRadiusY = innerCornerRadiusY;\r\n\t}\r\n\r\n\tlet crInnerAngle: number = Math.asin(innerCornerRadius / innerRadius / 2) * $math.DEGREES * 2;\r\n\tlet crInnerAngleY: number = Math.asin(innerCornerRadiusY / innerRadiusY / 2) * $math.DEGREES * 2;\r\n\r\n\tif (!$type.isNumber(crInnerAngle)) {\r\n\t\tcrInnerAngle = 0;\r\n\t}\r\n\tif (!$type.isNumber(crInnerAngleY)) {\r\n\t\tcrInnerAngleY = 0;\r\n\t}\r\n\r\n\tlet middleAngle = startAngle + arc / 2;\r\n\tlet mPoint = { x: $math.round($math.cos(middleAngle) * innerRadius, 4), y: $math.sin(middleAngle) * innerRadiusY };\r\n\r\n\tlet a0 = { x: $math.cos(startAngle) * (innerRadius + innerCornerRadius), y: $math.sin(startAngle) * (innerRadiusY + innerCornerRadiusY) };\r\n\tlet b0 = { x: $math.cos(startAngle) * (radius - cornerRadius), y: $math.sin(startAngle) * (radiusY - cornerRadiusY) };\r\n\tlet c0 = { x: $math.cos(endAngle) * (radius - cornerRadius), y: $math.sin(endAngle) * (radiusY - cornerRadiusY) };\r\n\tlet d0 = { x: $math.cos(endAngle) * (innerRadius + innerCornerRadius), y: $math.sin(endAngle) * (innerRadiusY + innerCornerRadiusY) };\r\n\r\n\tlet b1 = { x: $math.cos(startAngle + crAngle) * radius, y: $math.sin(startAngle + crAngleY) * radiusY };\r\n\tlet d1 = { x: $math.cos(endAngle - crInnerAngle) * innerRadius, y: $math.sin(endAngle - crInnerAngleY) * innerRadiusY };\r\n\r\n\t// some magic math\r\n\tinnerCornerRadius += innerCornerRadius * $math.sin(crInnerAngle / 2);\r\n\tinnerCornerRadiusY += innerCornerRadiusY * $math.sin(crInnerAngleY / 2);\r\n\r\n\tif (crInnerAngle > (endAngle - startAngle) / 2) {\r\n\t\td1 = mPoint;\r\n\t}\r\n\r\n\tlet path: string = \"\";\r\n\t// start from b if this is full circle\r\n\tif (arc == 360) {\r\n\t\tpath = moveTo(b0);\r\n\t}\r\n\t// otherwise start from a\r\n\telse {\r\n\t\tpath = moveTo(a0);\r\n\t\tpath += lineTo(b0);\r\n\t\tpath += arcToPoint(b1, cornerRadius, cornerRadiusY, true);\r\n\t}\r\n\r\n\t// draw arc\r\n\tpath += arcTo(startAngle + crAngle, arc - 2 * crAngle, radius, radiusY);\r\n\r\n\t// draw inner arc\r\n\tif ($type.isNumber(innerRadius) && innerRadius != 0) {\r\n\r\n\t\t// move to B if this is full circle\r\n\t\tif (arc == 360 && cornerRadius == 0) {\r\n\t\t\tpath += moveTo(d0);\r\n\t\t}\r\n\t\t// draw line otherwise\r\n\t\telse {\r\n\t\t\tpath += arcToPoint(c0, cornerRadius, cornerRadiusY, true);\r\n\t\t\tpath += lineTo(d0);\r\n\t\t\tpath += arcToPoint(d1, innerCornerRadius, innerCornerRadiusY, true);\r\n\t\t}\r\n\r\n\t\tpath += arcTo(endAngle - crInnerAngle, -(arc - 2 * crInnerAngle), innerRadius, innerRadiusY);\r\n\t\tif (arc < 360 || cornerRadius > 0) {\r\n\t\t\tpath += arcToPoint(a0, innerCornerRadius, innerCornerRadiusY, true);\r\n\t\t}\r\n\t\tpath += lineTo(a0);\r\n\t}\r\n\telse {\r\n\t\tpath += arcToPoint(c0, cornerRadius, cornerRadiusY, true);\r\n\t\tif (arc < 360) {\r\n\t\t\tpath += lineTo(a0);\r\n\t\t}\r\n\t}\r\n\r\n\treturn path;\r\n}\r\n\r\n/**\r\n * Creates a path for an arc to specific coordinate.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param point         Reference point\r\n * @param radius        Radius\r\n * @param radiusY       Vertical radius (for skewed arcs)\r\n * @param sweepFlag     [description]\r\n * @param largeArcFlag  [description]\r\n * @param xAxisRotation [description]\r\n * @return Arc path\r\n */\r\nexport function arcToPoint(point: IPoint, radius: number, radiusY?: number, sweepFlag?: boolean, largeArcFlag?: boolean, xAxisRotation?: number): string {\r\n\tif (radius == 0) {\r\n\t\treturn \"\";\r\n\t}\r\n\txAxisRotation = xAxisRotation || 0;\r\n\tlargeArcFlag = Boolean(largeArcFlag);\r\n\tsweepFlag = Boolean(sweepFlag);\r\n\r\n\tlet c = \",\";\r\n\tlet sweepFlagValue: number = +sweepFlag; // converts to 1 or 0\r\n\tlet largeArcFlagValue: number = +largeArcFlag;  // converts to 1 or 0\r\n\r\n\treturn \" A\" + radius + c + radiusY + c + xAxisRotation + c + largeArcFlagValue + c + sweepFlagValue + c + $math.round(point.x, 4) + c + $math.round(point.y, 4);\r\n}\r\n\r\n/**\r\n * Creates a new rectangle.\r\n *\r\n * @ignore Exclude from docs\r\n * @param width   Width (px)\r\n * @param height  Height (px)\r\n * @param x       X position\r\n * @param y       Y position\r\n * @return Rectangle\r\n */\r\nexport function rectangle(width: number, height: number, x?: number, y?: number): string {\r\n\tif (!$type.isNumber(x)) {\r\n\t\tx = 0;\r\n\t}\r\n\tif (!$type.isNumber(y)) {\r\n\t\ty = 0;\r\n\t}\r\n\treturn moveTo({ x: x, y: y }) + lineTo({ x: x + width, y: y }) + lineTo({ x: x + width, y: y + height }) + lineTo({ x: x, y: y + height }) + closePath();\r\n}\r\n\r\n/**\r\n * Converts a rectangle to an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param rect  Rectangle\r\n * @param ccw   Counter-clockwise?\r\n * @return SVG path\r\n */\r\nexport function rectToPath(rect: IRectangle, ccw?: boolean): string {\r\n\tlet c = \",\";\r\n\tlet L = \" L\";\r\n\tif (ccw) {\r\n\t\treturn \"M\" + rect.x\r\n\t\t\t+ c + rect.y + L + rect.x\r\n\t\t\t+ c + (rect.y + rect.height) + L + (rect.x + rect.width)\r\n\t\t\t+ c + (rect.y + rect.height) + L + (rect.x + rect.width)\r\n\t\t\t+ c + rect.y + L + rect.x\r\n\t\t\t+ c + rect.y;\r\n\t}\r\n\telse {\r\n\t\treturn \"M\" + rect.x\r\n\t\t\t+ c + rect.y + L + (rect.x + rect.width)\r\n\t\t\t+ c + rect.y + L + (rect.x + rect.width)\r\n\t\t\t+ c + (rect.y + rect.height) + L + rect.x\r\n\t\t\t+ c + (rect.y + rect.height) + L + rect.x\r\n\t\t\t+ c + rect.y;\r\n\t}\r\n}\r\n\r\n/**\r\n * Converts SVG path to array of points.\r\n *\r\n * Note, this is experimental feature based on method which is deprecated\r\n * on some browsers and some browsers do not support it at all.\r\n *\r\n * You can save the output of this function, but not rely on it completely.\r\n */\r\nexport function pathToPoints(path: string, pointCount: number): IPoint[] {\r\n\r\n\tlet paper = getGhostPaper();\r\n\tlet svgPath: SVGPathElement = <any>paper.add(\"path\").node;\r\n\tsvgPath.setAttribute(\"d\", path);\r\n\r\n\tif (svgPath.getPointAtLength && svgPath.getTotalLength) {\r\n\t\tlet length = svgPath.getTotalLength();\r\n\r\n\t\tlet toPoints = []\r\n\t\tfor (let i = 0; i < pointCount; i++) {\r\n\t\t\tlet point = svgPath.getPointAtLength(i / pointCount * length);\r\n\t\t\ttoPoints.push({ x: point.x, y: point.y });\r\n\t\t}\r\n\r\n\t\treturn toPoints;\r\n\t}\r\n\r\n\tsvgPath.remove();\r\n}\r\n\r\n\r\nexport function spiralPoints(cx: number, cy: number, radius: number, radiusY: number, innerRadius: number, step: number, radiusStep: number, startAngle?: number, endAngle?: number): IPoint[] {\r\n\r\n\tif (!$type.isNumber(startAngle)) {\r\n\t\tstartAngle = 0;\r\n\t}\r\n\r\n\tif (!$type.isNumber(startAngle)) {\r\n\t\tendAngle = startAngle;\r\n\t}\r\n\r\n\tlet r = innerRadius + 0.01;\r\n\tlet angle = startAngle * $math.RADIANS;\r\n\tlet points = [];\r\n\r\n\twhile (r < radius + radiusStep) {\r\n\r\n\t\tlet stepSize = step;\r\n\t\tif (stepSize / 2 > r) {\r\n\t\t\tstepSize = 2 * r;\r\n\t\t}\r\n\r\n\t\tangle += 2 * Math.asin(stepSize / 2 / r);\t\t\r\n\r\n\t\tif (angle * $math.DEGREES > endAngle + ((radius - innerRadius) / radiusStep) * 360) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tlet degrees = angle * $math.DEGREES;\r\n\r\n\t\tlet point = { x: cx + r * Math.cos(angle), y: cy + r * radiusY / radius * Math.sin(angle) };\r\n\t\tpoints.push(point);\r\n\r\n\t\tr = innerRadius + degrees / 360 * radiusStep;\r\n\r\n\t}\r\n\r\n\tpoints.shift();\r\n\r\n\treturn points;\r\n}\r\n\r\nexport function pointsToPath(points: IPoint[]) {\r\n\tif (!points || points.length == 0) {\r\n\t\treturn \"\";\r\n\t}\r\n\tlet path = moveTo(points[0]);\r\n\tif (points && points.length > 0) {\r\n\t\tfor (let i = 1; i < points.length; i++) {\r\n\t\t\tpath += lineTo(points[i]);\r\n\t\t}\r\n\t}\r\n\treturn path;\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}