{"ast":null,"code":"/**\r\n * Category axis module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Axis, AxisDataItem } from \"./Axis\";\nimport { AxisRendererX } from \"./AxisRendererX\";\nimport { AxisRendererY } from \"./AxisRendererY\";\nimport { registry } from \"../../core/Registry\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { CategoryAxisBreak } from \"./CategoryAxisBreak\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $iter from \"../../core/utils/Iterator\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[CategoryAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar CategoryAxisDataItem =\n/** @class */\nfunction (_super) {\n  __extends(CategoryAxisDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function CategoryAxisDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.seriesDataItems = {};\n    _this.className = \"CategoryAxisDataItem\";\n    _this.text = \"{category}\";\n    _this.locations.category = 0;\n    _this.locations.endCategory = 1;\n    _this.deltaPosition = 0;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"category\", {\n    /**\r\n     * @return Category\r\n     */\n    get: function () {\n      if (this._adapterO) {\n        if (this._adapterO.isEnabled(\"category\")) {\n          return this._adapterO.apply(\"category\", this.properties.category);\n        }\n      }\n\n      return this.properties.category;\n    },\n\n    /**\r\n     * Category.\r\n     *\r\n     * @param value  Category\r\n     */\n    set: function (value) {\n      var oldCategory = this.properties.category;\n      this.setProperty(\"category\", value);\n\n      if ($type.hasValue(oldCategory) && oldCategory != value) {\n        if (this.component) {\n          this.component.validateDataElement(this);\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"endCategory\", {\n    /**\r\n     * @return End category\r\n     */\n    get: function () {\n      return this.properties.endCategory;\n    },\n\n    /**\r\n     * End category.\r\n     *\r\n     * Used for items that span several categories, like [[CategoryAxisBreak]].\r\n     *\r\n     * @param value  End category\r\n     */\n    set: function (value) {\n      this.setProperty(\"endCategory\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"deltaPosition\", {\n    get: function () {\n      return this.properties.deltaCoordinate;\n    },\n    set: function (value) {\n      if (value != this.properties.deltaCoordinate) {\n        this.setProperty(\"deltaCoordinate\", value);\n\n        if (this.component) {\n          this.component.invalidateDataItems();\n          this.component.invalidateSeries();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return CategoryAxisDataItem;\n}(AxisDataItem);\n\nexport { CategoryAxisDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Used to create a category-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"CategoryAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Clients\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link ICategoryAxisEvents} for a list of available Events\r\n * @see {@link ICategoryAxisAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar CategoryAxis =\n/** @class */\nfunction (_super) {\n  __extends(CategoryAxis, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function CategoryAxis() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * A collection that holds Axis' data items sorted by each category.\r\n     */\n\n\n    _this.dataItemsByCategory = new Dictionary();\n    _this.className = \"CategoryAxis\"; // Set field name\n\n    _this.axisFieldName = \"category\";\n    _this._lastDataItem = _this.createDataItem();\n    _this._lastDataItem.component = _this;\n\n    _this._disposers.push(_this._lastDataItem); // Apply theme\n\n\n    _this.applyTheme();\n\n    var dataItemsByCategory = _this.dataItemsByCategory;\n\n    _this.addDisposer(_this.mainDataSet.events.on(\"removed\", function (event) {\n      dataItemsByCategory.removeKey(event.oldValue.category);\n    }));\n\n    return _this;\n  }\n  /**\r\n   * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  CategoryAxis.prototype.createDataItem = function () {\n    return new CategoryAxisDataItem();\n  };\n  /**\r\n   * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n   *\r\n   * @return Axis break\r\n   */\n\n\n  CategoryAxis.prototype.createAxisBreak = function () {\n    return new CategoryAxisBreak();\n  };\n  /**\r\n   * Processes a related series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  Data item\r\n   */\n\n\n  CategoryAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\n    _super.prototype.processSeriesDataItem.call(this, dataItem, axisLetter);\n\n    var category = dataItem[\"category\" + this.axisLetter];\n\n    if ($type.hasValue(category)) {\n      var categoryAxisDataItem = this.dataItemsByCategory.getKey(category);\n\n      if (categoryAxisDataItem) {\n        var seriesId = dataItem.component.uid;\n        var seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];\n\n        if (!seriesDataItems) {\n          seriesDataItems = [];\n          categoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;\n        }\n\n        seriesDataItems.push(dataItem);\n      }\n    } else {\n      dataItem.component.dataItems.remove(dataItem);\n    }\n  };\n  /**\r\n   * Validates the data range.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n\n\n  CategoryAxis.prototype.validateDataRange = function () {\n    var _this = this;\n\n    _super.prototype.validateDataRange.call(this);\n\n    $iter.each(this._series.iterator(), function (series) {\n      if (series.xAxis instanceof CategoryAxis && series.yAxis instanceof CategoryAxis) {\n        series.invalidateDataRange();\n      } else {\n        var startIndex = _this.positionToIndex(_this.start);\n\n        var endIndex = _this.positionToIndex(_this.end);\n\n        if (endIndex >= _this.dataItems.length) {\n          endIndex--;\n        }\n\n        var seriesId = series.uid;\n        var minIndex = void 0;\n        var maxIndex = void 0;\n\n        for (var i = startIndex; i <= endIndex; i++) {\n          var axisDataItem = _this.dataItems.getIndex(i);\n\n          if (axisDataItem) {\n            var seriesDataItems = axisDataItem.seriesDataItems[seriesId];\n\n            if (seriesDataItems) {\n              for (var i_1 = 0; i_1 < seriesDataItems.length; i_1++) {\n                var seriesDataItem = seriesDataItems[i_1];\n\n                if (seriesDataItem) {\n                  var index = seriesDataItem.index;\n\n                  if (!$type.isNumber(minIndex) || index < minIndex) {\n                    minIndex = index;\n                  }\n\n                  if (!$type.isNumber(maxIndex) || index > maxIndex) {\n                    maxIndex = index;\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if ($type.isNumber(minIndex)) {\n          series.startIndex = minIndex;\n        } else {\n          series.start = _this.start;\n        }\n\n        if ($type.isNumber(maxIndex)) {\n          series.endIndex = maxIndex + 1;\n        } else {\n          series.end = _this.end;\n        } // range might not change, but axis breaks might.\n\n\n        if (_this._axisBreaks && _this._axisBreaks.length > 0) {\n          series.invalidateDataRange();\n        }\n      }\n    });\n  };\n  /**\r\n   * Validates the whole axis. Causes it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n\n\n  CategoryAxis.prototype.validate = function () {\n    var _this = this;\n\n    _super.prototype.validate.call(this);\n\n    var dataCount = this.dataItems.length;\n    var startIndex = $math.fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);\n    var endIndex = $math.fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);\n\n    if (this.renderer.invalid) {\n      this.renderer.validate();\n    } // find frequency at which we'll show items\n\n\n    var maxCount = this.renderer.axisLength / this.renderer.minGridDistance;\n    var frequency = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));\n    this._startIndex = Math.floor(startIndex / frequency) * frequency;\n    this._endIndex = Math.ceil(this.end * dataCount);\n    this.fixAxisBreaks();\n\n    if (this._startIndex == this._endIndex) {\n      this._endIndex++;\n    }\n\n    this._frequency = frequency;\n\n    if (this.axisLength <= 0) {\n      return;\n    }\n\n    this.maxZoomFactor = this.dataItems.length;\n\n    if (this.dataItems.length <= 0) {\n      this.maxZoomFactor = 1;\n    }\n\n    this.resetIterators(); // it's important to use protected variables here, as getters will return 0 - length\n    // TODO use iterator instead\n    // @ todo: not solved cat axis item fading\n\n    startIndex = $math.max(0, this._startIndex - this._frequency);\n    endIndex = $math.min(this.dataItems.length, this._endIndex + this._frequency);\n    var itemIndex = 0;\n\n    for (var i = 0; i < startIndex; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n\n    for (var i = endIndex, len = this.dataItems.length; i < len; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n\n    for (var i = startIndex; i < endIndex; i++) {\n      if (i < this.dataItems.length) {\n        var dataItem = this.dataItems.getIndex(i);\n\n        if (i / this._frequency == Math.round(i / this._frequency)) {\n          var axisBreak = this.isInBreak(i);\n\n          if (!axisBreak) {\n            this.appendDataItem(dataItem);\n            this.validateDataElement(dataItem, itemIndex);\n          }\n\n          itemIndex++;\n        } else {\n          //previously we disabled all before, but this is better for cpu\n          //this.validateDataElement(dataItem, itemIndex); // helps to solve shrinking // not good - creates all items\n          dataItem.__disabled = true;\n        }\n      }\n    }\n\n    this.appendDataItem(this._lastDataItem);\n    this.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);\n\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks;\n      axisBreaks.each(function (axisBreak) {\n        var adjustedStartValue = axisBreak.adjustedStartValue;\n        var adjustedEndValue = axisBreak.adjustedEndValue;\n\n        if ($math.intersect({\n          start: adjustedStartValue,\n          end: adjustedEndValue\n        }, {\n          start: _this._startIndex,\n          end: _this._endIndex\n        })) {\n          for (var b = adjustedStartValue; b <= adjustedEndValue; b++) {\n            var dataItem = _this.dataItems.getIndex(b);\n\n            dataItem.__disabled = true;\n          }\n\n          var frequency_1 = $math.fitToRange(Math.ceil(_this._frequency / axisBreak.breakSize), 1, adjustedEndValue - adjustedStartValue);\n          var itemIndex_1 = 0;\n\n          if (axisBreak.breakSize > 0) {\n            // TODO use iterator instead\n            for (var b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency_1) {\n              var dataItem = _this.dataItems.getIndex(b);\n\n              dataItem.__disabled = false;\n\n              _this.appendDataItem(dataItem);\n\n              _this.validateDataElement(dataItem, itemIndex_1);\n\n              itemIndex_1++;\n            }\n          }\n        }\n      });\n    }\n\n    this.validateBreaks();\n    this.validateAxisRanges();\n    this.ghostLabel.invalidate(); // solves font issue\n\n    this.renderer.invalidateLayout();\n  };\n  /**\r\n   * [validateDataElement description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem   [description]\r\n   * @param itemIndex  [description]\r\n   */\n\n\n  CategoryAxis.prototype.validateDataElement = function (dataItem, itemIndex, index) {\n    _super.prototype.validateDataElement.call(this, dataItem);\n\n    dataItem.itemIndex = this._axisItemCount;\n    this._axisItemCount++; //dataItem.__disabled = false;\n\n    var renderer = this.renderer;\n\n    if (!$type.isNumber(index)) {\n      index = this.categoryToIndex(dataItem.category);\n    }\n\n    var endIndex = this.categoryToIndex(dataItem.endCategory);\n\n    if (!$type.isNumber(endIndex)) {\n      endIndex = index;\n    }\n\n    var position = this.indexToPosition(index, dataItem.locations.category);\n    var endPosition = this.indexToPosition(endIndex, dataItem.locations.endCategory);\n    dataItem.position = position;\n    var fillEndIndex;\n    var fillPosition;\n    var fillEndPosition;\n\n    if (dataItem.isRange) {\n      fillEndIndex = endIndex;\n      fillPosition = this.indexToPosition(index, dataItem.locations.category);\n      fillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);\n    }\n\n    dataItem.point = renderer.positionToPoint(position);\n    var tick = dataItem.tick;\n\n    if (tick && !tick.disabled) {\n      renderer.updateTickElement(tick, position, endPosition);\n    }\n\n    var grid = dataItem.grid;\n\n    if (grid && !grid.disabled) {\n      renderer.updateGridElement(grid, position, endPosition);\n    }\n\n    var label = dataItem.label;\n\n    if (label && !label.disabled) {\n      // theorethically this might result problems if category text changes, the range text won't change. But otherwise range.label.text = \"custom text\" wont' work, which is not intuitive.\n      if (!dataItem.isRange || label.text == undefined) {\n        dataItem.text = dataItem.text;\n      }\n\n      renderer.updateLabelElement(label, position, endPosition);\n\n      if (renderer instanceof AxisRendererY && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth || renderer instanceof AxisRendererX && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight) {\n        if (dataItem.label.html) {\n          this.ghostLabel.html = dataItem.label.currentText;\n        } else {\n          this.ghostLabel.text = dataItem.label.currentText;\n        }\n      }\n    }\n\n    var fill = dataItem.axisFill;\n\n    if (fill && !fill.disabled) {\n      if (!dataItem.isRange) {\n        fillEndIndex = index + this._frequency;\n        fillPosition = this.indexToPosition(index, fill.location);\n        fillEndPosition = this.indexToPosition(fillEndIndex, fill.location);\n      }\n\n      renderer.updateFillElement(fill, fillPosition, fillEndPosition);\n\n      if (!dataItem.isRange) {\n        this.fillRule(dataItem, itemIndex);\n      }\n    }\n\n    if (dataItem.bullet) {\n      renderer.updateBullet(dataItem.bullet, position, endPosition);\n    }\n\n    var mask = dataItem.mask;\n\n    if (mask) {\n      renderer.updateFillElement(mask, fillPosition, fillEndPosition);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  CategoryAxis.prototype.disposeData = function () {\n    this.dataItemsByCategory.clear();\n\n    _super.prototype.disposeData.call(this);\n  };\n  /**\r\n   * Processes the axis data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem     Data item\r\n   * @param dataContext  The raw data that corresponds to this data item\r\n   */\n\n\n  CategoryAxis.prototype.processDataItem = function (dataItem, dataContext) {\n    if (dataItem) {\n      // creat a collection for fast access\n      _super.prototype.processDataItem.call(this, dataItem, dataContext); // check if such category already exists\n      //let existingDataItem: CategoryAxisDataItem = this.dataItemsByCategory.getKey(dataItem.category);\n      //if (existingDataItem && existingDataItem != dataItem) {\n      //\tthis.dataItems.remove(existingDataItem);\n      //}\n\n\n      if ($type.hasValue(dataItem.category)) {\n        this.dataItemsByCategory.setKey(dataItem.category, dataItem);\n      }\n    }\n  };\n\n  CategoryAxis.prototype.getDataItem = function (dataContext) {\n    var category = dataContext[this.dataFields.category];\n\n    if ($type.hasValue(category)) {\n      var dataItem = this.dataItemsByCategory.getKey(category);\n\n      if (dataItem) {\n        return dataItem;\n      } else {\n        return this.dataItems.create();\n      }\n    }\n  };\n  /**\r\n   * Converts a category index to an actual screen coordinate on the axis.\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   *\r\n   * @param index     Index\r\n   * @param location  Location (0-1)\r\n   * @return Position (px)\r\n   */\n\n\n  CategoryAxis.prototype.indexToPosition = function (index, location) {\n    if (!$type.isNumber(location)) {\n      location = 0.5;\n    }\n\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var difference = this.adjustDifference(startIndex, endIndex);\n    var startLocation = this.startLocation;\n    var endLocation = this.endLocation;\n    difference -= startLocation;\n    difference -= 1 - endLocation;\n\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks;\n      $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n        var breakStartIndex = axisBreak.adjustedStartValue;\n        var breakEndIndex = axisBreak.adjustedEndValue;\n\n        if (index < startIndex || !$type.isNumber(breakStartIndex) || !$type.isNumber(breakEndIndex)) {\n          return false;\n        }\n\n        if ($math.intersect({\n          start: breakStartIndex,\n          end: breakEndIndex\n        }, {\n          start: startIndex,\n          end: endIndex\n        })) {\n          breakStartIndex = Math.max(startIndex, breakStartIndex);\n          breakEndIndex = Math.min(endIndex, breakEndIndex);\n          var breakSize = axisBreak.breakSize; // value to the right of break end\n\n          if (index > breakEndIndex) {\n            startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\n          } // value to the left of break start\n          else if (index < breakStartIndex) {} // value within break\n            else {\n                index = breakStartIndex + (index - breakStartIndex) * breakSize;\n              }\n        }\n\n        return true;\n      });\n    }\n\n    var deltaPosition = 0;\n    var dataItem = this.dataItems.getIndex(index);\n\n    if (dataItem) {\n      deltaPosition = dataItem.deltaPosition;\n    }\n\n    return $math.round(deltaPosition + (index + location - startLocation - startIndex) / difference, 5);\n  };\n  /**\r\n   * Converts a string category name to relative position on axis.\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   *\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Position\r\n   */\n\n\n  CategoryAxis.prototype.categoryToPosition = function (category, location) {\n    var index = this.categoryToIndex(category);\n    return this.indexToPosition(index, location);\n  };\n  /**\r\n   * Converts a string category name to a orientation point (x, y, angle) on axis\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Orientation point\r\n   */\n\n\n  CategoryAxis.prototype.categoryToPoint = function (category, location) {\n    var position = this.categoryToPosition(category, location);\n    var point = this.renderer.positionToPoint(position);\n    var angle = this.renderer.positionToAngle(position);\n    return {\n      x: point.x,\n      y: point.y,\n      angle: angle\n    };\n  };\n  /**\r\n   * Converts a string category name to a orientation point (x, y, angle) on axis\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Orientation point\r\n   */\n\n\n  CategoryAxis.prototype.anyToPoint = function (category, location) {\n    return this.categoryToPoint(category, location);\n  };\n  /**\r\n   * Converts a string category name to relative position on axis.\r\n   *\r\n   * An alias to `categoryToPosition()`.\r\n   *\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Relative position\r\n   */\n\n\n  CategoryAxis.prototype.anyToPosition = function (category, location) {\n    return this.categoryToPosition(category, location);\n  };\n  /**\r\n   * Converts named category to an index of data item it corresponds to.\r\n   *\r\n   * @param category  Category\r\n   * @return Data item index\r\n   */\n\n\n  CategoryAxis.prototype.categoryToIndex = function (category) {\n    if ($type.hasValue(category)) {\n      var dataItem = this.dataItemsByCategory.getKey(category);\n\n      if (dataItem) {\n        return dataItem.index;\n      }\n    }\n  };\n  /**\r\n   * Zooms the axis to specific named ctaegories.\r\n   *\r\n   * @param startCategory  Start category\r\n   * @param endCategory    End category\r\n   */\n\n\n  CategoryAxis.prototype.zoomToCategories = function (startCategory, endCategory) {\n    this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);\n  };\n  /**\r\n   * [getAnyRangePath description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param start         [description]\r\n   * @param end           [description]\r\n   * @param startLocation [description]\r\n   * @param endLocation   [description]\r\n   * @return [description]\r\n   */\n\n\n  CategoryAxis.prototype.getAnyRangePath = function (start, end, startLocation, endLocation) {\n    var startPos = this.categoryToPosition(start, startLocation);\n    var endPos = this.categoryToPosition(end, endLocation);\n    return this.getPositionRangePath(startPos, endPos); // Base class (Axis) gets range shape from AxisRenderer\n  };\n  /**\r\n   * Takes an absolute position (px) within axis and adjust it to a specific\r\n   * `location` within category it corresponds to.\r\n   *\r\n   * @param position  Source position (px)\r\n   * @param location  Location within category (0-1)\r\n   * @return Adjusted position (px)\r\n   */\n\n\n  CategoryAxis.prototype.roundPosition = function (position, location) {\n    var index = this.positionToIndex(position);\n    return this.indexToPosition(index, location);\n  };\n  /**\r\n   * Finds and returns first series data item with specific category\r\n   * @param series    Target series\r\n   * @param category  Category\r\n   * @return XYSeriesDataItem data item\r\n   */\n\n\n  CategoryAxis.prototype.getFirstSeriesDataItem = function (series, category) {\n    for (var i = 0; i < series.dataItems.length; i++) {\n      var dataItem = series.dataItems.getIndex(i);\n\n      if (series.xAxis == this) {\n        if (dataItem.categoryX == category) {\n          return dataItem;\n        }\n      }\n\n      if (series.yAxis == this) {\n        if (dataItem.categoryY == category) {\n          return dataItem;\n        }\n      }\n    }\n  };\n  /**\r\n   * Finds and returns last series data item with specific category.\r\n   * @param series    Target series\r\n   * @param category  Category\r\n   * @return XYSeriesDataItem data item\r\n   */\n\n\n  CategoryAxis.prototype.getLastSeriesDataItem = function (series, category) {\n    for (var i = series.dataItems.length - 1; i >= 0; i--) {\n      var dataItem = series.dataItems.getIndex(i);\n\n      if (series.xAxis == this) {\n        if (dataItem.categoryX == category) {\n          return dataItem;\n        }\n      }\n\n      if (series.yAxis == this) {\n        if (dataItem.categoryY == category) {\n          return dataItem;\n        }\n      }\n    }\n  }; // todo: optimize\n\n\n  CategoryAxis.prototype.getSeriesDataItemByCategory = function (category, series) {\n    var _this = this;\n\n    var seriesDataItem;\n    series.dataItems.each(function (dataItem) {\n      if (series.xAxis == _this) {\n        if (dataItem.categoryX == category) {\n          seriesDataItem = dataItem;\n        }\n      } else if (series.yAxis == _this) {\n        if (dataItem.categoryY == category) {\n          seriesDataItem = dataItem;\n        }\n      }\n    });\n    return seriesDataItem;\n  };\n  /**\r\n   * Returns a data item from Series that corresponds to a specific absolute\r\n   * position on the Axis.\r\n   *\r\n   * @param series    Target series\r\n   * @param position  Position (px)\r\n   * @return XYSeriesDataItem data item\r\n   */\n\n\n  CategoryAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\n    var _this = this;\n\n    if ($type.isNumber(position)) {\n      var index_1 = this.positionToIndex(position);\n\n      if (index_1 >= this.dataItems.length) {\n        index_1--;\n      }\n\n      var dataItem = this.dataItems.getIndex(index_1);\n\n      if (dataItem) {\n        var category_1 = dataItem.category;\n        var sdi_1;\n        var seriesDataItem = series.dataItems.getIndex(index_1);\n\n        if (seriesDataItem) {\n          if (series.xAxis == this) {\n            if (seriesDataItem.categoryX == category_1) {\n              return seriesDataItem;\n            }\n          }\n\n          if (series.yAxis == this) {\n            if (seriesDataItem.categoryY == category_1) {\n              return seriesDataItem;\n            }\n          }\n        }\n\n        series.dataItems.each(function (dataItem) {\n          if (series.xAxis == _this) {\n            if (dataItem.categoryX == category_1) {\n              if (!sdi_1) {\n                sdi_1 = dataItem;\n              }\n\n              if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\n                sdi_1 = dataItem;\n              }\n            }\n          }\n\n          if (series.yAxis == _this) {\n            if (dataItem.categoryY == category_1) {\n              if (!sdi_1) {\n                sdi_1 = dataItem;\n              }\n\n              if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\n                sdi_1 = dataItem;\n              }\n            }\n          }\n        }); //@todo\n\n        if (findNearest) {}\n\n        return sdi_1;\n      }\n    }\n  };\n  /**\r\n   * Returns the X coordinate for series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @return X coordinate (px)\r\n   */\n\n\n  CategoryAxis.prototype.getX = function (dataItem, key, location, stackKey, range) {\n    var position = this.getPositionX(dataItem, key, location, stackKey, range);\n\n    if ($type.isNaN(position)) {\n      return this.basePoint.x;\n    } else {\n      return this.renderer.positionToPoint(position).x;\n    }\n  };\n  /**\r\n   * Returns relative position on axis for series' data item.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Category\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n\n\n  CategoryAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\n    var position;\n\n    if ($type.hasValue(key)) {\n      position = this.categoryToPosition(dataItem.categories[key], location);\n    }\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return position;\n  };\n  /**\r\n   * Returns the Y coordinate for series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @return Y coordinate (px)\r\n   */\n\n\n  CategoryAxis.prototype.getY = function (dataItem, key, location, stackKey, range) {\n    var position = this.getPositionY(dataItem, key, location, stackKey, range);\n\n    if ($type.isNaN(position)) {\n      return this.basePoint.y;\n    } else {\n      return this.renderer.positionToPoint(position).y;\n    }\n  };\n  /**\r\n   * Returns relative position on axis for series' data item.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Category\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n\n\n  CategoryAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\n    var position;\n\n    if ($type.hasValue(key)) {\n      position = this.categoryToPosition(dataItem.categories[key], location);\n    }\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return position;\n  };\n  /**\r\n   * Returns an angle for series data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @param stackKey  Stack key (?)\r\n   * @param range Range to fit in\r\n   * @return Angle\r\n   */\n\n\n  CategoryAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\n    var position = this.categoryToPosition(dataItem.categories[key], location);\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return this.positionToAngle(position);\n  };\n  /**\r\n   * Returns an absolute pixel coordinate of the start of the cell (category),\r\n   * that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Position (px)\r\n   * @return Cell start position (px)\r\n   */\n\n\n  CategoryAxis.prototype.getCellStartPosition = function (position) {\n    return this.roundPosition(position, 0);\n  };\n  /**\r\n   * Returns an absolute pixel coordinate of the end of the cell (category),\r\n   * that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Position (px)\r\n   * @return Cell end position (px)\r\n   */\n\n\n  CategoryAxis.prototype.getCellEndPosition = function (position) {\n    return this.roundPosition(position, 1);\n  };\n  /**\r\n   * Returns text to show in a category tooltip, based on specific position\r\n   * within axis.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position  Position (px)\r\n   * @return Label (category)\r\n   */\n\n\n  CategoryAxis.prototype.getTooltipText = function (position) {\n    var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\n\n    if (dataItem) {\n      this.tooltipDataItem = dataItem;\n      this.tooltip.dataItem = dataItem;\n\n      if (this.tooltipText) {\n        return this.tooltipText;\n      }\n\n      if (!this._adapterO) {\n        return dataItem.category;\n      } else {\n        return this._adapterO.apply(\"getTooltipText\", dataItem.category);\n      }\n    }\n  };\n  /**\r\n   * Returns an index of the category that corresponds to specific pixel\r\n   * position within axis.\r\n   *\r\n   * @param position  Position (px)\r\n   * @return Category index\r\n   */\n\n\n  CategoryAxis.prototype.positionToIndex = function (position) {\n    position = $math.round(position, 10);\n\n    if (position < 0) {\n      position = 0;\n    }\n\n    if (position > 1) {\n      position = 1;\n    }\n\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var difference = endIndex - startIndex - this.startLocation - (1 - this.endLocation);\n    position += 1 / difference * this.startLocation;\n    var index = null;\n\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks; // in case we have some axis breaks\n\n      $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n        var breakStartPosition = axisBreak.startPosition;\n        var breakEndPosition = axisBreak.endPosition;\n        var breakStartIndex = axisBreak.adjustedStartValue;\n        var breakEndIndex = axisBreak.adjustedEndValue;\n        breakStartIndex = $math.max(breakStartIndex, startIndex);\n        breakEndIndex = $math.min(breakEndIndex, endIndex);\n        var breakSize = axisBreak.breakSize;\n        difference -= (breakEndIndex - breakStartIndex) * (1 - breakSize); // position to the right of break end\n\n        if (position > breakEndPosition) {\n          startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\n        } // position to the left of break start\n        else if (position < breakStartPosition) {} // value within break\n          else {\n              var breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);\n              index = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));\n              return false;\n            }\n\n        return true;\n      });\n    }\n\n    if (!$type.isNumber(index)) {\n      index = Math.floor(position * difference + startIndex);\n    }\n\n    if (index >= this.dataItems.length) {\n      index = this.dataItems.length - 1;\n    } // not good, when panning out of bounds, each time one less item gets selected\n    //if (index >= endIndex) {\n    //\tindex--;\n    //}\n\n\n    return index;\n  };\n  /**\r\n   * Returns category based on position.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * This is a synonim of `getPositionLabel()` implemented here for consistentcy.\r\n   *\r\n   * @since 4.3.8\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n\n\n  CategoryAxis.prototype.positionToCategory = function (position) {\n    return this.getPositionLabel(position);\n  };\n  /**\r\n   * Returns category based on position.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n\n\n  CategoryAxis.prototype.getPositionLabel = function (position) {\n    var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\n\n    if (dataItem) {\n      return dataItem.category;\n    }\n  };\n\n  Object.defineProperty(CategoryAxis.prototype, \"basePoint\", {\n    /**\r\n     * Coordinates of the actual axis start.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Base point\r\n     */\n    get: function () {\n      // This makes base grid to be drawn at the end of the axis and adds extra\n      // grid which we need to nicely close the chart.\n      return this.renderer.positionToPoint(1);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Initializes Axis' renderer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  CategoryAxis.prototype.initRenderer = function () {\n    _super.prototype.initRenderer.call(this);\n\n    var renderer = this.renderer;\n    renderer.baseGrid.disabled = true;\n  };\n\n  Object.defineProperty(CategoryAxis.prototype, \"frequency\", {\n    /**\r\n     * Current frequency of labels of the axis.\r\n     *\r\n     * Normally it would be 1, but when labels start to be hidden due\r\n     * to `minGridDistance` this read-only property will increase.\r\n     *\r\n     * @readonly\r\n     * @since 4.2.0\r\n     * @return Label frequency\r\n     */\n    get: function () {\n      return this._frequency;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxis.prototype, \"sortBySeries\", {\n    /**\r\n     * @return Sort categories?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"sortBySeries\");\n    },\n\n    /**\r\n     * If set to a reference of [[ColumnSeries]] the categories will be sorted\r\n     * by actual values.\r\n     *\r\n     * The categories are ordered in descending order (from highest values to\r\n     * lowest). To reverse the order, use axis renderer's `inversed` setting.\r\n     * E.g.:\r\n     *\r\n     * ```TypeScript\r\n     * categoryAxis.sortBySeries = series;\r\n     * categoryAxis.renderer.inversed = true;\r\n     * ```\r\n     * ```JavaScript\r\n     * categoryAxis.sortBySeries = series;\r\n     * categoryAxis.renderer.inversed = true;\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"xAxes\": [{\r\n     *     // ...\r\n     *     \"sortBySeries\": \"s1\",\r\n     *     \"renderer\": {\r\n     *       // ...\r\n     *       \"inversed\": true\r\n     *     }\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * @since 4.8.7\r\n     * @param  value  Sort categories?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"sortBySeries\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n  CategoryAxis.prototype.processConfig = function (config) {\n    if (config) {\n      if ($type.hasValue(config.sortBySeries) && $type.isString(config.sortBySeries)) {\n        if (this.map.hasKey(config.sortBySeries)) {\n          config.sortBySeries = this.map.getKey(config.sortBySeries);\n        } else {\n          this.addDelayedMap(\"sortBySeries\", config.sortBySeries);\n          delete config.sortBySeries;\n        }\n      }\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return CategoryAxis;\n}(Axis);\n\nexport { CategoryAxis };\n/**\r\n * Register class, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"CategoryAxis\"] = CategoryAxis;\nregistry.registeredClasses[\"CategoryAxisDataItem\"] = CategoryAxisDataItem;","map":{"version":3,"sources":["../../../../../src/.internal/charts/axes/CategoryAxis.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Category axis module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Axis, AxisItemLocation, AxisDataItem, IAxisProperties, IAxisDataFields, IAxisAdapters, IAxisEvents, IAxisDataItemAdapters } from \"./Axis\";\r\nimport { IPoint, IOrientationPoint } from \"../../core/defs/IPoint\";\r\nimport { Animation } from \"../../core/utils/Animation\";\r\nimport { AxisFill } from \"./AxisFill\";\r\nimport { AxisRenderer } from \"./AxisRenderer\";\r\nimport { AxisRendererX } from \"./AxisRendererX\";\r\nimport { AxisRendererY } from \"./AxisRendererY\";\r\nimport { SerialChart } from \"../types/SerialChart\";\r\nimport { AxisTick } from \"./AxisTick\";\r\nimport { Grid } from \"./Grid\";\r\nimport { AxisLabel } from \"./AxisLabel\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { Dictionary } from \"../../core/utils/Dictionary\";\r\nimport { XYSeries, XYSeriesDataItem } from \"../series/XYSeries\";\r\nimport { ColumnSeries } from \"../series/ColumnSeries\";\r\nimport { CategoryAxisBreak } from \"./CategoryAxisBreak\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport { IRange } from \"../../core/defs/IRange\";\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[CategoryAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class CategoryAxisDataItem extends AxisDataItem {\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: CategoryAxis;\r\n\r\n\tpublic seriesDataItems: { [index: string]: XYSeriesDataItem[] } = {};\r\n\r\n\tpublic deltaAnimation: Animation;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ICategoryAxisDataItemAdapters;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"CategoryAxisDataItem\";\r\n\t\tthis.text = \"{category}\";\r\n\r\n\t\tthis.locations.category = 0;\r\n\t\tthis.locations.endCategory = 1;\r\n\r\n\t\tthis.deltaPosition = 0;\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Category.\r\n\t *\r\n\t * @param value  Category\r\n\t */\r\n\tpublic set category(value: string) {\r\n\t\tlet oldCategory = this.properties.category;\r\n\t\tthis.setProperty(\"category\", value);\r\n\t\tif ($type.hasValue(oldCategory) && oldCategory != value) {\r\n\t\t\tif (this.component) {\r\n\t\t\t\tthis.component.validateDataElement(this);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Category\r\n\t */\r\n\tpublic get category(): string {\r\n\t\tif (this._adapterO) {\r\n\t\t\tif (this._adapterO.isEnabled(\"category\")) {\r\n\t\t\t\treturn this._adapterO.apply(\"category\", this.properties.category);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.properties.category;\r\n\t}\r\n\r\n\t/**\r\n\t * End category.\r\n\t *\r\n\t * Used for items that span several categories, like [[CategoryAxisBreak]].\r\n\t *\r\n\t * @param value  End category\r\n\t */\r\n\tpublic set endCategory(value: string) {\r\n\t\tthis.setProperty(\"endCategory\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return End category\r\n\t */\r\n\tpublic get endCategory(): string {\r\n\t\treturn this.properties.endCategory;\r\n\t}\r\n\r\n\tpublic set deltaPosition(value: number) {\r\n\t\tif (value != this.properties.deltaCoordinate) {\r\n\t\t\tthis.setProperty(\"deltaCoordinate\", value);\r\n\t\t\tif (this.component) {\r\n\t\t\t\tthis.component.invalidateDataItems();\r\n\t\t\t\tthis.component.invalidateSeries();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic get deltaPosition(): number {\r\n\t\treturn this.properties.deltaCoordinate;\r\n\t}\r\n}\r\n\r\n/**\r\n * Defines adapters for [[DataItem]]\r\n * Includes both the [[Adapter]] definitions and properties\r\n * @see {@link Adapter}\r\n */\r\nexport interface ICategoryAxisDataItemAdapters extends IAxisDataItemAdapters {\r\n\tcategory: string;\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[CategoryAxis]].\r\n */\r\nexport interface ICategoryAxisDataFields extends IAxisDataFields {\r\n\r\n\t/**\r\n\t * A field that holds category information.\r\n\t */\r\n\tcategory?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines properties for [[CategoryAxis]].\r\n */\r\nexport interface ICategoryAxisProperties extends IAxisProperties {\r\n\tsortBySeries?: ColumnSeries;\r\n}\r\n\r\n/**\r\n * Defines events for [[CategoryAxis]].\r\n */\r\nexport interface ICategoryAxisEvents extends IAxisEvents { }\r\n\r\n/**\r\n * Defines adapter for [[CategoryAxis]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface ICategoryAxisAdapters extends IAxisAdapters, ICategoryAxisProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to create a category-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"CategoryAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Clients\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link ICategoryAxisEvents} for a list of available Events\r\n * @see {@link ICategoryAxisAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class CategoryAxis<T extends AxisRenderer = AxisRenderer> extends Axis<T> {\r\n\r\n\t/**\r\n\t * Defines data fields.\r\n\t */\r\n\tpublic _dataFields: ICategoryAxisDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: ICategoryAxisProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ICategoryAxisAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: ICategoryAxisEvents;\r\n\r\n\t/**\r\n\t * Defines the type of the Date Items.\r\n\t */\r\n\tpublic _dataItem: CategoryAxisDataItem;\r\n\r\n\t/**\r\n\t * Defines the type of the axis breaks.\r\n\t */\r\n\tpublic _axisBreak: CategoryAxisBreak;\r\n\r\n\t/**\r\n\t * A reference to chart the axis is for.\r\n\t */\r\n\tpublic chart: SerialChart;\r\n\r\n\t/**\r\n\t * Frequency of the labels on axis.\r\n\t */\r\n\tprotected _frequency: number;\r\n\r\n\t/**\r\n\t * A collection that holds Axis' data items sorted by each category.\r\n\t */\r\n\tpublic dataItemsByCategory: Dictionary<string, this[\"_dataItem\"]> = new Dictionary<string, this[\"_dataItem\"]>();\r\n\r\n\t/**\r\n\t * last data item is used for the closing grid\r\n\t */\r\n\tprotected _lastDataItem: CategoryAxisDataItem;\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"CategoryAxis\";\r\n\r\n\t\t// Set field name\r\n\t\tthis.axisFieldName = \"category\";\r\n\r\n\t\tthis._lastDataItem = this.createDataItem();\r\n\t\tthis._lastDataItem.component = this;\r\n\t\tthis._disposers.push(this._lastDataItem);\r\n\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t\tlet dataItemsByCategory = this.dataItemsByCategory;\r\n\t\tthis.addDisposer(this.mainDataSet.events.on(\"removed\", function(event){\r\n\t\t\tdataItemsByCategory.removeKey(event.oldValue.category);\r\n\t\t}))\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new CategoryAxisDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n\t *\r\n\t * @return Axis break\r\n\t */\r\n\tprotected createAxisBreak(): this[\"_axisBreak\"] {\r\n\t\treturn new CategoryAxisBreak();\r\n\t}\r\n\r\n\t/**\r\n\t * Processes a related series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem  Data item\r\n\t */\r\n\tpublic processSeriesDataItem(dataItem: XYSeriesDataItem, axisLetter?: string): void {\r\n\t\tsuper.processSeriesDataItem(dataItem, axisLetter);\r\n\t\tlet category: string = (<any>dataItem)[\"category\" + this.axisLetter];\r\n\t\tif ($type.hasValue(category)) {\r\n\t\t\tlet categoryAxisDataItem: this[\"_dataItem\"] = this.dataItemsByCategory.getKey(category);\r\n\t\t\tif (categoryAxisDataItem) {\r\n\t\t\t\tlet seriesId = dataItem.component.uid;\r\n\t\t\t\tlet seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];\r\n\t\t\t\tif (!seriesDataItems) {\r\n\t\t\t\t\tseriesDataItems = [];\r\n\t\t\t\t\tcategoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;\r\n\t\t\t\t}\r\n\t\t\t\tseriesDataItems.push(dataItem);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdataItem.component.dataItems.remove(dataItem);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Validates the data range.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t */\r\n\tpublic validateDataRange(): void {\r\n\r\n\t\tsuper.validateDataRange();\r\n\r\n\t\t$iter.each(this._series.iterator(), (series) => {\r\n\t\t\tif ((series.xAxis instanceof CategoryAxis) && (series.yAxis instanceof CategoryAxis)) {\r\n\t\t\t\tseries.invalidateDataRange();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlet startIndex = this.positionToIndex(this.start);\r\n\t\t\t\tlet endIndex = this.positionToIndex(this.end);\r\n\r\n\t\t\t\tif (endIndex >= this.dataItems.length) {\r\n\t\t\t\t\tendIndex--;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet seriesId = series.uid;\r\n\t\t\t\tlet minIndex: number;\r\n\t\t\t\tlet maxIndex: number;\r\n\r\n\t\t\t\tfor (let i = startIndex; i <= endIndex; i++) {\r\n\t\t\t\t\tlet axisDataItem = this.dataItems.getIndex(i);\r\n\t\t\t\t\tif (axisDataItem) {\r\n\t\t\t\t\t\tlet seriesDataItems = axisDataItem.seriesDataItems[seriesId];\r\n\r\n\t\t\t\t\t\tif (seriesDataItems) {\r\n\t\t\t\t\t\t\tfor (let i = 0; i < seriesDataItems.length; i++) {\r\n\t\t\t\t\t\t\t\tlet seriesDataItem = seriesDataItems[i];\r\n\t\t\t\t\t\t\t\tif (seriesDataItem) {\r\n\t\t\t\t\t\t\t\t\tlet index = seriesDataItem.index;\r\n\t\t\t\t\t\t\t\t\tif (!$type.isNumber(minIndex) || index < minIndex) {\r\n\t\t\t\t\t\t\t\t\t\tminIndex = index;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!$type.isNumber(maxIndex) || index > maxIndex) {\r\n\t\t\t\t\t\t\t\t\t\tmaxIndex = index;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ($type.isNumber(minIndex)) {\r\n\t\t\t\t\tseries.startIndex = minIndex;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tseries.start = this.start;\r\n\t\t\t\t}\r\n\t\t\t\tif ($type.isNumber(maxIndex)) {\r\n\t\t\t\t\tseries.endIndex = maxIndex + 1;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tseries.end = this.end;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// range might not change, but axis breaks might.\r\n\t\t\t\tif (this._axisBreaks && this._axisBreaks.length > 0) {\r\n\t\t\t\t\tseries.invalidateDataRange();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Validates the whole axis. Causes it to redraw.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t */\r\n\tpublic validate(): void {\r\n\r\n\t\tsuper.validate();\r\n\r\n\t\tlet dataCount: number = this.dataItems.length;\r\n\r\n\t\tlet startIndex = $math.fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);\r\n\t\tlet endIndex = $math.fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);\r\n\r\n\t\tif (this.renderer.invalid) {\r\n\t\t\tthis.renderer.validate();\r\n\t\t}\r\n\r\n\t\t// find frequency at which we'll show items\r\n\t\tlet maxCount: number = this.renderer.axisLength / this.renderer.minGridDistance;\r\n\t\tlet frequency: number = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));\r\n\r\n\t\tthis._startIndex = Math.floor(startIndex / frequency) * frequency;\r\n\t\tthis._endIndex = Math.ceil(this.end * dataCount);\r\n\r\n\t\tthis.fixAxisBreaks();\r\n\r\n\t\tif (this._startIndex == this._endIndex) {\r\n\t\t\tthis._endIndex++;\r\n\t\t}\r\n\r\n\t\tthis._frequency = frequency;\r\n\r\n\t\tif (this.axisLength <= 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.maxZoomFactor = this.dataItems.length;\r\n\t\tif (this.dataItems.length <= 0) {\r\n\t\t\tthis.maxZoomFactor = 1;\r\n\t\t}\r\n\r\n\t\tthis.resetIterators();\r\n\r\n\t\t// it's important to use protected variables here, as getters will return 0 - length\r\n\t\t// TODO use iterator instead\r\n\t\t// @ todo: not solved cat axis item fading\r\n\t\tstartIndex = $math.max(0, this._startIndex - this._frequency);\r\n\t\tendIndex = $math.min(this.dataItems.length, this._endIndex + this._frequency);\r\n\r\n\t\tlet itemIndex = 0;\r\n\r\n\t\tfor (let i = 0; i < startIndex; i++) {\r\n\t\t\tlet dataItem = this.dataItems.getIndex(i);\r\n\t\t\tdataItem.__disabled = true;\r\n\t\t}\r\n\r\n\t\tfor (let i = endIndex, len = this.dataItems.length; i < len; i++) {\r\n\t\t\tlet dataItem = this.dataItems.getIndex(i);\r\n\t\t\tdataItem.__disabled = true;\r\n\t\t}\r\n\r\n\t\tfor (let i = startIndex; i < endIndex; i++) {\r\n\t\t\tif (i < this.dataItems.length) {\r\n\t\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(i);\r\n\t\t\t\tif (i / this._frequency == Math.round(i / this._frequency)) {\r\n\t\t\t\t\tlet axisBreak: CategoryAxisBreak = this.isInBreak(i);\r\n\t\t\t\t\tif (!axisBreak) {\r\n\t\t\t\t\t\tthis.appendDataItem(dataItem);\r\n\t\t\t\t\t\tthis.validateDataElement(dataItem, itemIndex);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\titemIndex++;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t//previously we disabled all before, but this is better for cpu\r\n\t\t\t\t\t//this.validateDataElement(dataItem, itemIndex); // helps to solve shrinking // not good - creates all items\r\n\t\t\t\t\tdataItem.__disabled = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.appendDataItem(this._lastDataItem);\r\n\t\tthis.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);\r\n\r\n\t\tif (this._axisBreaks) {\r\n\t\t\tlet axisBreaks = this._axisBreaks;\r\n\r\n\t\t\taxisBreaks.each((axisBreak) => {\r\n\t\t\t\tlet adjustedStartValue: number = axisBreak.adjustedStartValue;\r\n\t\t\t\tlet adjustedEndValue: number = axisBreak.adjustedEndValue;\r\n\r\n\t\t\t\tif ($math.intersect({ start: adjustedStartValue, end: adjustedEndValue }, { start: this._startIndex, end: this._endIndex })) {\r\n\r\n\t\t\t\t\tfor (let b = adjustedStartValue; b <= adjustedEndValue; b++) {\r\n\t\t\t\t\t\tlet dataItem = this.dataItems.getIndex(b);\r\n\t\t\t\t\t\tdataItem.__disabled = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet frequency: number = $math.fitToRange(Math.ceil(this._frequency / axisBreak.breakSize), 1, adjustedEndValue - adjustedStartValue);\r\n\t\t\t\t\tlet itemIndex = 0;\r\n\t\t\t\t\tif (axisBreak.breakSize > 0) {\r\n\t\t\t\t\t\t// TODO use iterator instead\r\n\t\t\t\t\t\tfor (let b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency) {\r\n\t\t\t\t\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(b);\r\n\t\t\t\t\t\t\tdataItem.__disabled = false;\r\n\t\t\t\t\t\t\tthis.appendDataItem(dataItem);\r\n\t\t\t\t\t\t\tthis.validateDataElement(dataItem, itemIndex);\r\n\t\t\t\t\t\t\titemIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis.validateBreaks();\r\n\t\tthis.validateAxisRanges();\r\n\r\n\t\tthis.ghostLabel.invalidate(); // solves font issue\r\n\t\tthis.renderer.invalidateLayout();\r\n\t}\r\n\r\n\t/**\r\n\t * [validateDataElement description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem   [description]\r\n\t * @param itemIndex  [description]\r\n\t */\r\n\tpublic validateDataElement(dataItem: this[\"_dataItem\"], itemIndex?: number, index?: number): void {\r\n\t\tsuper.validateDataElement(dataItem);\r\n\r\n\t\tdataItem.itemIndex = this._axisItemCount;\r\n\t\tthis._axisItemCount++;\r\n\r\n\t\t//dataItem.__disabled = false;\r\n\r\n\t\tlet renderer: AxisRenderer = this.renderer;\r\n\t\tif (!$type.isNumber(index)) {\r\n\t\t\tindex = this.categoryToIndex(dataItem.category);\r\n\t\t}\r\n\r\n\t\tlet endIndex = this.categoryToIndex(dataItem.endCategory);\r\n\r\n\t\tif (!$type.isNumber(endIndex)) {\r\n\t\t\tendIndex = index;\r\n\t\t}\r\n\r\n\t\tlet position: number = this.indexToPosition(index, dataItem.locations.category);\r\n\t\tlet endPosition: number = this.indexToPosition(endIndex, dataItem.locations.endCategory);\r\n\r\n\t\tdataItem.position = position;\r\n\r\n\t\tlet fillEndIndex: number;\r\n\t\tlet fillPosition: number;\r\n\t\tlet fillEndPosition: number;\r\n\r\n\t\tif (dataItem.isRange) {\r\n\t\t\tfillEndIndex = endIndex;\r\n\t\t\tfillPosition = this.indexToPosition(index, dataItem.locations.category);\r\n\t\t\tfillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);\r\n\t\t}\r\n\r\n\t\tdataItem.point = renderer.positionToPoint(position);\r\n\r\n\t\tlet tick: AxisTick = dataItem.tick;\r\n\t\tif (tick && !tick.disabled) {\r\n\t\t\trenderer.updateTickElement(tick, position, endPosition);\r\n\t\t}\r\n\r\n\t\tlet grid: Grid = dataItem.grid;\r\n\t\tif (grid && !grid.disabled) {\r\n\t\t\trenderer.updateGridElement(grid, position, endPosition);\r\n\t\t}\r\n\r\n\r\n\t\tlet label: AxisLabel = dataItem.label;\r\n\t\tif (label && !label.disabled) {\r\n\t\t\t// theorethically this might result problems if category text changes, the range text won't change. But otherwise range.label.text = \"custom text\" wont' work, which is not intuitive.\r\n\t\t\tif (!dataItem.isRange || label.text == undefined) {\r\n\t\t\t\tdataItem.text = dataItem.text;\r\n\t\t\t}\r\n\r\n\t\t\trenderer.updateLabelElement(label, position, endPosition);\r\n\r\n\t\t\tif ((renderer instanceof AxisRendererY && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth) || (renderer instanceof AxisRendererX && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight)) {\r\n\t\t\t\tif (dataItem.label.html) {\r\n\t\t\t\t\tthis.ghostLabel.html = dataItem.label.currentText;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.ghostLabel.text = dataItem.label.currentText;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet fill: AxisFill = dataItem.axisFill;\r\n\t\tif (fill && !fill.disabled) {\r\n\r\n\t\t\tif (!dataItem.isRange) {\r\n\t\t\t\tfillEndIndex = index + this._frequency;\r\n\t\t\t\tfillPosition = this.indexToPosition(index, fill.location);\r\n\t\t\t\tfillEndPosition = this.indexToPosition(fillEndIndex, fill.location);\r\n\t\t\t}\r\n\r\n\t\t\trenderer.updateFillElement(fill, fillPosition, fillEndPosition);\r\n\t\t\tif (!dataItem.isRange) {\r\n\t\t\t\tthis.fillRule(dataItem, itemIndex);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (dataItem.bullet) {\r\n\t\t\trenderer.updateBullet(dataItem.bullet, position, endPosition);\r\n\t\t}\r\n\r\n\r\n\t\tlet mask: AxisFill = dataItem.mask;\r\n\t\tif (mask) {\r\n\t\t\trenderer.updateFillElement(mask, fillPosition, fillEndPosition);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic disposeData() {\r\n\t\tthis.dataItemsByCategory.clear();\r\n\t\tsuper.disposeData();\r\n\t}\r\n\r\n\t/**\r\n\t * Processes the axis data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param dataItem     Data item\r\n\t * @param dataContext  The raw data that corresponds to this data item\r\n\t */\r\n\tpublic processDataItem(dataItem: this[\"_dataItem\"], dataContext: Object): void {\r\n\t\tif (dataItem) {\r\n\t\t\t// creat a collection for fast access\r\n\t\t\tsuper.processDataItem(dataItem, dataContext);\r\n\t\t\t// check if such category already exists\r\n\t\t\t//let existingDataItem: CategoryAxisDataItem = this.dataItemsByCategory.getKey(dataItem.category);\r\n\t\t\t//if (existingDataItem && existingDataItem != dataItem) {\r\n\t\t\t//\tthis.dataItems.remove(existingDataItem);\r\n\t\t\t//}\r\n\r\n\t\t\tif ($type.hasValue(dataItem.category)) {\r\n\t\t\t\tthis.dataItemsByCategory.setKey(dataItem.category, dataItem);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tprotected getDataItem(dataContext?: any): this[\"_dataItem\"] {\r\n\t\tlet category: string = <string>(dataContext[this.dataFields.category]);\r\n\t\tif ($type.hasValue(category)) {\r\n\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItemsByCategory.getKey(category);\r\n\r\n\t\t\tif (dataItem) {\r\n\t\t\t\treturn dataItem;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn this.dataItems.create();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a category index to an actual screen coordinate on the axis.\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t *\r\n\t * @param index     Index\r\n\t * @param location  Location (0-1)\r\n\t * @return Position (px)\r\n\t */\r\n\tpublic indexToPosition(index: number, location?: AxisItemLocation | number): number {\r\n\t\tif (!$type.isNumber(location)) {\r\n\t\t\tlocation = 0.5;\r\n\t\t}\r\n\r\n\t\tlet startIndex: number = this.startIndex;\r\n\t\tlet endIndex: number = this.endIndex;\r\n\r\n\t\tlet difference: number = this.adjustDifference(startIndex, endIndex);\r\n\r\n\t\tlet startLocation = this.startLocation;\r\n\t\tlet endLocation = this.endLocation;\r\n\r\n\t\tdifference -= startLocation;\r\n\t\tdifference -= (1 - endLocation);\r\n\r\n\t\tif (this._axisBreaks) {\r\n\t\t\tlet axisBreaks = this._axisBreaks;\r\n\r\n\t\t\t$iter.eachContinue(axisBreaks.iterator(), (axisBreak) => {\r\n\t\t\t\tlet breakStartIndex: number = axisBreak.adjustedStartValue;\r\n\t\t\t\tlet breakEndIndex: number = axisBreak.adjustedEndValue;\r\n\r\n\t\t\t\tif (index < startIndex || !$type.isNumber(breakStartIndex) || !$type.isNumber(breakEndIndex)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ($math.intersect({ start: breakStartIndex, end: breakEndIndex }, { start: startIndex, end: endIndex })) {\r\n\t\t\t\t\tbreakStartIndex = Math.max(startIndex, breakStartIndex);\r\n\t\t\t\t\tbreakEndIndex = Math.min(endIndex, breakEndIndex);\r\n\r\n\t\t\t\t\tlet breakSize: number = axisBreak.breakSize;\r\n\r\n\t\t\t\t\t// value to the right of break end\r\n\t\t\t\t\tif (index > breakEndIndex) {\r\n\t\t\t\t\t\tstartIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// value to the left of break start\r\n\t\t\t\t\telse if (index < breakStartIndex) {\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// value within break\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tindex = breakStartIndex + (index - breakStartIndex) * breakSize;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlet deltaPosition = 0;\r\n\t\tlet dataItem = this.dataItems.getIndex(index);\r\n\t\tif (dataItem) {\r\n\t\t\tdeltaPosition = dataItem.deltaPosition;\r\n\t\t}\r\n\r\n\t\treturn $math.round(deltaPosition + (index + location - startLocation - startIndex) / difference, 5);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a string category name to relative position on axis.\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t *\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Position\r\n\t */\r\n\tpublic categoryToPosition(category: string, location?: AxisItemLocation): number {\r\n\t\tlet index: number = this.categoryToIndex(category);\r\n\t\treturn this.indexToPosition(index, location);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a string category name to a orientation point (x, y, angle) on axis\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Orientation point\r\n\t */\r\n\tpublic categoryToPoint(category: string, location?: AxisItemLocation): IOrientationPoint {\r\n\t\tlet position = this.categoryToPosition(category, location);\r\n\t\tlet point = this.renderer.positionToPoint(position);\r\n\t\tlet angle = this.renderer.positionToAngle(position);\r\n\t\treturn { x: point.x, y: point.y, angle: angle };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts a string category name to a orientation point (x, y, angle) on axis\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Orientation point\r\n\t */\r\n\tanyToPoint(category: string, location?: AxisItemLocation): IOrientationPoint {\r\n\t\treturn this.categoryToPoint(category, location);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts a string category name to relative position on axis.\r\n\t *\r\n\t * An alias to `categoryToPosition()`.\r\n\t *\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Relative position\r\n\t */\r\n\tpublic anyToPosition(category: string, location?: AxisItemLocation): number {\r\n\t\treturn this.categoryToPosition(category, location);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts named category to an index of data item it corresponds to.\r\n\t *\r\n\t * @param category  Category\r\n\t * @return Data item index\r\n\t */\r\n\tpublic categoryToIndex(category: string): number {\r\n\t\tif ($type.hasValue(category)) {\r\n\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItemsByCategory.getKey(category);\r\n\t\t\tif (dataItem) {\r\n\t\t\t\treturn dataItem.index;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms the axis to specific named ctaegories.\r\n\t *\r\n\t * @param startCategory  Start category\r\n\t * @param endCategory    End category\r\n\t */\r\n\tpublic zoomToCategories(startCategory: string, endCategory: string): void {\r\n\t\tthis.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);\r\n\t}\r\n\r\n\t/**\r\n\t * [getAnyRangePath description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param start         [description]\r\n\t * @param end           [description]\r\n\t * @param startLocation [description]\r\n\t * @param endLocation   [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic getAnyRangePath(start: string, end: string, startLocation?: AxisItemLocation, endLocation?: AxisItemLocation): string {\r\n\t\tlet startPos: number = this.categoryToPosition(start, startLocation);\r\n\t\tlet endPos: number = this.categoryToPosition(end, endLocation);\r\n\t\treturn this.getPositionRangePath(startPos, endPos); // Base class (Axis) gets range shape from AxisRenderer\r\n\t}\r\n\r\n\t/**\r\n\t * Takes an absolute position (px) within axis and adjust it to a specific\r\n\t * `location` within category it corresponds to.\r\n\t *\r\n\t * @param position  Source position (px)\r\n\t * @param location  Location within category (0-1)\r\n\t * @return Adjusted position (px)\r\n\t */\r\n\tpublic roundPosition(position: number, location?: AxisItemLocation): number {\r\n\t\tlet index: number = this.positionToIndex(position);\r\n\t\treturn this.indexToPosition(index, location);\r\n\t}\r\n\r\n\t/**\r\n\t * Finds and returns first series data item with specific category\r\n\t * @param series    Target series\r\n\t * @param category  Category\r\n\t * @return XYSeriesDataItem data item\r\n\t */\r\n\tpublic getFirstSeriesDataItem(series: XYSeries, category: string): XYSeriesDataItem {\r\n\r\n\t\tfor (let i = 0; i < series.dataItems.length; i++) {\r\n\t\t\tlet dataItem = series.dataItems.getIndex(i);\r\n\t\t\tif (series.xAxis == this) {\r\n\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (series.yAxis == this) {\r\n\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Finds and returns last series data item with specific category.\r\n\t * @param series    Target series\r\n\t * @param category  Category\r\n\t * @return XYSeriesDataItem data item\r\n\t */\r\n\tpublic getLastSeriesDataItem(series: XYSeries, category: string): XYSeriesDataItem {\r\n\r\n\t\tfor (let i = series.dataItems.length - 1; i >= 0; i--) {\r\n\t\t\tlet dataItem = series.dataItems.getIndex(i);\r\n\t\t\tif (series.xAxis == this) {\r\n\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (series.yAxis == this) {\r\n\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// todo: optimize\r\n\tpublic getSeriesDataItemByCategory(category: string, series: XYSeries): XYSeriesDataItem {\r\n\t\tlet seriesDataItem: XYSeriesDataItem;\r\n\t\tseries.dataItems.each((dataItem) => {\r\n\t\t\tif (series.xAxis == this) {\r\n\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\tseriesDataItem = dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (series.yAxis == this) {\r\n\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\tseriesDataItem = dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn seriesDataItem;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a data item from Series that corresponds to a specific absolute\r\n\t * position on the Axis.\r\n\t *\r\n\t * @param series    Target series\r\n\t * @param position  Position (px)\r\n\t * @return XYSeriesDataItem data item\r\n\t */\r\n\tpublic getSeriesDataItem(series: XYSeries, position: number, findNearest?: boolean): XYSeriesDataItem {\r\n\r\n\t\tif ($type.isNumber(position)) {\r\n\r\n\t\t\tlet index = this.positionToIndex(position);\r\n\r\n\t\t\tif (index >= this.dataItems.length) {\r\n\t\t\t\tindex--;\r\n\t\t\t}\r\n\r\n\t\t\tlet dataItem = this.dataItems.getIndex(index);\r\n\r\n\t\t\tif (dataItem) {\r\n\t\t\t\tlet category = dataItem.category;\r\n\t\t\t\tlet sdi: XYSeriesDataItem;\r\n\r\n\t\t\t\tlet seriesDataItem = series.dataItems.getIndex(index);\r\n\t\t\t\tif (seriesDataItem) {\r\n\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\tif (seriesDataItem.categoryX == category) {\r\n\t\t\t\t\t\t\treturn seriesDataItem;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (series.yAxis == this) {\r\n\t\t\t\t\t\tif (seriesDataItem.categoryY == category) {\r\n\t\t\t\t\t\t\treturn seriesDataItem;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tseries.dataItems.each((dataItem) => {\r\n\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\t\t\tif (!sdi) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (Math.abs(index - sdi.index) > Math.abs(index - dataItem.index)) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (series.yAxis == this) {\r\n\t\t\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\t\t\tif (!sdi) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (Math.abs(index - sdi.index) > Math.abs(index - dataItem.index)) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\r\n\t\t\t\t//@todo\r\n\t\t\t\tif (findNearest) {\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn sdi;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns the X coordinate for series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Category\r\n\t * @param location  Location (0-1)\r\n\t * @return X coordinate (px)\r\n\t */\r\n\tpublic getX(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position = this.getPositionX(dataItem, key, location, stackKey, range);\r\n\r\n\t\tif ($type.isNaN(position)) {\r\n\t\t\treturn this.basePoint.x;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.renderer.positionToPoint(position).x;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns relative position on axis for series' data item.\r\n\t *\r\n\t * @since 4.5.14\r\n\t * @param  dataItem  Data item\r\n\t * @param  key       Category\r\n\t * @param  location  Location (0-1)\r\n\t * @return           Relative position\r\n\t */\r\n\tpublic getPositionX(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position;\r\n\t\tif ($type.hasValue(key)) {\r\n\t\t\tposition = this.categoryToPosition(dataItem.categories[key], location);\r\n\t\t}\r\n\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn position;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Y coordinate for series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Category\r\n\t * @param location  Location (0-1)\r\n\t * @return Y coordinate (px)\r\n\t */\r\n\tpublic getY(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\r\n\t\tlet position = this.getPositionY(dataItem, key, location, stackKey, range);\r\n\r\n\t\tif ($type.isNaN(position)) {\r\n\t\t\treturn this.basePoint.y;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.renderer.positionToPoint(position).y;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns relative position on axis for series' data item.\r\n\t *\r\n\t * @since 4.5.14\r\n\t * @param  dataItem  Data item\r\n\t * @param  key       Category\r\n\t * @param  location  Location (0-1)\r\n\t * @return           Relative position\r\n\t */\r\n\tpublic getPositionY(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position;\r\n\t\tif ($type.hasValue(key)) {\r\n\t\t\tposition = this.categoryToPosition(dataItem.categories[key], location);\r\n\t\t}\r\n\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn position;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an angle for series data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Category\r\n\t * @param location  Location (0-1)\r\n\t * @param stackKey  Stack key (?)\r\n\t * @param range Range to fit in\r\n\t * @return Angle\r\n\t */\r\n\tpublic getAngle(dataItem: XYSeriesDataItem, key: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position = this.categoryToPosition(dataItem.categories[key], location);\r\n\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn this.positionToAngle(position);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an absolute pixel coordinate of the start of the cell (category),\r\n\t * that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Position (px)\r\n\t * @return Cell start position (px)\r\n\t */\r\n\tpublic getCellStartPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an absolute pixel coordinate of the end of the cell (category),\r\n\t * that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Position (px)\r\n\t * @return Cell end position (px)\r\n\t */\r\n\tpublic getCellEndPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 1);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns text to show in a category tooltip, based on specific position\r\n\t * within axis.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param position  Position (px)\r\n\t * @return Label (category)\r\n\t */\r\n\tpublic getTooltipText(position: number): string {\r\n\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(this.positionToIndex(position));\r\n\r\n\t\tif (dataItem) {\r\n\t\t\tthis.tooltipDataItem = dataItem;\r\n\t\t\tthis.tooltip.dataItem = dataItem;\r\n\t\t\tif (this.tooltipText) {\r\n\t\t\t\treturn this.tooltipText;\r\n\t\t\t}\r\n\r\n\t\t\tif (!this._adapterO) {\r\n\t\t\t\treturn dataItem.category;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn this._adapterO.apply(\"getTooltipText\", dataItem.category);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an index of the category that corresponds to specific pixel\r\n\t * position within axis.\r\n\t *\r\n\t * @param position  Position (px)\r\n\t * @return Category index\r\n\t */\r\n\tpublic positionToIndex(position: number): number {\r\n\t\tposition = $math.round(position, 10);\r\n\t\tif (position < 0) {\r\n\t\t\tposition = 0;\r\n\t\t}\r\n\r\n\t\tif (position > 1) {\r\n\t\t\tposition = 1;\r\n\t\t}\r\n\r\n\t\tlet startIndex: number = this.startIndex;\r\n\t\tlet endIndex: number = this.endIndex;\r\n\t\tlet difference: number = endIndex - startIndex - this.startLocation - (1 - this.endLocation);\r\n\r\n\t\tposition += 1 / difference * this.startLocation;\r\n\t\tlet index: number = null;\r\n\r\n\t\tif (this._axisBreaks) {\r\n\t\t\tlet axisBreaks = this._axisBreaks;\r\n\r\n\t\t\t// in case we have some axis breaks\r\n\t\t\t$iter.eachContinue(axisBreaks.iterator(), (axisBreak) => {\r\n\t\t\t\tlet breakStartPosition: number = axisBreak.startPosition;\r\n\t\t\t\tlet breakEndPosition: number = axisBreak.endPosition;\r\n\r\n\t\t\t\tlet breakStartIndex: number = axisBreak.adjustedStartValue;\r\n\t\t\t\tlet breakEndIndex: number = axisBreak.adjustedEndValue;\r\n\r\n\t\t\t\tbreakStartIndex = $math.max(breakStartIndex, startIndex);\r\n\t\t\t\tbreakEndIndex = $math.min(breakEndIndex, endIndex);\r\n\r\n\t\t\t\tlet breakSize: number = axisBreak.breakSize;\r\n\r\n\t\t\t\tdifference -= (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n\r\n\t\t\t\t// position to the right of break end\r\n\t\t\t\tif (position > breakEndPosition) {\r\n\t\t\t\t\tstartIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n\t\t\t\t}\r\n\t\t\t\t// position to the left of break start\r\n\t\t\t\telse if (position < breakStartPosition) {\r\n\r\n\t\t\t\t}\r\n\t\t\t\t// value within break\r\n\t\t\t\telse {\r\n\t\t\t\t\tlet breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);\r\n\t\t\t\t\tindex = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(index)) {\r\n\t\t\tindex = Math.floor(position * difference + startIndex);\r\n\t\t}\r\n\t\tif (index >= this.dataItems.length) {\r\n\t\t\tindex = this.dataItems.length - 1;\r\n\t\t}\r\n\t\t// not good, when panning out of bounds, each time one less item gets selected\r\n\t\t//if (index >= endIndex) {\r\n\t\t//\tindex--;\r\n\t\t//}\r\n\r\n\t\treturn index;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns category based on position.\r\n\t *\r\n\t * Please note that `position` represents position within axis which may be\r\n\t * zoomed and not correspond to Cursor's `position`.\r\n\t *\r\n\t * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n\t *\r\n\t * This is a synonim of `getPositionLabel()` implemented here for consistentcy.\r\n\t *\r\n\t * @since 4.3.8\r\n\t * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n\t * @param position  Relative position on axis (0-1)\r\n\t * @return Position label\r\n\t */\r\n\tpublic positionToCategory(position: number): string {\r\n\t\treturn this.getPositionLabel(position);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns category based on position.\r\n\t *\r\n\t * Please note that `position` represents position within axis which may be\r\n\t * zoomed and not correspond to Cursor's `position`.\r\n\t *\r\n\t * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n\t * @param position  Relative position on axis (0-1)\r\n\t * @return Position label\r\n\t */\r\n\tpublic getPositionLabel(position: number): string {\r\n\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(this.positionToIndex(position));\r\n\t\tif (dataItem) {\r\n\t\t\treturn dataItem.category;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Coordinates of the actual axis start.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Base point\r\n\t */\r\n\tpublic get basePoint(): IPoint {\r\n\t\t// This makes base grid to be drawn at the end of the axis and adds extra\r\n\t\t// grid which we need to nicely close the chart.\r\n\t\treturn this.renderer.positionToPoint(1);\r\n\t}\r\n\r\n\t/**\r\n\t * Initializes Axis' renderer.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic initRenderer(): void {\r\n\t\tsuper.initRenderer();\r\n\r\n\t\tlet renderer = this.renderer;\r\n\t\trenderer.baseGrid.disabled = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Current frequency of labels of the axis.\r\n\t *\r\n\t * Normally it would be 1, but when labels start to be hidden due\r\n\t * to `minGridDistance` this read-only property will increase.\r\n\t *\r\n\t * @readonly\r\n\t * @since 4.2.0\r\n\t * @return Label frequency\r\n\t */\r\n\tpublic get frequency(): number {\r\n\t\treturn this._frequency;\r\n\t}\r\n\r\n\t/**\r\n\t * If set to a reference of [[ColumnSeries]] the categories will be sorted\r\n\t * by actual values.\r\n\t *\r\n\t * The categories are ordered in descending order (from highest values to\r\n\t * lowest). To reverse the order, use axis renderer's `inversed` setting.\r\n\t * E.g.:\r\n\t *\r\n\t * ```TypeScript\r\n\t * categoryAxis.sortBySeries = series;\r\n\t * categoryAxis.renderer.inversed = true;\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * categoryAxis.sortBySeries = series;\r\n\t * categoryAxis.renderer.inversed = true;\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"xAxes\": [{\r\n\t *     // ...\r\n\t *     \"sortBySeries\": \"s1\",\r\n\t *     \"renderer\": {\r\n\t *       // ...\r\n\t *       \"inversed\": true\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @since 4.8.7\r\n\t * @param  value  Sort categories?\r\n\t */\r\n\tpublic set sortBySeries(value: ColumnSeries) {\r\n\t\tthis.setPropertyValue(\"sortBySeries\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Sort categories?\r\n\t */\r\n\tpublic get sortBySeries(): ColumnSeries {\r\n\t\treturn this.getPropertyValue(\"sortBySeries\");\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON-based config before it is applied to the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param config  Config\r\n\t */\r\n\tpublic processConfig(config?: { [index: string]: any }): void {\r\n\r\n\t\tif (config) {\r\n\r\n\t\t\tif ($type.hasValue(config.sortBySeries) && $type.isString(config.sortBySeries)) {\r\n\t\t\t\tif (this.map.hasKey(config.sortBySeries)) {\r\n\t\t\t\t\tconfig.sortBySeries = this.map.getKey(config.sortBySeries);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.addDelayedMap(\"sortBySeries\", config.sortBySeries);\r\n\t\t\t\t\tdelete config.sortBySeries;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tsuper.processConfig(config);\r\n\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"CategoryAxis\"] = CategoryAxis;\r\nregistry.registeredClasses[\"CategoryAxisDataItem\"] = CategoryAxisDataItem;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}