{"ast":null,"code":"/**\r\n * This module contains PatternSet object definition\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObject } from \"../Base\";\nimport { Color } from \"./Color\";\nimport { InterfaceColorSet } from \"./InterfaceColorSet\";\nimport { LinePattern } from \"../rendering/fills/LinePattern\";\nimport { RectPattern } from \"../rendering/fills/RectPattern\";\nimport { CirclePattern } from \"../rendering/fills/CirclePattern\";\nimport { registry } from \"../Registry\";\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines an interable list of distinctive patterns that can be used in\r\n * conjunction to colors to generate various fill patterns.\r\n *\r\n * @important\r\n * @since 4.7.5\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/colors/} for color-related info\r\n */\n\nvar PatternSet =\n/** @class */\nfunction (_super) {\n  __extends(PatternSet, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function PatternSet() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Holds the list of the colors in this set. (preset or auto-generated)\r\n     */\n\n\n    _this._list = [];\n    /**\r\n     * Current step.\r\n     */\n\n    _this._currentStep = 0;\n    /**\r\n     * If set to non-zero value, the PatternSet will start iterating patterns from\r\n     * that particular index, not the first pattern in the list.\r\n     */\n\n    _this._startIndex = 0;\n    /**\r\n     * Current pass in cycle. Once all patterns in the list are iterated,\r\n     * iteration restarts from beginning and currentPass is incremented.\r\n     */\n\n    _this._currentPass = 0;\n    /**\r\n     * A base color. If there are no colors pre-set in the color list, ColorSet\r\n     * will use this color as a base when generating new ones, applying\r\n     * `stepOptions` and `passOptions` to this base color.\r\n     */\n\n    _this.baseColor = new Color({\n      r: 103,\n      g: 183,\n      b: 220\n    });\n    _this.className = \"PatternSet\"; // Set base color to be used for pattern elements\n\n    var interfaceColors = new InterfaceColorSet(); // Set default patterns\n\n    _this.list = [_this.getLinePattern(1000, 45, 1, 6), _this.getRectPattern(10, 0, 4), _this.getLinePattern(1000, -45, 1, 6), _this.getCirclePattern(11, 2, true), _this.getLinePattern(6, 90, 1), _this.getRectPattern(12, 45, 6, true), _this.getLinePattern(6, 0, 1), _this.getRectPattern(7, 0, 4), _this.getLinePattern(1000, 45, 2, 3, \"4,2\"), _this.getCirclePattern(9, 3, false), _this.getLinePattern(1000, -45, 2, 3, \"4,2\"), _this.getRectPattern(10, 45, Math.sqrt(50)), _this.getLinePattern(1000, -45, 2, 1), _this.getRectPattern(10, 0, 9), _this.getLinePattern(1000, 45, 2, 1), _this.getLinePattern(1000, 0, 3, 1), _this.getRectPattern(10, 45, 10), _this.getLinePattern(1000, 90, 3, 1)];\n    _this.baseColor = interfaceColors.getFor(\"stroke\");\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  PatternSet.prototype.getLinePattern = function (size, rotation, thickness, gap, strokeDashArray) {\n    var pattern = new LinePattern();\n    pattern.width = size;\n    pattern.height = size;\n    pattern.stroke = this.baseColor;\n    pattern.gap = gap;\n    pattern.strokeDasharray = strokeDashArray;\n    pattern.strokeWidth = thickness;\n    pattern.rotation = rotation;\n    return pattern;\n  };\n\n  PatternSet.prototype.getRectPattern = function (size, rotation, thickness, outline) {\n    var pattern = new RectPattern();\n    pattern.width = size;\n    pattern.height = size;\n    pattern.rectWidth = thickness;\n    pattern.rectHeight = thickness;\n\n    if (outline) {\n      pattern.stroke = this.baseColor;\n      pattern.strokeWidth = 1;\n      pattern.fillOpacity = 0;\n    } else {\n      pattern.fill = this.baseColor;\n      pattern.strokeWidth = 0;\n    }\n\n    if (rotation != 0) {\n      pattern.shapeRendering = \"auto\";\n    }\n\n    pattern.rotation = rotation;\n    return pattern;\n  };\n\n  PatternSet.prototype.getCirclePattern = function (size, radius, outline) {\n    var pattern = new CirclePattern();\n    pattern.width = size;\n    pattern.height = size;\n    pattern.shapeRendering = \"auto\";\n    pattern.radius = radius;\n\n    if (outline) {\n      pattern.stroke = this.baseColor;\n      pattern.strokeWidth = 1;\n      pattern.fillOpacity = 0;\n    } else {\n      pattern.fill = this.baseColor;\n      pattern.strokeWidth = 0;\n    }\n\n    return pattern;\n  };\n\n  Object.defineProperty(PatternSet.prototype, \"list\", {\n    /**\r\n     * @return Pattern list\r\n     */\n    get: function get() {\n      return this._list;\n    },\n\n    /**\r\n     * List of pre-defined patterns to be used in set.\r\n     *\r\n     * @param value Pattern list\r\n     */\n    set: function set(value) {\n      this._list = value;\n      this.reset();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns the next pattern in list.\r\n   *\r\n   * @return Pattern\r\n   */\n\n  PatternSet.prototype.next = function () {\n    var pattern = this.getIndex(this.currentStep);\n    this._currentStep++;\n    return pattern;\n  };\n  /**\r\n   * Returns a color at specific index in the list.\r\n   *\r\n   * @param  i  Index\r\n   * @return Pattern\r\n   */\n\n\n  PatternSet.prototype.getIndex = function (i) {\n    var pattern;\n\n    while (this.list.length <= i) {\n      this.generatePatterns();\n    }\n\n    pattern = this.list[i];\n    return pattern.clone();\n  };\n  /**\r\n   * Generates a new set of patterns.\r\n   */\n\n\n  PatternSet.prototype.generatePatterns = function () {\n    var count = this.list.length / (this._currentPass + 1);\n    this._currentPass++;\n\n    for (var i = 0; i < count; i++) {\n      this.list.push(this.list[i].clone());\n    }\n  };\n  /**\r\n   * Resets internal iterator.\r\n   *\r\n   * Calling `next()` after this will return the very first color in the color\r\n   * list, even if it was already returned before.\r\n   */\n\n\n  PatternSet.prototype.reset = function () {\n    this._currentStep = this._startIndex;\n  };\n\n  Object.defineProperty(PatternSet.prototype, \"currentStep\", {\n    /**\r\n     * @return Step\r\n     */\n    get: function get() {\n      return this._currentStep;\n    },\n\n    /**\r\n     * Sets current color iteration. You can use this property to skip some\r\n     * colors from iteration. E.g. setting it to `10` will skip first ten\r\n     * colors.\r\n     *\r\n     * Please note that the number is zero-based.\r\n     *\r\n     * @param value  Step\r\n     */\n    set: function set(value) {\n      this._currentStep = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PatternSet.prototype, \"startIndex\", {\n    /**\r\n     * @return Index\r\n     */\n    get: function get() {\n      return this._startIndex;\n    },\n\n    /**\r\n     * If set to non-zero value, the ColorSet will start iterating colors from\r\n     * that particular index, not the first color in the list.\r\n     *\r\n     * @default 0\r\n     * @param  value  Index\r\n     */\n    set: function set(value) {\n      this._startIndex = value;\n      this.reset();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n  PatternSet.prototype.processConfig = function (config) {\n    // if (config) {\n    // \t// Set up axis ranges\n    // \tif ($type.hasValue(config.list) && $type.isArray(config.list)) {\n    // \t\tfor (let i = 0, len = config.list.length; i < len; i++) {\n    // \t\t\tif (!(config.list[i] instanceof Color)) {\n    // \t\t\t\tconfig.list[i] = color(config.list[i]);\n    // \t\t\t}\n    // \t\t}\n    // \t}\n    // }\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return PatternSet;\n}(BaseObject);\n\nexport { PatternSet };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"PatternSet\"] = PatternSet;","map":{"version":3,"sources":["../../../../../src/.internal/core/utils/PatternSet.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * This module contains PatternSet object definition\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObject } from \"../Base\";\r\nimport { Color } from \"./Color\";\r\nimport { InterfaceColorSet } from \"./InterfaceColorSet\";\r\nimport { Pattern } from \"../rendering/fills/Pattern\";\r\nimport { LinePattern } from \"../rendering/fills/LinePattern\";\r\nimport { RectPattern } from \"../rendering/fills/RectPattern\";\r\nimport { CirclePattern } from \"../rendering/fills/CirclePattern\";\r\nimport { registry } from \"../Registry\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines an interable list of distinctive patterns that can be used in\r\n * conjunction to colors to generate various fill patterns.\r\n *\r\n * @important\r\n * @since 4.7.5\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/colors/} for color-related info\r\n */\r\nexport class PatternSet extends BaseObject {\r\n\r\n\t/**\r\n\t * Holds the list of the colors in this set. (preset or auto-generated)\r\n\t */\r\n\tprotected _list: Pattern[] = [];\r\n\r\n\t/**\r\n\t * Current step.\r\n\t */\r\n\tprotected _currentStep: number = 0;\r\n\r\n\t/**\r\n\t * If set to non-zero value, the PatternSet will start iterating patterns from\r\n\t * that particular index, not the first pattern in the list.\r\n\t */\r\n\tprotected _startIndex: number = 0;\r\n\r\n\t/**\r\n\t * Current pass in cycle. Once all patterns in the list are iterated,\r\n\t * iteration restarts from beginning and currentPass is incremented.\r\n\t */\r\n\tprotected _currentPass: number = 0;\r\n\r\n\t/**\r\n\t * A base color. If there are no colors pre-set in the color list, ColorSet\r\n\t * will use this color as a base when generating new ones, applying\r\n\t * `stepOptions` and `passOptions` to this base color.\r\n\t */\r\n\tpublic baseColor: Color = new Color({\r\n\t\tr: 103,\r\n\t\tg: 183,\r\n\t\tb: 220\r\n\t});\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"PatternSet\";\r\n\r\n\t\t// Set base color to be used for pattern elements\r\n\t\tconst interfaceColors = new InterfaceColorSet();\r\n\r\n\t\t// Set default patterns\r\n\t\tthis.list = [\r\n\t\t\tthis.getLinePattern(1000, 45, 1, 6),\r\n\t\t\tthis.getRectPattern(10, 0, 4),\r\n\t\t\tthis.getLinePattern(1000, -45, 1, 6),\r\n\t\t\tthis.getCirclePattern(11, 2, true),\r\n\t\t\tthis.getLinePattern(6, 90, 1),\r\n\t\t\tthis.getRectPattern(12, 45, 6, true),\r\n\t\t\tthis.getLinePattern(6, 0, 1),\r\n\t\t\tthis.getRectPattern(7, 0, 4),\r\n\t\t\tthis.getLinePattern(1000, 45, 2, 3, \"4,2\"),\r\n\t\t\tthis.getCirclePattern(9, 3, false),\r\n\t\t\tthis.getLinePattern(1000, -45, 2, 3, \"4,2\"),\r\n\t\t\tthis.getRectPattern(10, 45, Math.sqrt(50)),\r\n\t\t\tthis.getLinePattern(1000, -45, 2, 1),\r\n\t\t\tthis.getRectPattern(10, 0, 9),\r\n\t\t\tthis.getLinePattern(1000, 45, 2, 1),\r\n\t\t\tthis.getLinePattern(1000, 0, 3, 1),\r\n\t\t\tthis.getRectPattern(10, 45, 10),\r\n\t\t\tthis.getLinePattern(1000, 90, 3, 1)\r\n\t\t];\r\n\r\n\t\tthis.baseColor = interfaceColors.getFor(\"stroke\");\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\tpublic getLinePattern(size: number, rotation: number, thickness: number, gap?: number, strokeDashArray?: string): LinePattern {\r\n\t\tlet pattern = new LinePattern();\r\n\t\tpattern.width = size;\r\n\t\tpattern.height = size;\r\n\t\tpattern.stroke = this.baseColor;\r\n\t\tpattern.gap = gap;\r\n\t\tpattern.strokeDasharray = strokeDashArray;\r\n\t\tpattern.strokeWidth = thickness;\r\n\t\tpattern.rotation = rotation;\r\n\t\treturn pattern;\r\n\t}\r\n\r\n\tpublic getRectPattern(size: number, rotation: number, thickness: number, outline?:boolean): RectPattern {\r\n\t\tlet pattern = new RectPattern();\r\n\t\tpattern.width = size;\r\n\t\tpattern.height = size;\r\n\t\tpattern.rectWidth = thickness;\r\n\t\tpattern.rectHeight = thickness;\r\n\r\n\t\tif(outline){\r\n\t\t\tpattern.stroke = this.baseColor;\r\n\t\t\tpattern.strokeWidth = 1;\r\n\t\t\tpattern.fillOpacity = 0;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tpattern.fill = this.baseColor;\r\n\t\t\tpattern.strokeWidth = 0;\r\n\t\t}\r\n\r\n\t\tif(rotation != 0){\r\n\t\t\tpattern.shapeRendering = \"auto\";\r\n\t\t}\r\n\r\n\t\tpattern.rotation = rotation;\r\n\t\treturn pattern;\r\n\t}\r\n\r\n\tpublic getCirclePattern(size: number, radius: number, outline:boolean): CirclePattern {\r\n\t\tlet pattern = new CirclePattern();\r\n\t\tpattern.width = size;\r\n\t\tpattern.height = size;\r\n\t\tpattern.shapeRendering = \"auto\";\r\n\t\tpattern.radius = radius;\r\n\t\tif(outline){\r\n\t\t\tpattern.stroke = this.baseColor;\r\n\t\t\tpattern.strokeWidth = 1;\r\n\t\t\tpattern.fillOpacity = 0;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tpattern.fill = this.baseColor;\r\n\t\t\tpattern.strokeWidth = 0;\r\n\t\t}\r\n\t\treturn pattern;\r\n\t}\r\n\r\n\t/**\r\n\t * List of pre-defined patterns to be used in set.\r\n\t *\r\n\t * @param value Pattern list\r\n\t */\r\n\tpublic set list(value: Pattern[]) {\r\n\t\tthis._list = value;\r\n\t\tthis.reset();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Pattern list\r\n\t */\r\n\tpublic get list(): Pattern[] {\r\n\t\treturn this._list;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the next pattern in list.\r\n\t *\r\n\t * @return Pattern\r\n\t */\r\n\tpublic next(): Pattern {\r\n\t\tconst pattern = this.getIndex(this.currentStep);\r\n\t\tthis._currentStep++;\r\n\t\treturn pattern;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a color at specific index in the list.\r\n\t *\r\n\t * @param  i  Index\r\n\t * @return Pattern\r\n\t */\r\n\tpublic getIndex(i: number): Pattern {\r\n\t\tlet pattern;\r\n\t\twhile (this.list.length <= i) {\r\n\t\t\tthis.generatePatterns();\r\n\t\t}\r\n\t\tpattern = this.list[i];\r\n\t\treturn pattern.clone();\r\n\t}\r\n\r\n\t/**\r\n\t * Generates a new set of patterns.\r\n\t */\r\n\tprivate generatePatterns(): void {\r\n\t\tconst count = this.list.length / (this._currentPass + 1);\r\n\t\tthis._currentPass++;\r\n\t\tfor (let i = 0; i < count; i++) {\r\n\t\t\tthis.list.push(this.list[i].clone());\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Resets internal iterator.\r\n\t *\r\n\t * Calling `next()` after this will return the very first color in the color\r\n\t * list, even if it was already returned before.\r\n\t */\r\n\tpublic reset(): void {\r\n\t\tthis._currentStep = this._startIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets current color iteration. You can use this property to skip some\r\n\t * colors from iteration. E.g. setting it to `10` will skip first ten\r\n\t * colors.\r\n\t *\r\n\t * Please note that the number is zero-based.\r\n\t *\r\n\t * @param value  Step\r\n\t */\r\n\tpublic set currentStep(value: number) {\r\n\t\tthis._currentStep = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Step\r\n\t */\r\n\tpublic get currentStep(): number {\r\n\t\treturn this._currentStep;\r\n\t}\r\n\r\n\t/**\r\n\t * If set to non-zero value, the ColorSet will start iterating colors from\r\n\t * that particular index, not the first color in the list.\r\n\t *\r\n\t * @default 0\r\n\t * @param  value  Index\r\n\t */\r\n\tpublic set startIndex(value: number) {\r\n\t\tthis._startIndex = value;\r\n\t\tthis.reset();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Index\r\n\t */\r\n\tpublic get startIndex(): number {\r\n\t\treturn this._startIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON-based config before it is applied to the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param config  Config\r\n\t */\r\n\tpublic processConfig(config?: { [index: string]: any }): void {\r\n\r\n\t\t// if (config) {\r\n\r\n\t\t// \t// Set up axis ranges\r\n\t\t// \tif ($type.hasValue(config.list) && $type.isArray(config.list)) {\r\n\t\t// \t\tfor (let i = 0, len = config.list.length; i < len; i++) {\r\n\t\t// \t\t\tif (!(config.list[i] instanceof Color)) {\r\n\t\t// \t\t\t\tconfig.list[i] = color(config.list[i]);\r\n\t\t// \t\t\t}\r\n\t\t// \t\t}\r\n\t\t// \t}\r\n\t\t// }\r\n\t\tsuper.processConfig(config);\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"PatternSet\"] = PatternSet;"],"sourceRoot":""},"metadata":{},"sourceType":"module"}