{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Dictionary } from \"./utils/Dictionary\";\nimport { TargetedEventDispatcher } from \"./utils/EventDispatcher\";\nimport { MultiDisposer, CounterDisposer } from \"./utils/Disposer\";\nimport * as $utils from \"./utils/Utils\";\nimport * as $object from \"./utils/Object\";\n/**\r\n * An [[EventDispatcher]] for [[Sprite]].\r\n *\r\n * @important\r\n */\n\nvar SpriteEventDispatcher =\n/** @class */\nfunction (_super) {\n  __extends(SpriteEventDispatcher, _super);\n\n  function SpriteEventDispatcher() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * [_interactionEvents description]\r\n     *\r\n     * @todo Description\r\n     */\n\n\n    _this._interactionEvents = new Dictionary();\n    return _this;\n  }\n  /**\r\n   * [_dispatchSpriteEvent description]\r\n   *\r\n   * @todo Description\r\n   */\n\n\n  SpriteEventDispatcher.prototype._dispatchSpriteEvent = function (ev) {\n    if (this.target.disabled || this.target.isTemplate) {\n      return;\n    } // TODO remove this <any> later\n\n\n    if (this.target.events.isEnabled(ev.type)) {\n      var imev = $object.merge(ev, {\n        target: this.target\n      });\n      this.target.events.dispatchImmediately(imev.type, imev);\n    }\n  };\n  /**\r\n   * [_dispatchSpritePointEvent description]\r\n   *\r\n   * @todo Description\r\n   */\n\n\n  SpriteEventDispatcher.prototype._dispatchSpritePointEvent = function (ev) {\n    if (this.target.disabled || this.target.isTemplate) {\n      return;\n    } // TODO remove this <any> later\n\n\n    if (this.target.events.isEnabled(ev.type)) {\n      var imev = $object.merge(ev, {\n        target: this.target,\n        spritePoint: $utils.documentPointToSprite(ev.point, this.target),\n        svgPoint: this.target.getSvgPoint(ev.point)\n      });\n      this.target.events.dispatchImmediately(imev.type, imev);\n    }\n  };\n  /**\r\n   * [_addInteractionObjectEvent description]\r\n   *\r\n   * @todo Description\r\n   */\n\n\n  SpriteEventDispatcher.prototype._addInteractionObjectEvent = function (type, callback, context, shouldClone) {\n    var _this = this;\n\n    var key = shouldClone + \"-\" + type;\n\n    var counter = this._interactionEvents.insertKeyIfEmpty(key, function () {\n      var disposer = _this.target.interactions.events.on(type, callback, context, shouldClone);\n\n      return new CounterDisposer(function () {\n        _this._interactionEvents.removeKey(key);\n\n        disposer.dispose();\n      });\n    });\n\n    return counter.increment();\n  };\n  /**\r\n   * [_on description]\r\n   *\r\n   * @todo Description\r\n   */\n\n\n  SpriteEventDispatcher.prototype._on = function (once, type, callback, context, shouldClone, dispatch) {\n    var info = _super.prototype._on.call(this, once, type, callback, context, shouldClone, dispatch);\n\n    var disposers = [info.disposer];\n    /**\r\n     * Catching Sprite-related events, converting them to [[SpriteEvent]] and\r\n     * triggering them on sprite\r\n     */\n\n    switch (type) {\n      case \"hit\":\n      case \"track\":\n      case \"doublehit\":\n      case \"wheel\":\n      case \"wheelup\":\n      case \"wheeldown\":\n      case \"wheelleft\":\n      case \"wheelright\":\n        disposers.push(this._addInteractionObjectEvent(type, this._dispatchSpritePointEvent, this, shouldClone));\n        break;\n\n      case \"rightclick\":\n      case \"down\": //case \"hold\":\n\n      case \"up\":\n      case \"drag\":\n      case \"dragged\":\n      case \"dragstart\":\n      case \"dragstop\":\n      case \"over\":\n      case \"out\":\n      case \"swipe\":\n      case \"swipeleft\":\n      case \"swiperight\":\n      case \"resize\": //case \"rotate\":\n\n      case \"focus\":\n      case \"blur\":\n      case \"toggled\":\n        disposers.push(this._addInteractionObjectEvent(type, this._dispatchSpriteEvent, this, shouldClone));\n        break;\n    }\n    /**\r\n     * Set functional properties based on events. For example if we add a\r\n     * \"drag\" event handler, we want to make the Sprite draggable, even if we\r\n     * don't explicitly set \"draggable\"\r\n     */\n\n\n    switch (type) {\n      case \"hit\":\n      case \"doublehit\":\n      case \"rightclick\":\n      case \"down\":\n      case \"up\":\n        this.target.clickable = true;\n        break;\n\n      case \"toggled\":\n        this.target.togglable = true;\n        break;\n\n      case \"drag\":\n      case \"dragstart\":\n      case \"dragstop\":\n        this.target.draggable = true;\n        break;\n\n      case \"track\":\n        this.target.trackable = true;\n        break;\n\n      case \"resize\":\n        this.target.resizable = true;\n        break;\n\n      case \"swipe\":\n      case \"swipeleft\":\n      case \"swiperight\":\n        this.target.swipeable = true;\n        break;\n\n      case \"wheel\":\n      case \"wheelup\":\n      case \"wheeldown\":\n      case \"wheelleft\":\n      case \"wheelright\":\n        this.target.wheelable = true;\n        break;\n\n      case \"over\":\n        this.target.hoverable = true;\n\n      case \"out\":\n        this.target.hoverable = true;\n        break;\n\n      case \"focus\":\n      case \"blur\":\n        this.target.focusable = true;\n        break;\n    }\n\n    info.disposer = new MultiDisposer(disposers);\n    return info;\n  };\n\n  return SpriteEventDispatcher;\n}(TargetedEventDispatcher);\n\nexport { SpriteEventDispatcher };","map":{"version":3,"sources":["../../../../src/.internal/core/SpriteEvents.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Sprite } from \"./Sprite\";\r\nimport { Dictionary } from \"./utils/Dictionary\";\r\nimport { EventListener, TargetedEventDispatcher, AMEvent } from \"./utils/EventDispatcher\";\r\nimport { InteractionObject, IInteractionObjectEvents } from \"./interaction/InteractionObject\";\r\nimport { IPointer } from \"./interaction/Pointer\";\r\nimport { MultiDisposer, IDisposer, CounterDisposer } from \"./utils/Disposer\";\r\nimport { IPoint } from \"./defs/IPoint\";\r\nimport * as $utils from \"./utils/Utils\";\r\nimport * as $object from \"./utils/Object\";\r\n\r\n/**\r\n * ============================================================================\r\n * RE-EXPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nexport { AMEvent };\r\n\r\n/**\r\n * An [[EventDispatcher]] for [[Sprite]].\r\n *\r\n * @important\r\n */\r\nexport class SpriteEventDispatcher<T extends AMEvent<Sprite, ISpriteEvents>> extends TargetedEventDispatcher<Sprite, T> {\r\n\r\n\t/**\r\n\t * [_interactionEvents description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprivate _interactionEvents = new Dictionary<string, CounterDisposer>();\r\n\r\n\t/**\r\n\t * [_dispatchSpriteEvent description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprivate _dispatchSpriteEvent<Key extends keyof IInteractionObjectEvents>(ev: AMEvent<InteractionObject, IInteractionObjectEvents>[Key]): void {\r\n\t\tif (this.target.disabled || this.target.isTemplate) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// TODO remove this <any> later\r\n\t\tif (this.target.events.isEnabled(ev.type)) {\r\n\t\t\tlet imev: AMEvent<Sprite, ISpriteEvents>[Key] = <any>$object.merge(ev, {\r\n\t\t\t\ttarget: this.target\r\n\t\t\t});\r\n\t\t\tthis.target.events.dispatchImmediately(imev.type, imev);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [_dispatchSpritePointEvent description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprivate _dispatchSpritePointEvent<Key extends \"hit\" | \"track\">(ev: AMEvent<InteractionObject, IInteractionObjectEvents>[Key]): void {\r\n\t\tif (this.target.disabled || this.target.isTemplate) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// TODO remove this <any> later\r\n\t\tif (this.target.events.isEnabled(ev.type)) {\r\n\r\n\t\t\tlet imev: AMEvent<Sprite, ISpriteEvents>[Key] = <any>$object.merge(ev, {\r\n\t\t\t\ttarget: this.target,\r\n\t\t\t\tspritePoint: $utils.documentPointToSprite(ev.point, this.target),\r\n\t\t\t\tsvgPoint: this.target.getSvgPoint(ev.point)\r\n\t\t\t});\r\n\t\t\tthis.target.events.dispatchImmediately(imev.type, imev);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [_addInteractionObjectEvent description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprivate _addInteractionObjectEvent<C, Key extends keyof IInteractionObjectEvents>(type: Key, callback: (this: C, ev: AMEvent<InteractionObject, IInteractionObjectEvents>[Key]) => void, context: C, shouldClone: boolean): IDisposer {\r\n\t\tconst key = shouldClone + \"-\" + type;\r\n\r\n\t\tconst counter = this._interactionEvents.insertKeyIfEmpty(key, () => {\r\n\t\t\tconst disposer = this.target.interactions.events.on(type, callback, context, shouldClone);\r\n\r\n\t\t\treturn new CounterDisposer(() => {\r\n\t\t\t\tthis._interactionEvents.removeKey(key);\r\n\t\t\t\tdisposer.dispose();\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\treturn counter.increment();\r\n\t}\r\n\r\n\t/**\r\n\t * [_on description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _on<A, B, Key extends keyof T>(once: boolean, type: Key | null, callback: A, context: B, shouldClone: boolean, dispatch: (type: Key, event: T[Key]) => void): EventListener<T> {\r\n\t\tconst info = super._on(once, type, callback, context, shouldClone, dispatch);\r\n\r\n\t\tconst disposers = [info.disposer];\r\n\r\n\t\t/**\r\n\t\t * Catching Sprite-related events, converting them to [[SpriteEvent]] and\r\n\t\t * triggering them on sprite\r\n\t\t */\r\n\t\tswitch (type) {\r\n\t\t\tcase \"hit\":\r\n\t\t\tcase \"track\":\r\n\t\t\tcase \"doublehit\":\r\n\t\t\tcase \"wheel\":\r\n\t\t\tcase \"wheelup\":\r\n\t\t\tcase \"wheeldown\":\r\n\t\t\tcase \"wheelleft\":\r\n\t\t\tcase \"wheelright\":\r\n\t\t\t\tdisposers.push(this._addInteractionObjectEvent(<any>type, this._dispatchSpritePointEvent, this, shouldClone));\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"rightclick\":\r\n\t\t\tcase \"down\":\r\n\t\t\t//case \"hold\":\r\n\t\t\tcase \"up\":\r\n\t\t\tcase \"drag\":\r\n\t\t\tcase \"dragged\":\r\n\t\t\tcase \"dragstart\":\r\n\t\t\tcase \"dragstop\":\r\n\t\t\tcase \"over\":\r\n\t\t\tcase \"out\":\r\n\t\t\tcase \"swipe\":\r\n\t\t\tcase \"swipeleft\":\r\n\t\t\tcase \"swiperight\":\r\n\t\t\tcase \"resize\":\r\n\t\t\t//case \"rotate\":\r\n\t\t\tcase \"focus\":\r\n\t\t\tcase \"blur\":\r\n\t\t\tcase \"toggled\":\r\n\t\t\t\tdisposers.push(this._addInteractionObjectEvent(<any>type, this._dispatchSpriteEvent, this, shouldClone));\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Set functional properties based on events. For example if we add a\r\n\t\t * \"drag\" event handler, we want to make the Sprite draggable, even if we\r\n\t\t * don't explicitly set \"draggable\"\r\n\t\t */\r\n\t\tswitch (type) {\r\n\t\t\tcase \"hit\":\r\n\t\t\tcase \"doublehit\":\r\n\t\t\tcase \"rightclick\":\r\n\t\t\tcase \"down\":\r\n\t\t\tcase \"up\":\r\n\t\t\t\tthis.target.clickable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"toggled\":\r\n\t\t\t\tthis.target.togglable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"drag\":\r\n\t\t\tcase \"dragstart\":\r\n\t\t\tcase \"dragstop\":\r\n\t\t\t\tthis.target.draggable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"track\":\r\n\t\t\t\tthis.target.trackable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"resize\":\r\n\t\t\t\tthis.target.resizable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"swipe\":\r\n\t\t\tcase \"swipeleft\":\r\n\t\t\tcase \"swiperight\":\r\n\t\t\t\tthis.target.swipeable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"wheel\":\r\n\t\t\tcase \"wheelup\":\r\n\t\t\tcase \"wheeldown\":\r\n\t\t\tcase \"wheelleft\":\r\n\t\t\tcase \"wheelright\":\r\n\t\t\t\tthis.target.wheelable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"over\":\r\n\t\t\t\tthis.target.hoverable = true;\r\n\t\t\tcase \"out\":\r\n\t\t\t\tthis.target.hoverable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"focus\":\r\n\t\t\tcase \"blur\":\r\n\t\t\t\tthis.target.focusable = true;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tinfo.disposer = new MultiDisposer(disposers);\r\n\r\n\t\treturn info;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Defines a type of event that has a single point of reference.\r\n */\r\nexport type SpritePointerTypeEvent = {\r\n\r\n\t/**\r\n\t * Is event originated by touch pointer?\r\n\t */\r\n\ttouch: boolean;\r\n\r\n};\r\n\r\n/**\r\n * Defines property set for a [[Sprite]] event that contains point information.\r\n */\r\nexport type SpritePointEvent = {\r\n\t/**\r\n\t * Event point in global (document) coordinates.\r\n\t */\r\n\tpoint: IPoint;\r\n\r\n\t/**\r\n\t * Event point in local Sprite coordinates.\r\n\t */\r\n\tspritePoint: IPoint;\r\n\r\n\t/**\r\n\t * Event point with chart (svg) coodinates.\r\n\t */\r\n\tsvgPoint: IPoint;\r\n};\r\n\r\n\r\n/**\r\n * Defines a type of event that has a related Pointer.\r\n */\r\nexport type SpritePointerEvent = {\r\n\r\n\t/**\r\n\t * Coordinates of the primary cursor position.\r\n\t */\r\n\tpointer: IPointer;\r\n\r\n};\r\n\r\n\r\n/**\r\n * Defines property set for a [[Sprite]] event that contains mouse or touch\r\n * event.\r\n */\r\nexport type SpriteMouseTouchEvent = {\r\n\r\n\t/**\r\n\t * Original mouse/touch event.\r\n\t */\r\n\tevent: MouseEvent | TouchEvent;\r\n\r\n};\r\n\r\n/**\r\n * Defines property set for a [[Sprite]] event that contains coordinate shift\r\n * information, such as drag events.\r\n */\r\nexport type SpriteShiftEvent = {\r\n\r\n\t/**\r\n\t * Shift in coordinates after dragging.\r\n\t */\r\n\tshift: IPoint;\r\n\r\n};\r\n\r\n/**\r\n * Defines available events available for [[Sprite]].\r\n */\r\nexport interface ISpriteEvents extends IInteractionObjectEvents {\r\n\r\n\t/**\r\n\t * Invoked when Sprite completes transition to a [[SpriteState]].\r\n\t */\r\n\ttransitionended: {};\r\n\r\n\t/**\r\n\t * Invoked when size of the Sprite changes.\r\n\t */\r\n\tsizechanged: {};\r\n\r\n\t/**\r\n\t * Invoked when maximum available size of the Sprite changes, i.e. when the\r\n\t * size of parent container changes.\r\n\t */\r\n\tmaxsizechanged: {\r\n\t\tpreviousWidth: number,\r\n\t\tpreviousHeight: number\r\n\t};\r\n\r\n\t/**\r\n\t * @todo Description\r\n\t */\r\n\ttransformed: {\r\n\r\n\t\t/**\r\n\t\t * [string description]\r\n\t\t * @todo Needs description\r\n\t\t */\r\n\t\tdummyData?: string;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when position of the [[Sprite]] changes.\r\n\t */\r\n\tpositionchanged: {};\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] is initialized.\r\n\t */\r\n\tinited: {};\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] appears. Sprite appears when `sprite.appear()` method\r\n\t * is called and show animation is finished.\r\n\t */\r\n\tappeared: {};\r\n\r\n\t/**\r\n\t * Invoked when chart is shown if `am4core.options.queue = true` or/and `am4core.options.onlyShowOnViewport = true`.\r\n\t */\r\n\tremovedfromqueue: {};\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] is becomes ready, that is it has finished all\r\n\t * calculations and building itself.\r\n\t *\r\n\t * For [[Container]] object (and all those inheriting it, including charts)\r\n\t * this event will fire when all children become ready.\r\n\t */\r\n\tready: {};\r\n\r\n\t/**\r\n\t * Invoked before [[Sprite]] is validated.\r\n\t *\r\n\t * @todo Description (check)\r\n\t */\r\n\tbeforevalidated: {};\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] is validated. (on init or after update)\r\n\t *\r\n\t * @todo Description (check)\r\n\t */\r\n\tvalidated: {};\r\n\r\n\t/**\r\n\t * Invoked when visibility of the [[Sprite]] changes. (from visible to hidden,\r\n\t * and vice versa)\r\n\t */\r\n\tvisibilitychanged: {\r\n\t\tvisible: boolean;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when hidden [[Sprite]] is shown.\r\n\t */\r\n\tshown: {};\r\n\r\n\t/**\r\n\t * Invoked when visible [[Sprite]] is hidden.\r\n\t */\r\n\thidden: {};\r\n\r\n\t/**\r\n\t * Invoked when zIndex of a sprite is changed\r\n\t */\r\n\tzIndexChanged: {};\r\n\r\n\t/**\r\n\t * Invoked when property of the [[Sprite]] changes.\r\n\t */\r\n\tpropertychanged: {\r\n\r\n\t\t/**\r\n\t\t * Property key.\r\n\t\t */\r\n\t\tproperty: string;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when the global scale changed, meaning that scale of [[Sprite]]\r\n\t * or any of its ascendants changed.\r\n\t */\r\n\tglobalscalechanged: {};\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] is clicked or touched.\r\n\t */\r\n\thit: SpritePointerTypeEvent & SpritePointEvent & SpriteMouseTouchEvent;\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] is clicked or touched twice in rapid succession.\r\n\t */\r\n\tdoublehit: SpritePointerTypeEvent & SpritePointEvent & SpriteMouseTouchEvent;\r\n\r\n\t/**\r\n\t * Invoked when pointer (mouse cursor or touch point) moves over `trackable`\r\n\t * [[Sprite]].\r\n\t */\r\n\ttrack:  SpritePointerTypeEvent & SpritePointEvent & SpritePointerEvent & SpriteMouseTouchEvent;\r\n\r\n\t/**\r\n\t * Invoked when user turns mouse wheel while over the [[Sprite]].\r\n\t */\r\n\twheel: SpritePointEvent & SpriteShiftEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original JavaScript event.\r\n\t\t */\r\n\t\tevent: WheelEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when user turns mouse wheel upwards while over the [[Sprite]].\r\n\t */\r\n\twheelup: SpritePointEvent & SpriteShiftEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original JavaScript event\r\n\t\t */\r\n\t\tevent: WheelEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when user turns mouse wheel downwards while over the [[Sprite]].\r\n\t */\r\n\twheeldown: SpritePointEvent & SpriteShiftEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original JavaScript event.\r\n\t\t */\r\n\t\tevent: WheelEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when user turns mouse wheel leftwards while over the [[Sprite]].\r\n\t */\r\n\twheelleft: SpritePointEvent & SpriteShiftEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original JavaScript event\r\n\t\t */\r\n\t\tevent: WheelEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when user turns mouse wheel rightwards while over the [[Sprite]].\r\n\t */\r\n\twheelright: SpritePointEvent & SpriteShiftEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original JavaScript event.\r\n\t\t */\r\n\t\tevent: WheelEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when `togglable` Sprite is being toggled on and off. (its\r\n\t * `isActive` property is being changed)\r\n\t */\r\n\ttoggled: {};\r\n\r\n\t/**\r\n\t * Invoked just before Sprite is disposed.\r\n\t */\r\n\tbeforedisposed: {};\r\n\r\n\t/**\r\n\t * Invoked when sprite is disabled\r\n\t */\r\n\tdisabled: {};\r\n\r\n\t/**\r\n\t * Invoked when sprite is enabled\r\n\t */\r\n\tenabled: {};\r\n\r\n\t/**\r\n\t * Invoked when `draggable` object is being dragged. (using mouse, touch or\r\n\t * keyboard).\r\n\t *\r\n\t * This is simmilar but different then `\"drag\"` event in that it kicks in\r\n\t * after `\"drag\"` which modifies [[Sprite]] coordinates. This allows doing\r\n\t * own manipulations and corrections to element positions.\r\n\t */\r\n\tdragged: SpritePointerTypeEvent & SpriteShiftEvent & SpritePointEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original coordinates of the pointer's position when the dragging started.\r\n\t\t */\r\n\t\tstartPoint: IPoint,\r\n\r\n\t\t/**\r\n\t\t * An original JavaScript event that triggered dragging.\r\n\t\t */\r\n\t\tevent?: MouseEvent | TouchEvent | KeyboardEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when a sprite is added to a parent\r\n\t */\r\n\tparentset: {};\r\n\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}