{"ast":null,"code":"/**\r\n * Radar series module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { LineSeries, LineSeriesDataItem } from \"./LineSeries\";\nimport { registry } from \"../../core/Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $path from \"../../core/rendering/Path\"; //import { AxisRendererCircular } from \"../axes/AxisRendererCircular\";\n//import { Sprite } from \"../../core/Sprite\";\n\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[RadarSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar RadarSeriesDataItem =\n/** @class */\nfunction (_super) {\n  __extends(RadarSeriesDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function RadarSeriesDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"RadarSeriesDataItem\";\n\n    _this.setLocation(\"dateX\", 0, 0);\n\n    _this.setLocation(\"dateY\", 0, 0);\n\n    _this.setLocation(\"categoryX\", 0, 0);\n\n    _this.setLocation(\"categoryY\", 0, 0);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  return RadarSeriesDataItem;\n}(LineSeriesDataItem);\n\nexport { RadarSeriesDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines [[Series]] for a radar graph.\r\n *\r\n * @see {@link IRadarSeriesEvents} for a list of available Events\r\n * @see {@link IRadarSeriesAdapters} for a list of available Adapters\r\n * @todo Example\r\n * @important\r\n */\n\nvar RadarSeries =\n/** @class */\nfunction (_super) {\n  __extends(RadarSeries, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function RadarSeries() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"RadarSeries\";\n    _this.connectEnds = true;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * (Re)validates the whole series, effectively causing it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  RadarSeries.prototype.validate = function () {\n    // so that radius would be updated\n    if (this.chart.invalid) {\n      this.chart.validate();\n    }\n\n    _super.prototype.validate.call(this);\n  };\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  RadarSeries.prototype.createDataItem = function () {\n    return new RadarSeriesDataItem();\n  };\n  /**\r\n   * Returns an [[IPoint]] coordinates of the specific Serie's data point.\r\n   *\r\n   * @param    dataItem   Data item\r\n   * @param    xKey       Name of X data field\r\n   * @param    yKey       Name of Y data field\r\n   * @param    locationX  X location\r\n   * @param    locationY  Y location\r\n   * @param    stackKeyX  ?\r\n   * @param    stackKeyY  ?\r\n   * @returns             Coordinates\r\n   */\n\n\n  RadarSeries.prototype.getPoint = function (dataItem, xKey, yKey, locationX, locationY, stackKeyX, stackKeyY) {\n    if (!stackKeyX) {\n      stackKeyX = \"valueX\";\n    }\n\n    if (!stackKeyY) {\n      stackKeyY = \"valueY\";\n    }\n\n    var x = this.yAxis.getX(dataItem, yKey, locationY, stackKeyY);\n    var y = this.yAxis.getY(dataItem, yKey, locationY, stackKeyY);\n    var radius = $math.getDistance({\n      x: x,\n      y: y\n    }); // hack to be able to determine angle later\n\n    if (radius == 0) {\n      radius = 0.00001;\n    }\n\n    var angle = this.xAxis.getAngle(dataItem, xKey, locationX, stackKeyX);\n    var startAngle = this.chart.startAngle;\n    var endAngle = this.chart.endAngle; //\t\tangle = $math.fitToRange(angle, startAngle, endAngle);\n\n    if (angle < startAngle || angle > endAngle) {\n      return undefined;\n    } else {\n      return {\n        x: radius * $math.cos(angle),\n        y: radius * $math.sin(angle)\n      };\n    }\n  };\n  /**\r\n   * [addPoints description]\r\n   *\r\n   * @todo Description\r\n   * @param points    [description]\r\n   * @param dataItem  [description]\r\n   * @param xField    [description]\r\n   * @param yField    [description]\r\n   * @param backwards [description]\r\n   */\n\n\n  RadarSeries.prototype.addPoints = function (points, dataItem, xField, yField, backwards) {\n    var point = this.getPoint(dataItem, xField, yField, dataItem.locations[xField], dataItem.locations[yField]);\n\n    if (point) {\n      points.push(point);\n    }\n  };\n  /**\r\n   * Returns an SVG path to be used as a mask for the series.\r\n   *\r\n   * @return SVG path\r\n   */\n\n\n  RadarSeries.prototype.getMaskPath = function () {\n    var renderer = this.yAxis.renderer;\n    return $path.arc(renderer.startAngle, renderer.endAngle - renderer.startAngle, renderer.pixelRadius, renderer.pixelInnerRadius);\n  };\n  /**\r\n   * [drawSegment description]\r\n   *\r\n   * @todo Description\r\n   * @param segment      [description]\r\n   * @param points       [description]\r\n   * @param closePoints  [description]\r\n   */\n\n\n  RadarSeries.prototype.drawSegment = function (segment, points, closePoints) {\n    var axis = this.yAxis;\n    var renderer = axis.renderer;\n\n    if (this.connectEnds && Math.abs(renderer.endAngle - renderer.startAngle) == 360) {\n      // adds one point to the beginning of closePoints array, if needed\n      if (this.dataFields[this._xOpenField] || this.dataFields[this._yOpenField] || this.stacked) {\n        points.push(points[0]);\n\n        if (closePoints.length > 0) {\n          closePoints.unshift(closePoints[closePoints.length - 1]);\n        }\n      }\n    }\n\n    _super.prototype.drawSegment.call(this, segment, points, closePoints);\n  };\n\n  Object.defineProperty(RadarSeries.prototype, \"connectEnds\", {\n    /**\r\n     * @return Connect?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"connectEnds\");\n    },\n\n    /**\r\n     * Should the last and and first data points be connected, forming a complete\r\n     * closed circle?\r\n     *\r\n     * @default true\r\n     * @param value  Connect?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"connectEnds\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  RadarSeries.prototype.positionBulletReal = function (bullet, positionX, positionY) {\n    var xAxis = this.xAxis;\n    var yAxis = this.yAxis;\n\n    if (positionX < xAxis.start || positionX > xAxis.end || positionY < yAxis.start || positionY > yAxis.end) {\n      bullet.visible = false;\n    }\n\n    bullet.moveTo(this.xAxis.renderer.positionToPoint(positionX, positionY));\n  };\n\n  RadarSeries.prototype.setXAxis = function (axis) {\n    _super.prototype.setXAxis.call(this, axis);\n\n    this.updateRendererRefs();\n  };\n\n  RadarSeries.prototype.setYAxis = function (axis) {\n    _super.prototype.setYAxis.call(this, axis);\n\n    this.updateRendererRefs();\n  };\n\n  RadarSeries.prototype.updateRendererRefs = function () {\n    var rendererX = this.xAxis.renderer;\n    var rendererY = this.yAxis.renderer;\n    rendererX.axisRendererY = rendererY;\n  };\n\n  return RadarSeries;\n}(LineSeries);\n\nexport { RadarSeries };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"RadarSeries\"] = RadarSeries;\nregistry.registeredClasses[\"RadarSeriesDataItem\"] = RadarSeriesDataItem;","map":{"version":3,"sources":["../../../../../src/.internal/charts/series/RadarSeries.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Radar series module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { LineSeries, LineSeriesDataItem, ILineSeriesDataFields, ILineSeriesProperties, ILineSeriesAdapters, ILineSeriesEvents } from \"./LineSeries\";\r\nimport { LineSeriesSegment } from \"./LineSeriesSegment\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { AxisRendererRadial } from \"../axes/AxisRendererRadial\";\r\nimport { AxisRendererCircular } from \"../axes/AxisRendererCircular\";\r\nimport { Axis } from \"../axes/Axis\";\r\nimport { RadarChart } from \"../types/RadarChart\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { Sprite } from \"../../core/Sprite\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\n//import { AxisRendererCircular } from \"../axes/AxisRendererCircular\";\r\n//import { Sprite } from \"../../core/Sprite\";\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[RadarSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class RadarSeriesDataItem extends LineSeriesDataItem {\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: RadarSeries;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"RadarSeriesDataItem\";\r\n\r\n\t\tthis.setLocation(\"dateX\", 0, 0);\r\n\t\tthis.setLocation(\"dateY\", 0, 0);\r\n\r\n\t\tthis.setLocation(\"categoryX\", 0, 0);\r\n\t\tthis.setLocation(\"categoryY\", 0, 0);\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[RadarSeries]].\r\n */\r\nexport interface IRadarSeriesDataFields extends ILineSeriesDataFields { }\r\n\r\n/**\r\n * Defines properties for [[RadarSeries]].\r\n */\r\nexport interface IRadarSeriesProperties extends ILineSeriesProperties {\r\n\r\n\t/**\r\n\t * Should the last and and first data points be connected, forming a complete\r\n\t * closed circle?\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tconnectEnds?: boolean;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[RadarSeries]].\r\n */\r\nexport interface IRadarSeriesEvents extends ILineSeriesEvents { }\r\n\r\n/**\r\n * Defines adapters for [[RadarSeries]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IRadarSeriesAdapters extends ILineSeriesAdapters, IRadarSeriesProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines [[Series]] for a radar graph.\r\n *\r\n * @see {@link IRadarSeriesEvents} for a list of available Events\r\n * @see {@link IRadarSeriesAdapters} for a list of available Adapters\r\n * @todo Example\r\n * @important\r\n */\r\nexport class RadarSeries extends LineSeries {\r\n\r\n\t/**\r\n\t * Defines the type of data fields used for the series.\r\n\t */\r\n\tpublic _dataFields: IRadarSeriesDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IRadarSeriesProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IRadarSeriesAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IRadarSeriesEvents;\r\n\r\n\t/**\r\n\t * Defines the type of data item.\r\n\t */\r\n\tpublic _dataItem: RadarSeriesDataItem;\r\n\r\n\t/**\r\n\t * A chart series belongs to.\r\n\t */\r\n\tpublic _chart: RadarChart;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"RadarSeries\";\r\n\t\tthis.connectEnds = true;\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates the whole series, effectively causing it to redraw.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate(): void {\r\n\r\n\t\t// so that radius would be updated\r\n\t\tif (this.chart.invalid) {\r\n\t\t\tthis.chart.validate();\r\n\t\t}\r\n\r\n\t\tsuper.validate();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty DataItem of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new RadarSeriesDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an [[IPoint]] coordinates of the specific Serie's data point.\r\n\t *\r\n\t * @param    dataItem   Data item\r\n\t * @param    xKey       Name of X data field\r\n\t * @param    yKey       Name of Y data field\r\n\t * @param    locationX  X location\r\n\t * @param    locationY  Y location\r\n\t * @param    stackKeyX  ?\r\n\t * @param    stackKeyY  ?\r\n\t * @returns             Coordinates\r\n\t */\r\n\tpublic getPoint(dataItem: RadarSeriesDataItem, xKey: string, yKey: string, locationX?: number, locationY?: number, stackKeyX?: string, stackKeyY?: string) {\r\n\t\tif (!stackKeyX) {\r\n\t\t\tstackKeyX = \"valueX\";\r\n\t\t}\r\n\t\tif (!stackKeyY) {\r\n\t\t\tstackKeyY = \"valueY\";\r\n\t\t}\r\n\r\n\t\tlet x: number = this.yAxis.getX(dataItem, yKey, locationY, stackKeyY);\r\n\t\tlet y: number = this.yAxis.getY(dataItem, yKey, locationY, stackKeyY);\r\n\r\n\t\tlet radius: number = $math.getDistance({ x: x, y: y });\r\n\r\n\t\t// hack to be able to determine angle later\r\n\t\tif (radius == 0) {\r\n\t\t\tradius = 0.00001;\r\n\t\t}\r\n\r\n\t\tlet angle: number = this.xAxis.getAngle(dataItem, xKey, locationX, stackKeyX);\r\n\r\n\t\tlet startAngle = this.chart.startAngle;\r\n\t\tlet endAngle = this.chart.endAngle;\r\n\r\n\t\t//\t\tangle = $math.fitToRange(angle, startAngle, endAngle);\r\n\t\tif (angle < startAngle || angle > endAngle) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn { x: radius * $math.cos(angle), y: radius * $math.sin(angle) };\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * [addPoints description]\r\n\t *\r\n\t * @todo Description\r\n\t * @param points    [description]\r\n\t * @param dataItem  [description]\r\n\t * @param xField    [description]\r\n\t * @param yField    [description]\r\n\t * @param backwards [description]\r\n\t */\r\n\tprotected addPoints(points: IPoint[], dataItem: this[\"_dataItem\"], xField: string, yField: string, backwards?: boolean): void {\r\n\t\tlet point = this.getPoint(dataItem, xField, yField, dataItem.locations[xField], dataItem.locations[yField]);\r\n\t\tif (point) {\r\n\t\t\tpoints.push(point);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an SVG path to be used as a mask for the series.\r\n\t *\r\n\t * @return SVG path\r\n\t */\r\n\tprotected getMaskPath(): string {\r\n\t\tlet renderer: AxisRendererRadial = <AxisRendererRadial>this.yAxis.renderer;\r\n\t\treturn $path.arc(renderer.startAngle, renderer.endAngle - renderer.startAngle, renderer.pixelRadius, renderer.pixelInnerRadius);\r\n\t}\r\n\r\n\t/**\r\n\t * [drawSegment description]\r\n\t *\r\n\t * @todo Description\r\n\t * @param segment      [description]\r\n\t * @param points       [description]\r\n\t * @param closePoints  [description]\r\n\t */\r\n\tprotected drawSegment(segment: LineSeriesSegment, points: IPoint[], closePoints: IPoint[]): void {\r\n\t\tlet axis: Axis = this.yAxis;\r\n\t\tlet renderer: AxisRendererRadial = <AxisRendererRadial>axis.renderer;\r\n\r\n\t\tif (this.connectEnds && Math.abs(renderer.endAngle - renderer.startAngle) == 360) {\r\n\t\t\t// adds one point to the beginning of closePoints array, if needed\r\n\t\t\tif (this.dataFields[<keyof this[\"_dataFields\"]>this._xOpenField] ||\r\n\t\t\t\tthis.dataFields[<keyof this[\"_dataFields\"]>this._yOpenField] ||\r\n\t\t\t\tthis.stacked) {\r\n\t\t\t\tpoints.push(points[0]);\r\n\t\t\t\tif (closePoints.length > 0) {\r\n\t\t\t\t\tclosePoints.unshift(closePoints[closePoints.length - 1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsuper.drawSegment(segment, points, closePoints);\r\n\t}\r\n\r\n\t/**\r\n\t * Should the last and and first data points be connected, forming a complete\r\n\t * closed circle?\r\n\t *\r\n\t * @default true\r\n\t * @param value  Connect?\r\n\t */\r\n\tpublic set connectEnds(value: boolean) {\r\n\t\tthis.setPropertyValue(\"connectEnds\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Connect?\r\n\t */\r\n\tpublic get connectEnds(): boolean {\r\n\t\treturn this.getPropertyValue(\"connectEnds\");\r\n\t}\r\n\r\n\tprotected positionBulletReal(bullet:Sprite, positionX:number, positionY:number){\r\n\t\tlet xAxis = this.xAxis;\r\n\t\tlet yAxis = this.yAxis;\r\n\r\n\t\tif(positionX < xAxis.start || positionX > xAxis.end || positionY < yAxis.start || positionY > yAxis.end){\r\n\t\t\tbullet.visible = false;\r\n\t\t}\r\n\t\t\r\n\t\tbullet.moveTo(this.xAxis.renderer.positionToPoint(positionX, positionY));\t\t\r\n\t}\r\n\r\n\r\n\tprotected setXAxis(axis: Axis) {\r\n\t\tsuper.setXAxis(axis);\r\n\t\tthis.updateRendererRefs();\r\n\t}\r\n\r\n\tprotected setYAxis(axis: Axis) {\r\n\t\tsuper.setYAxis(axis);\r\n\t\tthis.updateRendererRefs();\r\n\t}\r\n\r\n\tprotected updateRendererRefs() {\r\n\t\tlet rendererX = <AxisRendererCircular>this.xAxis.renderer;\r\n\t\tlet rendererY = <AxisRendererRadial>this.yAxis.renderer;\r\n\r\n\t\trendererX.axisRendererY = rendererY;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"RadarSeries\"] = RadarSeries;\r\nregistry.registeredClasses[\"RadarSeriesDataItem\"] = RadarSeriesDataItem;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}