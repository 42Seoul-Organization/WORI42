{"ast":null,"code":"/**\r\n * Data parser module.\r\n */\n\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { DateFormatter } from \"../formatters/DateFormatter\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Base class for the data parsers.\r\n */\n\nvar DataParser =\n/** @class */\nfunction () {\n  function DataParser() {}\n  /**\r\n   * A \"placeholder\" function for real parsers to override.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param data  Source data\r\n   * @return Parsed data (empty)\r\n   */\n\n\n  DataParser.prototype.parse = function (data) {\n    return [];\n  };\n\n  ;\n  Object.defineProperty(DataParser.prototype, \"parsableNumbers\", {\n    /**\r\n     * Checks if there are any numeric fields that need to be converted to\r\n     * numbers.\r\n     *\r\n     * @return Numeric fields?\r\n     */\n    get: function get() {\n      return this.options.numberFields && this.options.numberFields.length > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts a value to 'number' if it is in `numberFields`.\r\n   *\r\n   * @param field  Field name\r\n   * @param value  Value\r\n   * @return Parsed or original value\r\n   */\n\n  DataParser.prototype.maybeToNumber = function (field, value) {\n    if (this.options.numberFields.indexOf(field) !== -1) {\n      return $utils.anyToNumber(value);\n    }\n\n    return value;\n  };\n\n  Object.defineProperty(DataParser.prototype, \"parsableDates\", {\n    /**\r\n     * Checks if there are any date fields that need to be converted to `Date`\r\n     * objects.\r\n     *\r\n     * @return Date fields?\r\n     */\n    get: function get() {\n      return this.options.dateFields && this.options.dateFields.length > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts a value to `Date` if it is in `dateFields`.\r\n   *\r\n   * @param field  Field name\r\n   * @param value  Value\r\n   * @return Parsed or original value\r\n   */\n\n  DataParser.prototype.maybeToDate = function (field, value) {\n    if (this.options.dateFields.indexOf(field) !== -1) {\n      return this.options.dateFormatter.parse(value, this.dateFormat);\n    }\n\n    return value;\n  };\n  /**\r\n   * Replaces empty value with something else.\r\n   *\r\n   * @param value  Source value\r\n   * @return Source value or replacement\r\n   */\n\n\n  DataParser.prototype.maybeToEmpty = function (value) {\n    if ((!$type.hasValue(value) || value == \"\") && $type.hasValue(this.options.emptyAs)) {\n      return this.options.emptyAs;\n    }\n\n    return value;\n  };\n\n  Object.defineProperty(DataParser.prototype, \"dateFormatter\", {\n    /**\r\n     * [[DateFormatter]] object for date parsing.\r\n     *\r\n     * If there was not [[DateFormatter]] supplied in parser options, a new one\r\n     * is created.\r\n     *\r\n     * @return Date formatter\r\n     * @see {@link DateFormatter}\r\n     */\n    get: function get() {\n      if (!this.options.dateFormatter) {\n        this.options.dateFormatter = new DateFormatter();\n\n        if (this.options.dateFormat) {\n          this.options.dateFormat = this.options.dateFormat;\n        }\n      }\n\n      return this.options.dateFormatter;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataParser.prototype, \"dateFormat\", {\n    /**\r\n     * A date format to use when parsing dates.\r\n     *\r\n     * @return Date format\r\n     * @see {@link DateFormatter}\r\n     */\n    get: function get() {\n      return this.options.dateFormat || this.dateFormatter.inputDateFormat;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DataParser;\n}();\n\nexport { DataParser };","map":{"version":3,"sources":["../../../../../src/.internal/core/data/DataParser.ts"],"names":[],"mappings":"AAAA;;;;AAKA;;;;;;AAMA,SAAS,aAAT,QAA8B,6BAA9B;AACA,OAAO,KAAK,MAAZ,MAAwB,gBAAxB;AACA,OAAO,KAAK,KAAZ,MAAuB,eAAvB;AAuDA;;;;;;;AAOA;;;;AAGA,IAAA,UAAA;AAAA;AAAA,YAAA;AAAA,WAAA,UAAA,GAAA,CAmHC;AArGA;;;;;;;;;AAOO,EAAA,UAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,IAAb,EAAyB;AACxB,WAAO,EAAP;AACA,GAFM;;AAEN;AAQD,EAAA,MAAA,CAAA,cAAA,CAAc,UAAA,CAAA,SAAd,EAAc,iBAAd,EAA6B;AAN7B;;;;;;SAMA,eAAA;AACC,aAAO,KAAK,OAAL,CAAa,YAAb,IAA8B,KAAK,OAAL,CAAa,YAAb,CAA0B,MAA1B,GAAmC,CAAxE;AACA,KAF4B;oBAAA;;AAAA,GAA7B;AAIA;;;;;;;;AAOU,EAAA,UAAA,CAAA,SAAA,CAAA,aAAA,GAAV,UAAwB,KAAxB,EAAuC,KAAvC,EAAiD;AAChD,QAAI,KAAK,OAAL,CAAa,YAAb,CAA0B,OAA1B,CAAkC,KAAlC,MAA6C,CAAC,CAAlD,EAAqD;AACpD,aAAO,MAAM,CAAC,WAAP,CAAmB,KAAnB,CAAP;AACA;;AACD,WAAO,KAAP;AACA,GALS;;AAaV,EAAA,MAAA,CAAA,cAAA,CAAc,UAAA,CAAA,SAAd,EAAc,eAAd,EAA2B;AAN3B;;;;;;SAMA,eAAA;AACC,aAAO,KAAK,OAAL,CAAa,UAAb,IAA4B,KAAK,OAAL,CAAa,UAAb,CAAwB,MAAxB,GAAiC,CAApE;AACA,KAF0B;oBAAA;;AAAA,GAA3B;AAIA;;;;;;;;AAOU,EAAA,UAAA,CAAA,SAAA,CAAA,WAAA,GAAV,UAAsB,KAAtB,EAAqC,KAArC,EAA+C;AAC9C,QAAI,KAAK,OAAL,CAAa,UAAb,CAAwB,OAAxB,CAAgC,KAAhC,MAA2C,CAAC,CAAhD,EAAmD;AAClD,aAAO,KAAK,OAAL,CAAa,aAAb,CAA2B,KAA3B,CAAiC,KAAjC,EAAwC,KAAK,UAA7C,CAAP;AACA;;AACD,WAAO,KAAP;AACA,GALS;AAOV;;;;;;;;AAMU,EAAA,UAAA,CAAA,SAAA,CAAA,YAAA,GAAV,UAAuB,KAAvB,EAAiC;AAChC,QAAI,CAAC,CAAC,KAAK,CAAC,QAAN,CAAe,KAAf,CAAD,IAA0B,KAAK,IAAI,EAApC,KAA2C,KAAK,CAAC,QAAN,CAAe,KAAK,OAAL,CAAa,OAA5B,CAA/C,EAAqF;AACpF,aAAO,KAAK,OAAL,CAAa,OAApB;AACA;;AACD,WAAO,KAAP;AACA,GALS;;AAgBV,EAAA,MAAA,CAAA,cAAA,CAAc,UAAA,CAAA,SAAd,EAAc,eAAd,EAA2B;AAT3B;;;;;;;;;SASA,eAAA;AACC,UAAI,CAAC,KAAK,OAAL,CAAa,aAAlB,EAAiC;AAChC,aAAK,OAAL,CAAa,aAAb,GAA6B,IAAI,aAAJ,EAA7B;;AACA,YAAI,KAAK,OAAL,CAAa,UAAjB,EAA6B;AAC5B,eAAK,OAAL,CAAa,UAAb,GAA0B,KAAK,OAAL,CAAa,UAAvC;AACA;AACD;;AACD,aAAO,KAAK,OAAL,CAAa,aAApB;AACA,KAR0B;oBAAA;;AAAA,GAA3B;AAgBA,EAAA,MAAA,CAAA,cAAA,CAAc,UAAA,CAAA,SAAd,EAAc,YAAd,EAAwB;AANxB;;;;;;SAMA,eAAA;AACC,aAAO,KAAK,OAAL,CAAa,UAAb,IAA2B,KAAK,aAAL,CAAmB,eAArD;AACA,KAFuB;oBAAA;;AAAA,GAAxB;AAID,SAAA,UAAA;AAAC,CAnHD,EAAA","sourcesContent":["/**\r\n * Data parser module.\r\n */\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { DateFormatter } from \"../formatters/DateFormatter\";\r\nimport * as $utils from \"../utils/Utils\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines common options for all data parsers.\r\n */\r\nexport interface IDataParserOptions {\r\n\r\n\t/**\r\n\t * Empty values (e.g. empty strings, `null`, etc.) will be replaced with\r\n\t * this.\r\n\t */\r\n\temptyAs?: any;\r\n\r\n\t/**\r\n\t * List of fields in data that hold numeric values. Parser will try to\r\n\t * convert the value in those fields to a `number`.\r\n\t */\r\n\tnumberFields?: string[];\r\n\r\n\t/**\r\n\t * List of fields in data that need to be treated as Dates, i.e. converted\r\n\t * to `Date` objects from whatever source format they are currently in.\r\n\t */\r\n\tdateFields?: string[];\r\n\r\n\t/**\r\n\t * An instance of [[DateFormatter]] to use when parsing string-based dates.\r\n\t * If it's not set, the parser will create it's own instance of\r\n\t * [[DateFormatter]], should any date parsing required. (`dateFields` is set)\r\n\t *\r\n\t * Unless `dateFormat` is set in parser options, the parser will try to look\r\n\t * for `dateFormat` in `dateFormatter`.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/#Parsing_Dates} Tutorial on date parsing\r\n\t */\r\n\tdateFormatter?: DateFormatter;\r\n\r\n\t/**\r\n\t * Override date format set in `dateFormatter`.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/#Parsing_Dates} Tutorial on date parsing\r\n\t */\r\n\tdateFormat?: string;\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Base class for the data parsers.\r\n */\r\nexport class DataParser {\r\n\r\n\t/**\r\n\t * Content type, relevant to the specific format.\r\n\t */\r\n\tpublic contentType: string;\r\n\r\n\t/**\r\n\t * Parser options.\r\n\t *\r\n\t * @see {@link IDataParserOptions} for description of each option\r\n\t */\r\n\tpublic options: IDataParserOptions;\r\n\r\n\t/**\r\n\t * A \"placeholder\" function for real parsers to override.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param data  Source data\r\n\t * @return Parsed data (empty)\r\n\t */\r\n\tpublic parse(data: string): any {\r\n\t\treturn [];\r\n\t};\r\n\r\n\t/**\r\n\t * Checks if there are any numeric fields that need to be converted to\r\n\t * numbers.\r\n\t *\r\n\t * @return Numeric fields?\r\n\t */\r\n\tprotected get parsableNumbers(): boolean {\r\n\t\treturn this.options.numberFields && (this.options.numberFields.length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a value to 'number' if it is in `numberFields`.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @param value  Value\r\n\t * @return Parsed or original value\r\n\t */\r\n\tprotected maybeToNumber(field: string, value: any): any {\r\n\t\tif (this.options.numberFields.indexOf(field) !== -1) {\r\n\t\t\treturn $utils.anyToNumber(value);\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if there are any date fields that need to be converted to `Date`\r\n\t * objects.\r\n\t *\r\n\t * @return Date fields?\r\n\t */\r\n\tprotected get parsableDates(): boolean {\r\n\t\treturn this.options.dateFields && (this.options.dateFields.length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a value to `Date` if it is in `dateFields`.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @param value  Value\r\n\t * @return Parsed or original value\r\n\t */\r\n\tprotected maybeToDate(field: string, value: any): any {\r\n\t\tif (this.options.dateFields.indexOf(field) !== -1) {\r\n\t\t\treturn this.options.dateFormatter.parse(value, this.dateFormat);\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces empty value with something else.\r\n\t *\r\n\t * @param value  Source value\r\n\t * @return Source value or replacement\r\n\t */\r\n\tprotected maybeToEmpty(value: any): any {\r\n\t\tif ((!$type.hasValue(value) || value == \"\") && $type.hasValue(this.options.emptyAs)) {\r\n\t\t\treturn this.options.emptyAs;\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * [[DateFormatter]] object for date parsing.\r\n\t *\r\n\t * If there was not [[DateFormatter]] supplied in parser options, a new one\r\n\t * is created.\r\n\t *\r\n\t * @return Date formatter\r\n\t * @see {@link DateFormatter}\r\n\t */\r\n\tprotected get dateFormatter(): DateFormatter {\r\n\t\tif (!this.options.dateFormatter) {\r\n\t\t\tthis.options.dateFormatter = new DateFormatter;\r\n\t\t\tif (this.options.dateFormat) {\r\n\t\t\t\tthis.options.dateFormat = this.options.dateFormat;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.options.dateFormatter;\r\n\t}\r\n\r\n\t/**\r\n\t * A date format to use when parsing dates.\r\n\t *\r\n\t * @return Date format\r\n\t * @see {@link DateFormatter}\r\n\t */\r\n\tprotected get dateFormat(): string {\r\n\t\treturn this.options.dateFormat || this.dateFormatter.inputDateFormat;\r\n\t}\r\n\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}