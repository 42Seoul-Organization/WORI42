{"ast":null,"code":"/**\r\n * 3D slice module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Slice } from \"../Slice\";\nimport { Sprite } from \"../../Sprite\";\nimport * as $math from \"../../utils/Math\";\nimport * as $path from \"../../rendering/Path\";\nimport * as $type from \"../../utils/Type\";\nimport { Color, color } from \"../../utils/Color\";\nimport { RadialGradient } from \"../../rendering/fills/RadialGradient\";\nimport { LinearGradient } from \"../../rendering/fills/LinearGradient\";\nimport { LightenFilter } from \"../../rendering/filters/LightenFilter\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Used to draw a 3D slice of a Pie chart.\r\n *\r\n * @see {@link ISlice3DEvents} for a list of available events\r\n * @see {@link ISlice3DAdapters} for a list of available Adapters\r\n */\n\nvar Slice3D =\n/** @class */\nfunction (_super) {\n  __extends(Slice3D, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Slice3D() {\n    var _this = // Init\n    _super.call(this) || this;\n\n    _this.className = \"Slice3D\";\n    _this.layout = \"none\"; // Create edge container\n\n    var edge = _this.createChild(Sprite);\n\n    _this.edge = edge;\n    edge.shouldClone = false;\n    edge.isMeasured = false;\n    edge.toBack(); // Set defaults\n\n    _this.angle = 30;\n    _this.depth = 20; // Create side A element\n\n    var sideA = _this.createChild(Sprite);\n\n    _this.sideA = sideA;\n    sideA.shouldClone = false;\n    sideA.isMeasured = false; //sideA.setElement(this.paper.add(\"path\"));\n    //sideA.strokeOpacity = 0;\n    // Crate side B element\n\n    var sideB = _this.createChild(Sprite);\n\n    _this.sideB = sideB;\n    sideB.shouldClone = false;\n    sideB.isMeasured = false; //sideB.setElement(this.paper.add(\"path\"));\n    //sideB.strokeOpacity = 0;\n    // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Sets actual `fill` property on the SVG element, including applicable color\r\n   * modifiers.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param value  Fill\r\n   */\n\n\n  Slice3D.prototype.setFill = function (value) {\n    _super.prototype.setFill.call(this, value);\n\n    var colorStr;\n\n    if (value instanceof Color) {\n      colorStr = value.hex;\n    } else if (value instanceof LinearGradient || value instanceof RadialGradient) {\n      colorStr = value.stops.getIndex(0).color.hex;\n    } else {\n      var filter = new LightenFilter();\n      filter.lightness = -0.25;\n      this.edge.filters.push(filter);\n      this.sideA.filters.push(filter.clone());\n      this.sideB.filters.push(filter.clone());\n    }\n\n    if (colorStr) {\n      var edgeFill = color(colorStr).lighten(-0.25);\n      this.edge.fill = edgeFill;\n      this.sideA.fill = edgeFill;\n      this.sideB.fill = edgeFill;\n      this.edge.stroke = edgeFill;\n      this.sideA.stroke = edgeFill;\n      this.sideB.stroke = edgeFill;\n    }\n  };\n  /**\r\n   * Draws the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Slice3D.prototype.draw = function () {\n    this.cornerRadius = 0;\n    this.innerCornerRadius = 0;\n\n    _super.prototype.draw.call(this);\n\n    if (this.arc !== 0 && this.radius > 0 && this.depth > 0) {\n      this.sideB.show(0);\n      this.sideA.show(0);\n      this.edge.show(0);\n      var startAngle = this.startAngle;\n      var arc = this.arc;\n      var innerRadius = this.pixelInnerRadius || 0;\n      var radiusY = this.radiusY || 0; //let cornerRadius = this.cornerRadius || 0;\n      //let innerCornerRadius = this.innerCornerRadius;\n\n      var radius = this.radius; // this is code duplicate with $path.arc. @todo to think how to avoid it\n\n      var endAngle = startAngle + arc; //let crSin = $math.sin($math.min(arc, 45) / 2);\n      //innerCornerRadius = innerCornerRadius || cornerRadius;\n\n      var innerRadiusY = radiusY / radius * innerRadius; //let cornerRadiusY = (radiusY / radius) * cornerRadius;\n      //let innerCornerRadiusY = (radiusY / radius) * innerCornerRadius;\n      //cornerRadius = $math.fitToRange(cornerRadius, 0, (radius - innerRadius) / 2);\n      //cornerRadiusY = $math.fitToRange(cornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\n      //innerCornerRadius = $math.fitToRange(innerCornerRadius, 0, (radius - innerRadius) / 2);\n      //innerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\n      //cornerRadius = $math.fitToRange(cornerRadius, 0, radius * crSin);\n      //cornerRadiusY = $math.fitToRange(cornerRadiusY, 0, radiusY * crSin);\n      //innerCornerRadius = $math.fitToRange(innerCornerRadius, 0, innerRadius * crSin);\n      //innerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, innerRadiusY * crSin);\n      //let crAngle: number = Math.asin(cornerRadius / radius / 2) * $math.DEGREES * 2;\n      //let crAngleY: number = Math.asin(cornerRadiusY / radiusY / 2) * $math.DEGREES * 2;\n      //if (innerRadius < innerCornerRadius) {\n      //\tinnerRadius = innerCornerRadius;\n      //}\n      //if (innerRadiusY < innerCornerRadiusY) {\n      //\tinnerRadiusY = innerCornerRadiusY;\n      //}\n      //let crInnerAngle: number = Math.asin(innerCornerRadius / innerRadius / 2) * $math.DEGREES * 2;\n      //let crInnerAngleY: number = Math.asin(innerCornerRadiusY / innerRadiusY / 2) * $math.DEGREES * 2;\n      //if (!$type.isNumber(crInnerAngle)) {\n      //\tcrInnerAngle = 0;\n      //}\n      //if (!$type.isNumber(crInnerAngleY)) {\n      //\tcrInnerAngleY = 0;\n      //}\n      //let middleAngle = startAngle + arc / 2;\n      //let mPoint = { x: $math.round($math.cos(middleAngle) * innerRadius, 4), y: $math.round($math.sin(middleAngle) * innerRadiusY, 4) };\n\n      var a0 = {\n        x: $math.cos(startAngle) * innerRadius,\n        y: $math.sin(startAngle) * innerRadiusY\n      };\n      var b0 = {\n        x: $math.cos(startAngle) * radius,\n        y: $math.sin(startAngle) * radiusY\n      };\n      var c0 = {\n        x: $math.cos(endAngle) * radius,\n        y: $math.sin(endAngle) * radiusY\n      };\n      var d0 = {\n        x: $math.cos(endAngle) * innerRadius,\n        y: $math.sin(endAngle) * innerRadiusY\n      }; // end of duplicate\n\n      var h = this.depth;\n      var ah = {\n        x: a0.x,\n        y: a0.y - h\n      };\n      var bh = {\n        x: b0.x,\n        y: b0.y - h\n      };\n      var ch = {\n        x: c0.x,\n        y: c0.y - h\n      };\n      var dh = {\n        x: d0.x,\n        y: d0.y - h\n      };\n      var edgePath = \"\";\n      var count = Math.ceil(arc / 5);\n      var step = arc / count;\n      var mangle = startAngle;\n      var prevPoint = bh;\n\n      for (var i = 0; i < count; i++) {\n        mangle += step;\n\n        if (mangle > 0 && mangle < 180) {\n          edgePath += $path.moveTo(prevPoint);\n          var pp = {\n            x: $math.cos(mangle) * radius,\n            y: $math.sin(mangle) * radiusY - h\n          };\n          edgePath += $path.lineTo({\n            x: prevPoint.x,\n            y: prevPoint.y + h\n          });\n          edgePath += $path.arcToPoint({\n            x: pp.x,\n            y: pp.y + h\n          }, radius, radiusY, true);\n          edgePath += $path.lineTo(pp);\n          edgePath += $path.arcToPoint(prevPoint, radius, radiusY);\n          edgePath += \"z\";\n          prevPoint = pp;\n        } else {\n          edgePath += $path.moveTo(prevPoint);\n          var pp = {\n            x: $math.cos(mangle) * radius,\n            y: $math.sin(mangle) * radiusY - h\n          };\n          edgePath += $path.arcToPoint(pp, radius, radiusY, true);\n          edgePath += $path.lineTo({\n            x: pp.x,\n            y: pp.y + h\n          });\n          edgePath += $path.arcToPoint({\n            x: prevPoint.x,\n            y: prevPoint.y + h\n          }, radius, radiusY);\n          edgePath += $path.lineTo(prevPoint);\n          edgePath += \"z\";\n          prevPoint = pp;\n        }\n      }\n\n      prevPoint = ah;\n      mangle = startAngle;\n\n      for (var i = 0; i < count; i++) {\n        mangle += step;\n\n        if (mangle > 0 && mangle < 180) {\n          edgePath += $path.moveTo(prevPoint);\n          var pp = {\n            x: $math.cos(mangle) * innerRadius,\n            y: $math.sin(mangle) * innerRadiusY - h\n          };\n          edgePath += $path.lineTo({\n            x: prevPoint.x,\n            y: prevPoint.y + h\n          });\n          edgePath += $path.arcToPoint({\n            x: pp.x,\n            y: pp.y + h\n          }, innerRadius, innerRadiusY, true);\n          edgePath += $path.lineTo(pp);\n          edgePath += $path.arcToPoint(prevPoint, innerRadius, innerRadiusY);\n          edgePath += \"z\";\n          prevPoint = pp;\n        } else {\n          edgePath += $path.moveTo(prevPoint);\n          var pp = {\n            x: $math.cos(mangle) * innerRadius,\n            y: $math.sin(mangle) * innerRadiusY - h\n          };\n          edgePath += $path.arcToPoint(pp, innerRadius, innerRadiusY, true);\n          edgePath += $path.lineTo({\n            x: pp.x,\n            y: pp.y + h\n          });\n          edgePath += $path.arcToPoint({\n            x: prevPoint.x,\n            y: prevPoint.y + h\n          }, innerRadius, innerRadiusY);\n          edgePath += $path.lineTo(prevPoint);\n          edgePath += \"z\";\n          prevPoint = pp;\n        }\n      }\n\n      this.edge.path = edgePath;\n      /*\r\n                  a0 = { x: $math.cos(startAngle) * (innerRadius + innerCornerRadius), y: $math.sin(startAngle) * (innerRadiusY + innerCornerRadiusY) };\r\n                  b0 = { x: $math.cos(startAngle) * (radius - cornerRadius), y: $math.sin(startAngle) * (radiusY - cornerRadiusY) };\r\n                  c0 = { x: $math.cos(endAngle) * (radius - cornerRadius), y: $math.sin(endAngle) * (radiusY - cornerRadiusY) };\r\n                  d0 = { x: $math.cos(endAngle) * (innerRadius + innerCornerRadius), y: $math.sin(endAngle) * (innerRadiusY + innerCornerRadiusY) };\r\n                  // end of duplicate\r\n      \r\n                  ah = { x: a0.x, y: a0.y - h };\r\n                  bh = { x: b0.x, y: b0.y - h };\r\n                  ch = { x: c0.x, y: c0.y - h };\r\n                  dh = { x: d0.x, y: d0.y - h };\r\n      */\n\n      this.sideA.path = $path.moveTo(a0) + $path.lineTo(b0) + $path.lineTo(bh) + $path.lineTo(ah) + $path.closePath();\n      this.sideB.path = $path.moveTo(c0) + $path.lineTo(d0) + $path.lineTo(dh) + $path.lineTo(ch) + $path.closePath();\n\n      if (this.startAngle < 90) {\n        this.sideA.toBack();\n      } else {\n        this.sideA.toFront();\n      }\n\n      if (this.startAngle + this.arc > 90) {\n        this.sideB.toBack();\n      } else {\n        this.sideB.toFront();\n      }\n\n      this.slice.dy = -h;\n    } else {\n      this.sideA.hide(0);\n      this.sideB.hide(0);\n      this.edge.hide(0);\n    }\n  };\n\n  Object.defineProperty(Slice3D.prototype, \"depth\", {\n    /**\r\n     * @return Depth (px)\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"depth\");\n    },\n\n    /**\r\n     * Depth (height) of the 3D slice in pixels.\r\n     *\r\n     * @default 20\r\n     * @param depth  Depth (px)\r\n     */\n    set: function set(depth) {\n      this.setPropertyValue(\"depth\", depth, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Slice3D.prototype, \"angle\", {\n    /**\r\n     * @return Angle\r\n     */\n    get: function get() {\n      var angle = this.getPropertyValue(\"angle\");\n\n      if (!$type.isNumber(angle)) {\n        angle = 0;\n      }\n\n      return angle;\n    },\n\n    /**\r\n     * Angle of the point of view to the 3D element. (0-360)\r\n     *\r\n     * @default 30\r\n     * @param value  Angle\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"angle\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Slice3D.prototype, \"radiusY\", {\n    /**\r\n     * @return Vertical radius (0-1)\r\n     */\n    get: function get() {\n      var radiusY = this.getPropertyValue(\"radiusY\");\n\n      if (!$type.isNumber(radiusY)) {\n        radiusY = this.radius - this.radius * this.angle / 90;\n      }\n\n      return radiusY;\n    },\n\n    /**\r\n     * Vertical radius for creating skewed slices.\r\n     *\r\n     * This is relevant to `radius`, e.g. 0.5 will set vertical radius to half\r\n     * the `radius`.\r\n     *\r\n     * @param value Vertical radius (0-1)\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"radiusY\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies all properties and related data from a different instance of Axis.\r\n   *\r\n   * @param source Source Axis\r\n   */\n\n  Slice3D.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.edge.copyFrom(source.edge);\n    this.sideA.copyFrom(source.sideA);\n    this.sideB.copyFrom(source.sideB);\n  };\n\n  return Slice3D;\n}(Slice);\n\nexport { Slice3D };","map":{"version":3,"sources":["../../../../../../src/.internal/core/elements/3d/Slice3D.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * 3D slice module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Slice, ISliceProperties, ISliceAdapters, ISliceEvents } from \"../Slice\";\r\nimport { Sprite } from \"../../Sprite\";\r\nimport { IPoint } from \"../../defs/IPoint\";\r\nimport * as $math from \"../../utils/Math\";\r\nimport * as $path from \"../../rendering/Path\";\r\nimport * as $type from \"../../utils/Type\";\r\nimport { Color, color } from \"../../utils/Color\";\r\nimport { RadialGradient } from \"../../rendering/fills/RadialGradient\";\r\nimport { LinearGradient } from \"../../rendering/fills/LinearGradient\";\r\nimport { Pattern } from \"../../rendering/fills/Pattern\";\r\nimport { LightenFilter } from \"../../rendering/filters/LightenFilter\";\r\n\r\n/**\r\n * Defines properties for [[Slice3D]].\r\n */\r\nexport interface ISlice3DProperties extends ISliceProperties {\r\n\r\n\t/**\r\n\t * Depth (height) of the 3D slice in pixels.\r\n\t *\r\n\t * @default 20\r\n\t */\r\n\tdepth?: number;\r\n\r\n\t/**\r\n\t * Angle of the point of view to the 3D element. (0-360)\r\n\t *\r\n\t * @default 30\r\n\t */\r\n\tangle?: number;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[Slice3D]].\r\n */\r\nexport interface ISlice3DEvents extends ISliceEvents { }\r\n\r\n/**\r\n * Defines adapters for [[Slice3D]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface ISlice3DAdapters extends ISliceAdapters, ISlice3DProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to draw a 3D slice of a Pie chart.\r\n *\r\n * @see {@link ISlice3DEvents} for a list of available events\r\n * @see {@link ISlice3DAdapters} for a list of available Adapters\r\n */\r\nexport class Slice3D extends Slice {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: ISlice3DProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ISlice3DAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: ISlice3DEvents;\r\n\r\n\t/**\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic edge: Sprite;\r\n\r\n\t/**\r\n\t * Side element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic sideA: Sprite;\r\n\r\n\t/**\r\n\t * Side element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic sideB: Sprite;\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"Slice3D\";\r\n\t\tthis.layout = \"none\";\r\n\r\n\t\t// Create edge container\r\n\t\tlet edge = this.createChild(Sprite);\r\n\t\tthis.edge = edge;\r\n\t\tedge.shouldClone = false;\r\n\t\tedge.isMeasured = false;\r\n\t\tedge.toBack();\r\n\r\n\t\t// Set defaults\r\n\t\tthis.angle = 30;\r\n\t\tthis.depth = 20;\r\n\r\n\t\t// Create side A element\r\n\t\tlet sideA = this.createChild(Sprite);\r\n\t\tthis.sideA = sideA;\r\n\t\tsideA.shouldClone = false;\r\n\t\tsideA.isMeasured = false;\r\n\t\t//sideA.setElement(this.paper.add(\"path\"));\r\n\t\t//sideA.strokeOpacity = 0;\r\n\r\n\t\t// Crate side B element\r\n\t\tlet sideB = this.createChild(Sprite);\r\n\t\tthis.sideB = sideB;\r\n\t\tsideB.shouldClone = false;\r\n\t\tsideB.isMeasured = false;\r\n\t\t//sideB.setElement(this.paper.add(\"path\"));\r\n\t\t//sideB.strokeOpacity = 0;\r\n\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Sets actual `fill` property on the SVG element, including applicable color\r\n\t * modifiers.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param value  Fill\r\n\t */\r\n\tprotected setFill(value: $type.Optional<Color | Pattern | LinearGradient | RadialGradient>): void {\r\n\t\tsuper.setFill(value);\r\n\r\n\t\tlet colorStr: string;\r\n\t\tif (value instanceof Color) {\r\n\t\t\tcolorStr = value.hex;\r\n\t\t}\r\n\t\telse if (value instanceof LinearGradient || value instanceof RadialGradient) {\r\n\t\t\tcolorStr = value.stops.getIndex(0).color.hex;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet filter = new LightenFilter();\r\n\t\t\tfilter.lightness = -0.25;\r\n\t\t\tthis.edge.filters.push(filter);\r\n\t\t\tthis.sideA.filters.push(filter.clone());\r\n\t\t\tthis.sideB.filters.push(filter.clone());\r\n\t\t}\r\n\r\n\t\tif (colorStr) {\r\n\t\t\tlet edgeFill = color(colorStr).lighten(-0.25);\r\n\r\n\t\t\tthis.edge.fill = edgeFill;\r\n\t\t\tthis.sideA.fill = edgeFill;\r\n\t\t\tthis.sideB.fill = edgeFill;\r\n\r\n\t\t\tthis.edge.stroke = edgeFill;\r\n\t\t\tthis.sideA.stroke = edgeFill;\r\n\t\t\tthis.sideB.stroke = edgeFill;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Draws the element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic draw(): void {\r\n\t\tthis.cornerRadius = 0;\r\n\t\tthis.innerCornerRadius = 0;\r\n\r\n\t\tsuper.draw();\r\n\r\n\t\tif (this.arc !== 0 && this.radius > 0 && this.depth > 0) {\r\n\t\t\tthis.sideB.show(0);\r\n\t\t\tthis.sideA.show(0);\r\n\t\t\tthis.edge.show(0);\r\n\r\n\t\t\tlet startAngle = this.startAngle;\r\n\t\t\tlet arc = this.arc;\r\n\t\t\tlet innerRadius = this.pixelInnerRadius || 0;\r\n\t\t\tlet radiusY = this.radiusY || 0;\r\n\r\n\t\t\t//let cornerRadius = this.cornerRadius || 0;\r\n\t\t\t//let innerCornerRadius = this.innerCornerRadius;\r\n\t\t\tlet radius = this.radius;\r\n\r\n\t\t\t// this is code duplicate with $path.arc. @todo to think how to avoid it\r\n\r\n\t\t\tlet endAngle = startAngle + arc;\r\n\t\t\t//let crSin = $math.sin($math.min(arc, 45) / 2);\r\n\r\n\t\t\t//innerCornerRadius = innerCornerRadius || cornerRadius;\r\n\r\n\t\t\tlet innerRadiusY = (radiusY / radius) * innerRadius;\r\n\t\t\t//let cornerRadiusY = (radiusY / radius) * cornerRadius;\r\n\t\t\t//let innerCornerRadiusY = (radiusY / radius) * innerCornerRadius;\r\n\r\n\t\t\t//cornerRadius = $math.fitToRange(cornerRadius, 0, (radius - innerRadius) / 2);\r\n\t\t\t//cornerRadiusY = $math.fitToRange(cornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\r\n\r\n\t\t\t//innerCornerRadius = $math.fitToRange(innerCornerRadius, 0, (radius - innerRadius) / 2);\r\n\t\t\t//innerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\r\n\r\n\t\t\t//cornerRadius = $math.fitToRange(cornerRadius, 0, radius * crSin);\r\n\t\t\t//cornerRadiusY = $math.fitToRange(cornerRadiusY, 0, radiusY * crSin);\r\n\r\n\t\t\t//innerCornerRadius = $math.fitToRange(innerCornerRadius, 0, innerRadius * crSin);\r\n\t\t\t//innerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, innerRadiusY * crSin);\r\n\r\n\t\t\t//let crAngle: number = Math.asin(cornerRadius / radius / 2) * $math.DEGREES * 2;\r\n\t\t\t//let crAngleY: number = Math.asin(cornerRadiusY / radiusY / 2) * $math.DEGREES * 2;\r\n\r\n\t\t\t//if (innerRadius < innerCornerRadius) {\r\n\t\t\t//\tinnerRadius = innerCornerRadius;\r\n\t\t\t//}\r\n\r\n\t\t\t//if (innerRadiusY < innerCornerRadiusY) {\r\n\t\t\t//\tinnerRadiusY = innerCornerRadiusY;\r\n\t\t\t//}\r\n\r\n\t\t\t//let crInnerAngle: number = Math.asin(innerCornerRadius / innerRadius / 2) * $math.DEGREES * 2;\r\n\t\t\t//let crInnerAngleY: number = Math.asin(innerCornerRadiusY / innerRadiusY / 2) * $math.DEGREES * 2;\r\n\r\n\t\t\t//if (!$type.isNumber(crInnerAngle)) {\r\n\t\t\t//\tcrInnerAngle = 0;\r\n\t\t\t//}\r\n\t\t\t//if (!$type.isNumber(crInnerAngleY)) {\r\n\t\t\t//\tcrInnerAngleY = 0;\r\n\t\t\t//}\r\n\r\n\t\t\t//let middleAngle = startAngle + arc / 2;\r\n\t\t\t//let mPoint = { x: $math.round($math.cos(middleAngle) * innerRadius, 4), y: $math.round($math.sin(middleAngle) * innerRadiusY, 4) };\r\n\r\n\t\t\tlet a0 = { x: $math.cos(startAngle) * (innerRadius), y: $math.sin(startAngle) * (innerRadiusY) };\r\n\t\t\tlet b0 = { x: $math.cos(startAngle) * (radius), y: $math.sin(startAngle) * (radiusY) };\r\n\t\t\tlet c0 = { x: $math.cos(endAngle) * (radius), y: $math.sin(endAngle) * (radiusY) };\r\n\t\t\tlet d0 = { x: $math.cos(endAngle) * (innerRadius), y: $math.sin(endAngle) * (innerRadiusY) };\r\n\t\t\t// end of duplicate\r\n\r\n\t\t\tlet h: number = this.depth;\r\n\t\t\tlet ah: IPoint = { x: a0.x, y: a0.y - h };\r\n\t\t\tlet bh: IPoint = { x: b0.x, y: b0.y - h };\r\n\t\t\tlet ch: IPoint = { x: c0.x, y: c0.y - h };\r\n\t\t\tlet dh: IPoint = { x: d0.x, y: d0.y - h };\r\n\r\n\t\t\tlet edgePath = \"\";\r\n\t\t\tlet count = Math.ceil(arc / 5);\r\n\t\t\tlet step = arc / count;\r\n\t\t\tlet mangle = startAngle;\r\n\r\n\t\t\tlet prevPoint = bh;\r\n\r\n\r\n\t\t\tfor (let i = 0; i < count; i++) {\r\n\t\t\t\tmangle += step;\r\n\t\t\t\tif (mangle > 0 && mangle < 180) {\r\n\t\t\t\t\tedgePath += $path.moveTo(prevPoint);\r\n\t\t\t\t\tlet pp = { x: $math.cos(mangle) * (radius), y: $math.sin(mangle) * (radiusY) - h };\r\n\t\t\t\t\tedgePath += $path.lineTo({ x: prevPoint.x, y: prevPoint.y + h });\r\n\t\t\t\t\tedgePath += $path.arcToPoint({ x: pp.x, y: pp.y + h }, radius, radiusY, true);\r\n\t\t\t\t\tedgePath += $path.lineTo(pp);\r\n\t\t\t\t\tedgePath += $path.arcToPoint(prevPoint, radius, radiusY);\r\n\t\t\t\t\tedgePath += \"z\";\r\n\t\t\t\t\tprevPoint = pp;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tedgePath += $path.moveTo(prevPoint);\r\n\t\t\t\t\tlet pp = { x: $math.cos(mangle) * (radius), y: $math.sin(mangle) * (radiusY) - h };\r\n\t\t\t\t\tedgePath += $path.arcToPoint(pp, radius, radiusY, true);\r\n\t\t\t\t\tedgePath += $path.lineTo({ x: pp.x, y: pp.y + h });\r\n\t\t\t\t\tedgePath += $path.arcToPoint({ x: prevPoint.x, y: prevPoint.y + h }, radius, radiusY);\r\n\t\t\t\t\tedgePath += $path.lineTo(prevPoint);\r\n\t\t\t\t\tedgePath += \"z\";\r\n\t\t\t\t\tprevPoint = pp;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tprevPoint = ah;\r\n\t\t\tmangle = startAngle;\r\n\r\n\r\n\t\t\tfor (let i = 0; i < count; i++) {\r\n\t\t\t\tmangle += step;\r\n\t\t\t\tif (mangle > 0 && mangle < 180) {\r\n\t\t\t\t\tedgePath += $path.moveTo(prevPoint);\r\n\t\t\t\t\tlet pp = { x: $math.cos(mangle) * (innerRadius), y: $math.sin(mangle) * (innerRadiusY) - h };\r\n\t\t\t\t\tedgePath += $path.lineTo({ x: prevPoint.x, y: prevPoint.y + h });\r\n\t\t\t\t\tedgePath += $path.arcToPoint({ x: pp.x, y: pp.y + h }, innerRadius, innerRadiusY, true);\r\n\t\t\t\t\tedgePath += $path.lineTo(pp);\r\n\t\t\t\t\tedgePath += $path.arcToPoint(prevPoint, innerRadius, innerRadiusY);\r\n\t\t\t\t\tedgePath += \"z\";\r\n\t\t\t\t\tprevPoint = pp;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tedgePath += $path.moveTo(prevPoint);\r\n\t\t\t\t\tlet pp = { x: $math.cos(mangle) * (innerRadius), y: $math.sin(mangle) * (innerRadiusY) - h };\r\n\t\t\t\t\tedgePath += $path.arcToPoint(pp, innerRadius, innerRadiusY, true);\r\n\t\t\t\t\tedgePath += $path.lineTo({ x: pp.x, y: pp.y + h });\r\n\t\t\t\t\tedgePath += $path.arcToPoint({ x: prevPoint.x, y: prevPoint.y + h }, innerRadius, innerRadiusY);\r\n\t\t\t\t\tedgePath += $path.lineTo(prevPoint);\r\n\t\t\t\t\tedgePath += \"z\";\r\n\t\t\t\t\tprevPoint = pp;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.edge.path = edgePath;\r\n/*\r\n\t\t\ta0 = { x: $math.cos(startAngle) * (innerRadius + innerCornerRadius), y: $math.sin(startAngle) * (innerRadiusY + innerCornerRadiusY) };\r\n\t\t\tb0 = { x: $math.cos(startAngle) * (radius - cornerRadius), y: $math.sin(startAngle) * (radiusY - cornerRadiusY) };\r\n\t\t\tc0 = { x: $math.cos(endAngle) * (radius - cornerRadius), y: $math.sin(endAngle) * (radiusY - cornerRadiusY) };\r\n\t\t\td0 = { x: $math.cos(endAngle) * (innerRadius + innerCornerRadius), y: $math.sin(endAngle) * (innerRadiusY + innerCornerRadiusY) };\r\n\t\t\t// end of duplicate\r\n\r\n\t\t\tah = { x: a0.x, y: a0.y - h };\r\n\t\t\tbh = { x: b0.x, y: b0.y - h };\r\n\t\t\tch = { x: c0.x, y: c0.y - h };\r\n\t\t\tdh = { x: d0.x, y: d0.y - h };\r\n*/\r\n\t\t\tthis.sideA.path = $path.moveTo(a0) + $path.lineTo(b0) + $path.lineTo(bh) + $path.lineTo(ah) + $path.closePath();\r\n\t\t\tthis.sideB.path = $path.moveTo(c0) + $path.lineTo(d0) + $path.lineTo(dh) + $path.lineTo(ch) + $path.closePath();\r\n\r\n\t\t\tif (this.startAngle < 90) {\r\n\t\t\t\tthis.sideA.toBack();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.sideA.toFront();\r\n\t\t\t}\r\n\r\n\t\t\tif (this.startAngle + this.arc > 90) {\r\n\t\t\t\tthis.sideB.toBack();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.sideB.toFront();\r\n\t\t\t}\r\n\r\n\t\t\tthis.slice.dy = -h;\t\t\t\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.sideA.hide(0);\r\n\t\t\tthis.sideB.hide(0);\r\n\t\t\tthis.edge.hide(0);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Depth (height) of the 3D slice in pixels.\r\n\t *\r\n\t * @default 20\r\n\t * @param depth  Depth (px)\r\n\t */\r\n\tpublic set depth(depth: number) {\r\n\t\tthis.setPropertyValue(\"depth\", depth, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Depth (px)\r\n\t */\r\n\tpublic get depth(): number {\r\n\t\treturn this.getPropertyValue(\"depth\");\r\n\t}\r\n\r\n\t/**\r\n\t * Angle of the point of view to the 3D element. (0-360)\r\n\t *\r\n\t * @default 30\r\n\t * @param value  Angle\r\n\t */\r\n\tpublic set angle(value: number) {\r\n\t\tthis.setPropertyValue(\"angle\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Angle\r\n\t */\r\n\tpublic get angle(): number {\r\n\t\tlet angle: number = this.getPropertyValue(\"angle\");\r\n\t\tif (!$type.isNumber(angle)) {\r\n\t\t\tangle = 0;\r\n\t\t}\r\n\t\treturn angle;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Vertical radius (0-1)\r\n\t */\r\n\tpublic get radiusY(): number {\r\n\t\tlet radiusY: number = this.getPropertyValue(\"radiusY\");\r\n\t\tif (!$type.isNumber(radiusY)) {\r\n\t\t\tradiusY = this.radius - this.radius * this.angle / 90;\r\n\t\t}\r\n\t\treturn radiusY;\r\n\t}\r\n\r\n\t/**\r\n\t * Vertical radius for creating skewed slices.\r\n\t *\r\n\t * This is relevant to `radius`, e.g. 0.5 will set vertical radius to half\r\n\t * the `radius`.\r\n\t *\r\n\t * @param value Vertical radius (0-1)\r\n\t */\r\n\tpublic set radiusY(value: number) {\r\n\t\tthis.setPropertyValue(\"radiusY\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all properties and related data from a different instance of Axis.\r\n\t *\r\n\t * @param source Source Axis\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tsuper.copyFrom(source);\r\n\t\tthis.edge.copyFrom(source.edge);\r\n\t\tthis.sideA.copyFrom(source.sideA);\r\n\t\tthis.sideB.copyFrom(source.sideB);\r\n\t}\r\n\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}