{"version":3,"file":"EventDispatcher.js","sourceRoot":"","sources":["../../../../../src/.internal/core/utils/EventDispatcher.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Event Dispatcher module is used for registering listeners and dispatching\r\n * events across amCharts system.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Disposer, IDisposer } from \"./Disposer\";\r\nimport * as $array from \"./Array\";\r\nimport * as $async from \"./AsyncPending\";\r\nimport * as $type from \"./Type\";\r\n\r\n/**\r\n * Defines a universal type for the event object.\r\n */\r\nexport type AMEvent<Target, T> = {\r\n\t[K in keyof T]: { type: K, target: Target } & T[K];\r\n};\r\n\r\n/**\r\n * A universal interface for event listeners.\r\n */\r\nexport interface EventListener<T> {\r\n\tkilled: boolean;\r\n\tonce: boolean;\r\n\ttype: any;\r\n\tcallback: any;\r\n\tcontext: any;\r\n\tshouldClone: boolean;\r\n\tdispatch: any;\r\n\tdisposer: IDisposer;\r\n}\r\n\r\n/*export interface IEventDispatcher<T> {\r\n\tisDisposed(): boolean;\r\n\tdispose(): void;\r\n\thasListeners(): boolean;\r\n\tenable(): void;\r\n\tdisable(): void;\r\n\tenableType<Key extends keyof T>(type: Key): void;\r\n\tdisableType<Key extends keyof T>(type: Key, amount?: number): void;\r\n\tisEnabled<Key extends keyof T>(type: Key): boolean;\r\n\thas<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean;\r\n\tdispatchImmediately<Key extends keyof T>(type: Key, event: T[Key]): void;\r\n\tdispatch<Key extends keyof T>(type: Key, event: T[Key]): void;\r\n\tonAll<C, Key extends keyof T>(callback: (this: C, type: Key, event: T[Key]) => void, context?: C): IDisposer;\r\n\ton<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;\r\n\tonce<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;\r\n\toff<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;\r\n\toff<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;\r\n\tcopyFrom(source: this): void;\r\n}*/\r\n\r\n/**\r\n * Universal Event Dispatcher.\r\n *\r\n * @important\r\n */\r\nexport class EventDispatcher<T> implements IDisposer {\r\n\r\n\tprotected _listeners: Array<EventListener<T>>;\r\n\tprotected _killed: Array<EventListener<T>>;\r\n\tprotected _disabled: { [key in keyof T]?: number };\r\n\tprotected _iterating: number;\r\n\tprotected _enabled: boolean;\r\n\tprotected _disposed: boolean;\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tthis._listeners = [];\r\n\t\tthis._killed = [];\r\n\t\tthis._disabled = {};\r\n\t\tthis._iterating = 0;\r\n\t\tthis._enabled = true;\r\n\t\tthis._disposed = false;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns if this object has been already disposed.\r\n\t *\r\n\t * @return Disposed?\r\n\t */\r\n\tpublic isDisposed(): boolean {\r\n\t\treturn this._disposed;\r\n\t}\r\n\r\n\t/**\r\n\t * Dispose (destroy) this object.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tif (!this._disposed) {\r\n\t\t\tthis._disposed = true;\r\n\r\n\t\t\tconst a = this._listeners;\r\n\r\n\t\t\tthis._iterating = 1;\r\n\t\t\tthis._listeners = <any>null;\r\n\t\t\tthis._disabled = <any>null;\r\n\r\n\t\t\ttry {\r\n\t\t\t\t$array.each(a, (x) => {\r\n\t\t\t\t\tx.disposer.dispose();\r\n\t\t\t\t});\r\n\r\n\t\t\t} finally {\r\n\t\t\t\tthis._killed = <any>null;\r\n\t\t\t\tthis._iterating = <any>null;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this particular event dispatcher has any listeners set.\r\n\t *\r\n\t * @return Has listeners?\r\n\t */\r\n\tpublic hasListeners(): boolean {\r\n\t\treturn this._listeners.length !== 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this particular event dispatcher has any particular listeners set.\r\n\t *\r\n\t * @return Has particular event listeners?\r\n\t */\r\n\tpublic hasListenersByType<Key extends keyof T>(type: Key): boolean {\r\n\t\treturn $array.any(this._listeners, (x) => (x.type === null || x.type === type) && !x.killed);\r\n\t}\r\n\r\n\t/**\r\n\t * Enable dispatching of events if they were previously disabled by\r\n\t * `disable()`.\r\n\t */\r\n\tpublic enable(): void {\r\n\t\tthis._enabled = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Disable dispatching of events until re-enabled by `enable()`.\r\n\t */\r\n\tpublic disable(): void {\r\n\t\tthis._enabled = false;\r\n\t}\r\n\r\n\t/**\r\n\t * Enable dispatching particular event, if it was disabled before by\r\n\t * `disableType()`.\r\n\t *\r\n\t * @param type Event type\r\n\t */\r\n\tpublic enableType<Key extends keyof T>(type: Key): void {\r\n\t\tdelete this._disabled[type];\r\n\t}\r\n\r\n\t/**\r\n\t * Disable dispatching of events for a certain event type.\r\n\t *\r\n\t * Optionally, can set how many dispatches to skip before automatically\r\n\t * re-enabling the dispatching.\r\n\t *\r\n\t * @param type    Event type\r\n\t * @param amount  Number of event dispatches to skip\r\n\t */\r\n\tpublic disableType<Key extends keyof T>(type: Key, amount: number = Infinity): void {\r\n\t\tthis._disabled[type] = amount;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes listener from dispatcher.\r\n\t *\r\n\t * Will throw an exception if such listener does not exists.\r\n\t *\r\n\t * @param listener Listener to remove\r\n\t */\r\n\tprotected _removeListener(listener: EventListener<T>): void {\r\n\t\tif (this._iterating === 0) {\r\n\t\t\tconst index = this._listeners.indexOf(listener);\r\n\r\n\t\t\tif (index === -1) {\r\n\t\t\t\tthrow new Error(\"Invalid state: could not remove listener\");\r\n\t\t\t}\r\n\r\n\t\t\tthis._listeners.splice(index, 1);\r\n\r\n\t\t} else {\r\n\t\t\tthis._killed.push(listener);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Removes existing listener by certain parameters.\r\n\t *\r\n\t * @param once         Listener's once setting\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t */\r\n\tprotected _removeExistingListener<A, B, Key extends keyof T>(once: boolean, type: Key | null, callback?: A, context?: B): void {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tthis._eachListener((info) => {\r\n\t\t\tif (info.once === once && // TODO is this correct ?\r\n\t\t\t\tinfo.type === type &&\r\n\t\t\t\t(callback == null || info.callback === callback) &&\r\n\t\t\t\tinfo.context === context) {\r\n\t\t\t\tinfo.disposer.dispose();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if dispatching for particular event type is enabled.\r\n\t *\r\n\t * @param type  Event type\r\n\t * @return Enabled?\r\n\t */\r\n\tpublic isEnabled<Key extends keyof T>(type: Key): boolean {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\t// TODO is this check correct ?\r\n\t\treturn this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] == null;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if there's already a listener with specific parameters.\r\n\t *\r\n\t * @param type      Listener's type\r\n\t * @param callback  Callback function\r\n\t * @param context   Callback context\r\n\t * @return Has listener?\r\n\t */\r\n\tpublic has<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean {\r\n\t\tconst index = $array.findIndex(this._listeners, (info) => {\r\n\t\t\treturn info.once !== true && // Ignoring \"once\" listeners\r\n\t\t\t\tinfo.type === type &&\r\n\t\t\t\t(callback == null || info.callback === callback) &&\r\n\t\t\t\tinfo.context === context;\r\n\t\t});\r\n\r\n\t\treturn index !== -1;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether event of the particular type should be dispatched.\r\n\t *\r\n\t * @param type  Event type\r\n\t * @return Dispatch?\r\n\t */\r\n\tprotected _shouldDispatch<Key extends keyof T>(type: Key): boolean {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tconst count = this._disabled[type];\r\n\r\n\t\tif (!$type.isNumber(count)) {\r\n\t\t\treturn this._enabled;\r\n\r\n\t\t} else {\r\n\t\t\tif (count <= 1) {\r\n\t\t\t\tdelete this._disabled[type];\r\n\r\n\t\t\t} else {\r\n\t\t\t\t--this._disabled[type];\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [_eachListener description]\r\n\t *\r\n\t * All of this extra code is needed when a listener is removed while iterating\r\n\t *\r\n\t * @todo Description\r\n\t * @param fn [description]\r\n\t */\r\n\tprotected _eachListener(fn: (listener: EventListener<T>) => void): void {\r\n\t\t++this._iterating;\r\n\r\n\t\ttry {\r\n\t\t\t$array.each(this._listeners, fn);\r\n\r\n\t\t} finally {\r\n\t\t\t--this._iterating;\r\n\r\n\t\t\t// TODO should this be inside or outside the finally ?\r\n\t\t\tif (this._iterating === 0 && this._killed.length !== 0) {\r\n\t\t\t\t// Remove killed listeners\r\n\t\t\t\t$array.each(this._killed, (killed) => {\r\n\t\t\t\t\tthis._removeListener(killed);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis._killed.length = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Dispatches an event immediately without waiting for next cycle.\r\n\t *\r\n\t * @param type   Event type\r\n\t * @param event  Event object\r\n\t * @todo automatically add in type and target properties if they are missing\r\n\t */\r\n\tpublic dispatchImmediately<Key extends keyof T>(type: Key, event: T[Key]): void {\r\n\t\tif (this._shouldDispatch(type)) {\r\n\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\r\n\t\t\t// TODO if the function throws, maybe it should keep going ?\r\n\t\t\tthis._eachListener((listener) => {\r\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\r\n\t\t\t\t\tlistener.dispatch(type, event);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Shelves the event to be dispatched within next update cycle.\r\n\t *\r\n\t * @param type   Event type\r\n\t * @param event  Event object\r\n\t * @todo automatically add in type and target properties if they are missing\r\n\t */\r\n\tpublic dispatch<Key extends keyof T>(type: Key, event: T[Key]): void {\r\n\t\tif (this._shouldDispatch(type)) {\r\n\t\t\tthis._eachListener((listener) => {\r\n\t\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\r\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\r\n\t\t\t\t\t// TODO if the function throws, maybe it should keep going ?\r\n\t\t\t\t\t// TODO dispatch during the update cycle, rather than using whenIdle\r\n\t\t\t\t\t$async.whenIdle(() => {\r\n\t\t\t\t\t\tif (!listener.killed) {\r\n\t\t\t\t\t\t\tlistener.dispatch(type, event);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Creates, catalogs and returns an [[EventListener]].\r\n\t *\r\n\t * Event listener can be disposed.\r\n\t *\r\n\t * @param once         Listener's once setting\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @param dispatch\r\n\t * @returns An event listener\r\n\t */\r\n\tprotected _on<A, B, Key extends keyof T>(once: boolean, type: Key | null, callback: A, context: B, shouldClone: boolean, dispatch: (type: Key, event: T[Key]) => void): EventListener<T> {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tthis._removeExistingListener(once, type, callback, context);\r\n\r\n\t\tconst info: EventListener<T> = {\r\n\t\t\ttype: type,\r\n\t\t\tcallback: callback,\r\n\t\t\tcontext: context,\r\n\t\t\tshouldClone: shouldClone,\r\n\t\t\tdispatch: <any>dispatch,\r\n\t\t\tkilled: false,\r\n\t\t\tonce: once,\r\n\t\t\tdisposer: new Disposer(() => {\r\n\t\t\t\tinfo.killed = true;\r\n\t\t\t\tthis._removeListener(info);\r\n\t\t\t})\r\n\t\t};\r\n\r\n\t\tthis._listeners.push(info);\r\n\r\n\t\treturn info;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an event listener to be invoked on **any** event.\r\n\t *\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @returns A disposable event listener\r\n\t * @todo what if `listen` is called on the same function twice ?\r\n\t */\r\n\tpublic onAll<C, Key extends keyof T>(callback: (this: C, type: Key, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\r\n\t\treturn this._on(false, null, callback, context, shouldClone, (type, event) => callback.call(context, type, event)).disposer;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an event listener to be invoked on a specific event type.\r\n\t *\r\n\t * ```TypeScript\r\n\t * series.events.on(\"hidden\", (ev) => {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * series.events.on(\"hidden\", function(ev) {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"series\": [{\r\n\t *     // ...\r\n\t *     \"events\": {\r\n\t *     \t\"hidden\": function(ev) {\r\n\t *     \t  console.log(\"Series hidden: \" + ev.target.name);\r\n\t *     \t}\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * The above will invoke our custom event handler whenever series we put\r\n\t * event on is hidden.\r\n\t *\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @returns A disposable event listener\r\n\t * @todo what if `listen` is called on the same function twice ?\r\n\t */\r\n\tpublic on<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\r\n\t\treturn this._on(false, type, callback, context, shouldClone, (type, event) => callback.call(context, event)).disposer;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an event listener to be invoked on a specific event type once.\r\n\t *\r\n\t * Once the event listener is invoked, it is automatically disposed.\r\n\t *\r\n\t * ```TypeScript\r\n\t * series.events.on(\"hidden\", (ev) => {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * series.events.on(\"hidden\", function(ev) {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"series\": [{\r\n\t *     // ...\r\n\t *     \"events\": {\r\n\t *     \t\"hidden\": function(ev) {\r\n\t *     \t  console.log(\"Series hidden: \" + ev.target.name);\r\n\t *     \t}\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * The above will invoke our custom event handler the first time series we\r\n\t * put event on is hidden.\r\n\t *\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @returns A disposable event listener\r\n\t * @todo what if `listen` is called on the same function twice ?\r\n\t */\r\n\tpublic once<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\r\n\t\tconst x = this._on(true, type, callback, context, shouldClone, (type, event) => {\r\n\t\t\tx.disposer.dispose();\r\n\t\t\tcallback.call(context, event)\r\n\t\t});\r\n\r\n\t\t// TODO maybe this should return a different Disposer ?\r\n\t\treturn x.disposer;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the event listener with specific parameters.\r\n\t *\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t */\r\n\tpublic off<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): void {\r\n\t\tthis._removeExistingListener(false, type, callback, context);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Copies all dispatcher parameters, including listeners, from another event\r\n\t * dispatcher.\r\n\t *\r\n\t * @param source Source event dispatcher\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tif (source === this) {\r\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\r\n\t\t}\r\n\r\n\t\t$array.each(source._listeners, (x) => {\r\n\t\t\t// TODO is this correct ?\r\n\t\t\tif (!x.killed && x.shouldClone) {\r\n\t\t\t\tif (x.type === null) {\r\n\t\t\t\t\tthis.onAll(x.callback, x.context);\r\n\r\n\t\t\t\t} else if (x.once) {\r\n\t\t\t\t\tthis.once(x.type, x.callback, x.context);\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.on(x.type, x.callback, x.context);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * A version of the [[EventDispatcher]] that dispatches events for a specific\r\n * target object.\r\n *\r\n * @important\r\n */\r\nexport class TargetedEventDispatcher<Target, T> extends EventDispatcher<T> {\r\n\r\n\t/**\r\n\t * A target object which is originating events using this dispatcher.\r\n\t */\r\n\tpublic target: Target;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t *\r\n\t * @param target Event dispatcher target\r\n\t */\r\n\tconstructor(target: Target) {\r\n\t\tsuper();\r\n\t\tthis.target = target;\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all dispatcher parameters, including listeners, from another event\r\n\t * dispatcher.\r\n\t *\r\n\t * @param source Source event dispatcher\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tif (source === this) {\r\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\r\n\t\t}\r\n\r\n\t\t$array.each(source._listeners, (x) => {\r\n\t\t\t// TODO very hacky\r\n\t\t\tif (x.context === source.target) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// TODO is this correct ?\r\n\t\t\tif (!x.killed && x.shouldClone) {\r\n\t\t\t\tif (x.type === null) {\r\n\t\t\t\t\tthis.onAll(x.callback, x.context);\r\n\r\n\t\t\t\t} else if (x.once) {\r\n\t\t\t\t\tthis.once(x.type, x.callback, x.context);\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.on(x.type, x.callback, x.context);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n}\r\n"]}