{"version":3,"file":"JSONParser.js","sourceRoot":"","sources":["../../../../../src/.internal/core/data/JSONParser.ts"],"names":[],"mappings":"AAAA;;GAEG;;AAEH;;;;;GAKG;AACH,OAAO,EAAE,UAAU,EAAsB,MAAM,cAAc,CAAC;AAE9D,OAAO,KAAK,OAAO,MAAM,iBAAiB,CAAC;AAC3C,OAAO,KAAK,KAAK,MAAM,eAAe,CAAC;AA6BvC;;;;GAIG;AACH;IAAgC,8BAAU;IAA1C;QAAA,qEAoFC;QA9DA;;WAEG;QACI,iBAAW,GAAW,kBAAkB,CAAC;QAEhD;;;;WAIG;QACI,aAAO,GAAiB,EAAE,CAAC;;IAoDnC,CAAC;IAlFA;;;;;OAKG;IACI,iBAAM,GAAb,UAAc,IAAY;QACzB,IAAI;YAEH,mBAAmB;YACnB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YAEjB,qDAAqD;YACrD,OAAO,IAAI,CAAC;SACZ;QACD,OAAO,CAAC,EAAE;YACT,OAAO,KAAK,CAAC;SACb;IACF,CAAC;IAcD;;;;;OAKG;IACI,0BAAK,GAAZ,UAAa,IAAY;QAAzB,iBA0CC;QAxCA,cAAc;QACd,IAAI,GAAQ,CAAC;QAEb,cAAc;QACd,IAAI;YACH,IAAI,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gBACzB,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;aACvB;SACD;QAAC,OAAO,CAAC,EAAE;YACX,OAAO,SAAS,CAAC;SACjB;QAED,sDAAsD;QACtD,IAAI,KAAK,GAAG,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QACjD,IAAI,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC;QACnC,IAAI,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC;QAC/B,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,IAAI,KAAK,IAAI,KAAK,CAAC,EAAE;oCAG7C,CAAC,EAAM,GAAG;gBAClB,IAAI,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;gBACjB,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,UAAC,GAAG,EAAE,KAAK;oBAC5B,IAAI,KAAK,EAAE;wBACV,GAAG,CAAC,GAAG,CAAC,GAAG,KAAI,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;qBACvC;oBACD,IAAI,OAAO,EAAE;wBACZ,GAAG,CAAC,GAAG,CAAC,GAAG,KAAI,CAAC,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;qBAC7C;oBACD,IAAI,KAAK,EAAE;wBACV,GAAG,CAAC,GAAG,CAAC,GAAG,KAAI,CAAC,WAAW,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;qBAC3C;gBACF,CAAC,CAAC,CAAC;;YAbJ,iEAAiE;YACjE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE;wBAArC,CAAC,EAAM,GAAG;aAalB;SAED;QAED,mBAAmB;QACnB,0CAA0C;QAC1C,OAAO,GAAG,CAAC;IAEZ,CAAC;IAEF,iBAAC;AAAD,CAAC,AApFD,CAAgC,UAAU,GAoFzC","sourcesContent":["/**\r\n * JSON parser.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { DataParser, IDataParserOptions } from \"./DataParser\";\r\nimport { DateFormatter } from \"../formatters/DateFormatter\";\r\nimport * as $object from \"../utils/Object\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n\r\n/**\r\n * Defines options for JSON format parser\r\n */\r\nexport interface IJSONOptions extends IDataParserOptions {\r\n\r\n\t/**\r\n\t * A list of fields that should be treaded as numeric.\r\n\t *\r\n\t * Any information container in such fields will be converted to `number`.\r\n\t */\r\n\tnumberFields?: string[];\r\n\r\n\t/**\r\n\t * A list of fields that hold date/time infromation.\r\n\t *\r\n\t * Parser will try to convert such fields into `Date` objects.\r\n\t */\r\n\tdateFields?: string[];\r\n\r\n\t/**\r\n\t * A date formatted to be used when parsing dates.\r\n\t */\r\n\tdateFormatter?: DateFormatter;\r\n\r\n}\r\n\r\n/**\r\n * A parser for JSON.\r\n *\r\n * @important\r\n */\r\nexport class JSONParser extends DataParser {\r\n\r\n\t/**\r\n\t * Tests if the data is valid JSON.\r\n\t *\r\n\t * @param data  Source data\r\n\t * @return Is it JSON?\r\n\t */\r\n\tstatic isJSON(data: string): boolean {\r\n\t\ttry {\r\n\r\n\t\t\t// Try parsing JSON\r\n\t\t\tJSON.parse(data);\r\n\r\n\t\t\t// If we got to this point it means it's a valid JSON\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tcatch (e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Content-type suitable for JSON format.\r\n\t */\r\n\tpublic contentType: string = \"application/json\";\r\n\r\n\t/**\r\n\t * Parser options.\r\n\t *\r\n\t * @see {@link IJSONOptions} for description of each option\r\n\t */\r\n\tpublic options: IJSONOptions = {};\r\n\r\n\t/**\r\n\t * Parses and returns data.\r\n\t *\r\n\t * @param data  Unparsed data\r\n\t * @return Parsed data\r\n\t */\r\n\tpublic parse(data: string): any {\r\n\r\n\t\t// Init return\r\n\t\tlet res: any;\r\n\r\n\t\t// Try parsing\r\n\t\ttry {\r\n\t\t\tif ($type.hasValue(JSON)) {\r\n\t\t\t\tres = JSON.parse(data);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\t// Do we need to cast some fields to numbers or dates?\r\n\t\tlet empty = $type.hasValue(this.options.emptyAs);\r\n\t\tlet numbers = this.parsableNumbers;\r\n\t\tlet dates = this.parsableDates;\r\n\t\tif (Array.isArray(res) && (numbers || dates || empty)) {\r\n\r\n\t\t\t// Iterate through the data and check if it needs to be converted\r\n\t\t\tfor (let i = 0, len = res.length; i < len; i++) {\r\n\t\t\t\tlet row = res[i];\r\n\t\t\t\t$object.each(row, (key, value) => {\r\n\t\t\t\t\tif (empty) {\r\n\t\t\t\t\t\trow[key] = this.maybeToEmpty(row[key]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (numbers) {\r\n\t\t\t\t\t\trow[key] = this.maybeToNumber(key, row[key]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (dates) {\r\n\t\t\t\t\t\trow[key] = this.maybeToDate(key, row[key]);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Convert to array\r\n\t\t//return Array.isArray(res) ? res : [res];\r\n\t\treturn res;\r\n\r\n\t}\r\n\r\n}\r\n"]}