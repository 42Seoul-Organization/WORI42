{"version":3,"file":"DataParser.js","sourceRoot":"","sources":["../../../../../src/.internal/core/data/DataParser.ts"],"names":[],"mappings":"AAAA;;GAEG;AAGH;;;;;GAKG;AACH,OAAO,EAAE,aAAa,EAAE,MAAM,6BAA6B,CAAC;AAC5D,OAAO,KAAK,MAAM,MAAM,gBAAgB,CAAC;AACzC,OAAO,KAAK,KAAK,MAAM,eAAe,CAAC;AAuDvC;;;;;GAKG;AAEH;;GAEG;AACH;IAAA;IAmHA,CAAC;IArGA;;;;;;OAMG;IACI,0BAAK,GAAZ,UAAa,IAAY;QACxB,OAAO,EAAE,CAAC;IACX,CAAC;IAAA,CAAC;IAQF,sBAAc,uCAAe;QAN7B;;;;;WAKG;aACH;YACC,OAAO,IAAI,CAAC,OAAO,CAAC,YAAY,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC5E,CAAC;;;OAAA;IAED;;;;;;OAMG;IACO,kCAAa,GAAvB,UAAwB,KAAa,EAAE,KAAU;QAChD,IAAI,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;YACpD,OAAO,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;SACjC;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IAQD,sBAAc,qCAAa;QAN3B;;;;;WAKG;aACH;YACC,OAAO,IAAI,CAAC,OAAO,CAAC,UAAU,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACxE,CAAC;;;OAAA;IAED;;;;;;OAMG;IACO,gCAAW,GAArB,UAAsB,KAAa,EAAE,KAAU;QAC9C,IAAI,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;YAClD,OAAO,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;SAChE;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IAED;;;;;OAKG;IACO,iCAAY,GAAtB,UAAuB,KAAU;QAChC,IAAI,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,EAAE,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;YACpF,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC;SAC5B;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IAWD,sBAAc,qCAAa;QAT3B;;;;;;;;WAQG;aACH;YACC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE;gBAChC,IAAI,CAAC,OAAO,CAAC,aAAa,GAAG,IAAI,aAAa,CAAC;gBAC/C,IAAI,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE;oBAC5B,IAAI,CAAC,OAAO,CAAC,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC;iBAClD;aACD;YACD,OAAO,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC;QACnC,CAAC;;;OAAA;IAQD,sBAAc,kCAAU;QANxB;;;;;WAKG;aACH;YACC,OAAO,IAAI,CAAC,OAAO,CAAC,UAAU,IAAI,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC;QACtE,CAAC;;;OAAA;IAEF,iBAAC;AAAD,CAAC,AAnHD,IAmHC","sourcesContent":["/**\r\n * Data parser module.\r\n */\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { DateFormatter } from \"../formatters/DateFormatter\";\r\nimport * as $utils from \"../utils/Utils\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines common options for all data parsers.\r\n */\r\nexport interface IDataParserOptions {\r\n\r\n\t/**\r\n\t * Empty values (e.g. empty strings, `null`, etc.) will be replaced with\r\n\t * this.\r\n\t */\r\n\temptyAs?: any;\r\n\r\n\t/**\r\n\t * List of fields in data that hold numeric values. Parser will try to\r\n\t * convert the value in those fields to a `number`.\r\n\t */\r\n\tnumberFields?: string[];\r\n\r\n\t/**\r\n\t * List of fields in data that need to be treated as Dates, i.e. converted\r\n\t * to `Date` objects from whatever source format they are currently in.\r\n\t */\r\n\tdateFields?: string[];\r\n\r\n\t/**\r\n\t * An instance of [[DateFormatter]] to use when parsing string-based dates.\r\n\t * If it's not set, the parser will create it's own instance of\r\n\t * [[DateFormatter]], should any date parsing required. (`dateFields` is set)\r\n\t *\r\n\t * Unless `dateFormat` is set in parser options, the parser will try to look\r\n\t * for `dateFormat` in `dateFormatter`.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/#Parsing_Dates} Tutorial on date parsing\r\n\t */\r\n\tdateFormatter?: DateFormatter;\r\n\r\n\t/**\r\n\t * Override date format set in `dateFormatter`.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/#Parsing_Dates} Tutorial on date parsing\r\n\t */\r\n\tdateFormat?: string;\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Base class for the data parsers.\r\n */\r\nexport class DataParser {\r\n\r\n\t/**\r\n\t * Content type, relevant to the specific format.\r\n\t */\r\n\tpublic contentType: string;\r\n\r\n\t/**\r\n\t * Parser options.\r\n\t *\r\n\t * @see {@link IDataParserOptions} for description of each option\r\n\t */\r\n\tpublic options: IDataParserOptions;\r\n\r\n\t/**\r\n\t * A \"placeholder\" function for real parsers to override.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param data  Source data\r\n\t * @return Parsed data (empty)\r\n\t */\r\n\tpublic parse(data: string): any {\r\n\t\treturn [];\r\n\t};\r\n\r\n\t/**\r\n\t * Checks if there are any numeric fields that need to be converted to\r\n\t * numbers.\r\n\t *\r\n\t * @return Numeric fields?\r\n\t */\r\n\tprotected get parsableNumbers(): boolean {\r\n\t\treturn this.options.numberFields && (this.options.numberFields.length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a value to 'number' if it is in `numberFields`.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @param value  Value\r\n\t * @return Parsed or original value\r\n\t */\r\n\tprotected maybeToNumber(field: string, value: any): any {\r\n\t\tif (this.options.numberFields.indexOf(field) !== -1) {\r\n\t\t\treturn $utils.anyToNumber(value);\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if there are any date fields that need to be converted to `Date`\r\n\t * objects.\r\n\t *\r\n\t * @return Date fields?\r\n\t */\r\n\tprotected get parsableDates(): boolean {\r\n\t\treturn this.options.dateFields && (this.options.dateFields.length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a value to `Date` if it is in `dateFields`.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @param value  Value\r\n\t * @return Parsed or original value\r\n\t */\r\n\tprotected maybeToDate(field: string, value: any): any {\r\n\t\tif (this.options.dateFields.indexOf(field) !== -1) {\r\n\t\t\treturn this.options.dateFormatter.parse(value, this.dateFormat);\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces empty value with something else.\r\n\t *\r\n\t * @param value  Source value\r\n\t * @return Source value or replacement\r\n\t */\r\n\tprotected maybeToEmpty(value: any): any {\r\n\t\tif ((!$type.hasValue(value) || value == \"\") && $type.hasValue(this.options.emptyAs)) {\r\n\t\t\treturn this.options.emptyAs;\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * [[DateFormatter]] object for date parsing.\r\n\t *\r\n\t * If there was not [[DateFormatter]] supplied in parser options, a new one\r\n\t * is created.\r\n\t *\r\n\t * @return Date formatter\r\n\t * @see {@link DateFormatter}\r\n\t */\r\n\tprotected get dateFormatter(): DateFormatter {\r\n\t\tif (!this.options.dateFormatter) {\r\n\t\t\tthis.options.dateFormatter = new DateFormatter;\r\n\t\t\tif (this.options.dateFormat) {\r\n\t\t\t\tthis.options.dateFormat = this.options.dateFormat;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.options.dateFormatter;\r\n\t}\r\n\r\n\t/**\r\n\t * A date format to use when parsing dates.\r\n\t *\r\n\t * @return Date format\r\n\t * @see {@link DateFormatter}\r\n\t */\r\n\tprotected get dateFormat(): string {\r\n\t\treturn this.options.dateFormat || this.dateFormatter.inputDateFormat;\r\n\t}\r\n\r\n}\r\n"]}